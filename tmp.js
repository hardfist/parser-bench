(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["BizCharts"] = factory(require("react"), require("react-dom"));
	else
		root["BizCharts"] = factory(root["React"], root["ReactDOM"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__221__) {
return  (function(modules) { 
 	
 	var installedModules = {};
 	
 	function __webpack_require__(moduleId) {
 		
 		if(installedModules[moduleId]) {
 			return installedModules[moduleId].exports;
 		}
 		
 		var module = installedModules[moduleId] = {
 			i: moduleId,
 			l: false,
 			exports: {}
 		};
 		
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
 		
 		module.l = true;
 		
 		return module.exports;
 	}
 	
 	__webpack_require__.m = modules;
 	
 	__webpack_require__.c = installedModules;
 	
 	__webpack_require__.d = function(exports, name, getter) {
 		if(!__webpack_require__.o(exports, name)) {
 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
 		}
 	};
 	
 	__webpack_require__.r = function(exports) {
 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 		}
 		Object.defineProperty(exports, '__esModule', { value: true });
 	};
 	
 	
 	
 	
 	
 	__webpack_require__.t = function(value, mode) {
 		if(mode & 1) value = __webpack_require__(value);
 		if(mode & 8) return value;
 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
 		var ns = Object.create(null);
 		__webpack_require__.r(ns);
 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
 		return ns;
 	};
 	
 	__webpack_require__.n = function(module) {
 		var getter = module && module.__esModule ?
 			function getDefault() { return module['default']; } :
 			function getModuleExports() { return module; };
 		__webpack_require__.d(getter, 'a', getter);
 		return getter;
 	};
 	
 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
 	
 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 646);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Cache", {
  enumerable: true,
  get: function get() {
    return _cache.default;
  }
});
Object.defineProperty(exports, "assign", {
  enumerable: true,
  get: function get() {
    return _mix.default;
  }
});
Object.defineProperty(exports, "augment", {
  enumerable: true,
  get: function get() {
    return _augment.default;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function get() {
    return _clamp.default;
  }
});
Object.defineProperty(exports, "clearAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _clearAnimationFrame.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function get() {
    return _clone.default;
  }
});
Object.defineProperty(exports, "contains", {
  enumerable: true,
  get: function get() {
    return _contains.default;
  }
});
Object.defineProperty(exports, "debounce", {
  enumerable: true,
  get: function get() {
    return _debounce.default;
  }
});
Object.defineProperty(exports, "deepMix", {
  enumerable: true,
  get: function get() {
    return _deepMix.default;
  }
});
Object.defineProperty(exports, "difference", {
  enumerable: true,
  get: function get() {
    return _difference.default;
  }
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return _each.default;
  }
});
Object.defineProperty(exports, "endsWith", {
  enumerable: true,
  get: function get() {
    return _endsWith.default;
  }
});
Object.defineProperty(exports, "every", {
  enumerable: true,
  get: function get() {
    return _every.default;
  }
});
Object.defineProperty(exports, "extend", {
  enumerable: true,
  get: function get() {
    return _extend.default;
  }
});
Object.defineProperty(exports, "filter", {
  enumerable: true,
  get: function get() {
    return _filter.default;
  }
});
Object.defineProperty(exports, "find", {
  enumerable: true,
  get: function get() {
    return _find.default;
  }
});
Object.defineProperty(exports, "findIndex", {
  enumerable: true,
  get: function get() {
    return _findIndex.default;
  }
});
Object.defineProperty(exports, "firstValue", {
  enumerable: true,
  get: function get() {
    return _firstValue.default;
  }
});
Object.defineProperty(exports, "fixedBase", {
  enumerable: true,
  get: function get() {
    return _fixedBase.default;
  }
});
Object.defineProperty(exports, "flatten", {
  enumerable: true,
  get: function get() {
    return _flatten.default;
  }
});
Object.defineProperty(exports, "flattenDeep", {
  enumerable: true,
  get: function get() {
    return _flattenDeep.default;
  }
});
Object.defineProperty(exports, "forIn", {
  enumerable: true,
  get: function get() {
    return _forIn.default;
  }
});
Object.defineProperty(exports, "get", {
  enumerable: true,
  get: function get() {
    return _get.default;
  }
});
Object.defineProperty(exports, "getEllipsisText", {
  enumerable: true,
  get: function get() {
    return _getEllipsisText.default;
  }
});
Object.defineProperty(exports, "getRange", {
  enumerable: true,
  get: function get() {
    return _getRange.default;
  }
});
Object.defineProperty(exports, "getType", {
  enumerable: true,
  get: function get() {
    return _getType.default;
  }
});
Object.defineProperty(exports, "getWrapBehavior", {
  enumerable: true,
  get: function get() {
    return _getWrapBehavior.default;
  }
});
Object.defineProperty(exports, "group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
Object.defineProperty(exports, "groupBy", {
  enumerable: true,
  get: function get() {
    return _groupBy.default;
  }
});
Object.defineProperty(exports, "groupToMap", {
  enumerable: true,
  get: function get() {
    return _groupToMap.default;
  }
});
Object.defineProperty(exports, "has", {
  enumerable: true,
  get: function get() {
    return _has.default;
  }
});
Object.defineProperty(exports, "hasKey", {
  enumerable: true,
  get: function get() {
    return _hasKey.default;
  }
});
Object.defineProperty(exports, "hasValue", {
  enumerable: true,
  get: function get() {
    return _hasValue.default;
  }
});
Object.defineProperty(exports, "head", {
  enumerable: true,
  get: function get() {
    return _head.default;
  }
});
Object.defineProperty(exports, "identity", {
  enumerable: true,
  get: function get() {
    return _identity.default;
  }
});
Object.defineProperty(exports, "includes", {
  enumerable: true,
  get: function get() {
    return _contains.default;
  }
});
Object.defineProperty(exports, "indexOf", {
  enumerable: true,
  get: function get() {
    return _indexOf.default;
  }
});
Object.defineProperty(exports, "isArguments", {
  enumerable: true,
  get: function get() {
    return _isArguments.default;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _isArray.default;
  }
});
Object.defineProperty(exports, "isArrayLike", {
  enumerable: true,
  get: function get() {
    return _isArrayLike.default;
  }
});
Object.defineProperty(exports, "isBoolean", {
  enumerable: true,
  get: function get() {
    return _isBoolean.default;
  }
});
Object.defineProperty(exports, "isDate", {
  enumerable: true,
  get: function get() {
    return _isDate.default;
  }
});
Object.defineProperty(exports, "isDecimal", {
  enumerable: true,
  get: function get() {
    return _isDecimal.default;
  }
});
Object.defineProperty(exports, "isElement", {
  enumerable: true,
  get: function get() {
    return _isElement.default;
  }
});
Object.defineProperty(exports, "isEmpty", {
  enumerable: true,
  get: function get() {
    return _isEmpty.default;
  }
});
Object.defineProperty(exports, "isEqual", {
  enumerable: true,
  get: function get() {
    return _isEqual.default;
  }
});
Object.defineProperty(exports, "isEqualWith", {
  enumerable: true,
  get: function get() {
    return _isEqualWith.default;
  }
});
Object.defineProperty(exports, "isError", {
  enumerable: true,
  get: function get() {
    return _isError.default;
  }
});
Object.defineProperty(exports, "isEven", {
  enumerable: true,
  get: function get() {
    return _isEven.default;
  }
});
Object.defineProperty(exports, "isFinite", {
  enumerable: true,
  get: function get() {
    return _isFinite.default;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return _isFunction.default;
  }
});
Object.defineProperty(exports, "isInteger", {
  enumerable: true,
  get: function get() {
    return _isInteger.default;
  }
});
Object.defineProperty(exports, "isMatch", {
  enumerable: true,
  get: function get() {
    return _isMatch.default;
  }
});
Object.defineProperty(exports, "isNegative", {
  enumerable: true,
  get: function get() {
    return _isNegative.default;
  }
});
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return _isNil.default;
  }
});
Object.defineProperty(exports, "isNull", {
  enumerable: true,
  get: function get() {
    return _isNull.default;
  }
});
Object.defineProperty(exports, "isNumber", {
  enumerable: true,
  get: function get() {
    return _isNumber.default;
  }
});
Object.defineProperty(exports, "isNumberEqual", {
  enumerable: true,
  get: function get() {
    return _isNumberEqual.default;
  }
});
Object.defineProperty(exports, "isObject", {
  enumerable: true,
  get: function get() {
    return _isObject.default;
  }
});
Object.defineProperty(exports, "isObjectLike", {
  enumerable: true,
  get: function get() {
    return _isObjectLike.default;
  }
});
Object.defineProperty(exports, "isOdd", {
  enumerable: true,
  get: function get() {
    return _isOdd.default;
  }
});
Object.defineProperty(exports, "isPlainObject", {
  enumerable: true,
  get: function get() {
    return _isPlainObject.default;
  }
});
Object.defineProperty(exports, "isPositive", {
  enumerable: true,
  get: function get() {
    return _isPositive.default;
  }
});
Object.defineProperty(exports, "isPrototype", {
  enumerable: true,
  get: function get() {
    return _isPrototype.default;
  }
});
Object.defineProperty(exports, "isRegExp", {
  enumerable: true,
  get: function get() {
    return _isRegExp.default;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return _isString.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function get() {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isUndefined", {
  enumerable: true,
  get: function get() {
    return _isUndefined.default;
  }
});
Object.defineProperty(exports, "keys", {
  enumerable: true,
  get: function get() {
    return _keys.default;
  }
});
Object.defineProperty(exports, "last", {
  enumerable: true,
  get: function get() {
    return _last.default;
  }
});
Object.defineProperty(exports, "lowerCase", {
  enumerable: true,
  get: function get() {
    return _lowerCase.default;
  }
});
Object.defineProperty(exports, "lowerFirst", {
  enumerable: true,
  get: function get() {
    return _lowerFirst.default;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function get() {
    return _map.default;
  }
});
Object.defineProperty(exports, "mapValues", {
  enumerable: true,
  get: function get() {
    return _mapValues.default;
  }
});
Object.defineProperty(exports, "max", {
  enumerable: true,
  get: function get() {
    return _max.default;
  }
});
Object.defineProperty(exports, "maxBy", {
  enumerable: true,
  get: function get() {
    return _maxBy.default;
  }
});
Object.defineProperty(exports, "measureTextWidth", {
  enumerable: true,
  get: function get() {
    return _measureTextWidth.default;
  }
});
Object.defineProperty(exports, "memoize", {
  enumerable: true,
  get: function get() {
    return _memoize.default;
  }
});
Object.defineProperty(exports, "min", {
  enumerable: true,
  get: function get() {
    return _min.default;
  }
});
Object.defineProperty(exports, "minBy", {
  enumerable: true,
  get: function get() {
    return _minBy.default;
  }
});
Object.defineProperty(exports, "mix", {
  enumerable: true,
  get: function get() {
    return _mix.default;
  }
});
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return _mod.default;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function get() {
    return _noop.default;
  }
});
Object.defineProperty(exports, "number2color", {
  enumerable: true,
  get: function get() {
    return _number2color.default;
  }
});
Object.defineProperty(exports, "omit", {
  enumerable: true,
  get: function get() {
    return _omit.default;
  }
});
Object.defineProperty(exports, "parseRadius", {
  enumerable: true,
  get: function get() {
    return _parseRadius.default;
  }
});
Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function get() {
    return _pick.default;
  }
});
Object.defineProperty(exports, "pull", {
  enumerable: true,
  get: function get() {
    return _pull.default;
  }
});
Object.defineProperty(exports, "pullAt", {
  enumerable: true,
  get: function get() {
    return _pullAt.default;
  }
});
Object.defineProperty(exports, "reduce", {
  enumerable: true,
  get: function get() {
    return _reduce.default;
  }
});
Object.defineProperty(exports, "remove", {
  enumerable: true,
  get: function get() {
    return _remove.default;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.default;
  }
});
Object.defineProperty(exports, "set", {
  enumerable: true,
  get: function get() {
    return _set.default;
  }
});
Object.defineProperty(exports, "size", {
  enumerable: true,
  get: function get() {
    return _size.default;
  }
});
Object.defineProperty(exports, "some", {
  enumerable: true,
  get: function get() {
    return _some.default;
  }
});
Object.defineProperty(exports, "sortBy", {
  enumerable: true,
  get: function get() {
    return _sortBy.default;
  }
});
Object.defineProperty(exports, "startsWith", {
  enumerable: true,
  get: function get() {
    return _startsWith.default;
  }
});
Object.defineProperty(exports, "substitute", {
  enumerable: true,
  get: function get() {
    return _substitute.default;
  }
});
Object.defineProperty(exports, "throttle", {
  enumerable: true,
  get: function get() {
    return _throttle.default;
  }
});
Object.defineProperty(exports, "toArray", {
  enumerable: true,
  get: function get() {
    return _toArray.default;
  }
});
Object.defineProperty(exports, "toDegree", {
  enumerable: true,
  get: function get() {
    return _toDegree.default;
  }
});
Object.defineProperty(exports, "toInteger", {
  enumerable: true,
  get: function get() {
    return _toInteger.default;
  }
});
Object.defineProperty(exports, "toRadian", {
  enumerable: true,
  get: function get() {
    return _toRadian.default;
  }
});
Object.defineProperty(exports, "toString", {
  enumerable: true,
  get: function get() {
    return _toString.default;
  }
});
Object.defineProperty(exports, "union", {
  enumerable: true,
  get: function get() {
    return _union.default;
  }
});
Object.defineProperty(exports, "uniq", {
  enumerable: true,
  get: function get() {
    return _uniq.default;
  }
});
Object.defineProperty(exports, "uniqueId", {
  enumerable: true,
  get: function get() {
    return _uniqueId.default;
  }
});
Object.defineProperty(exports, "upperCase", {
  enumerable: true,
  get: function get() {
    return _upperCase.default;
  }
});
Object.defineProperty(exports, "upperFirst", {
  enumerable: true,
  get: function get() {
    return _upperFirst.default;
  }
});
Object.defineProperty(exports, "values", {
  enumerable: true,
  get: function get() {
    return _values.default;
  }
});
Object.defineProperty(exports, "valuesOfKey", {
  enumerable: true,
  get: function get() {
    return _valuesOfKey.default;
  }
});
Object.defineProperty(exports, "wrapBehavior", {
  enumerable: true,
  get: function get() {
    return _wrapBehavior.default;
  }
});
var _contains = _interopRequireDefault(__webpack_require__(238));
var _difference = _interopRequireDefault(__webpack_require__(655));
var _find = _interopRequireDefault(__webpack_require__(656));
var _findIndex = _interopRequireDefault(__webpack_require__(657));
var _firstValue = _interopRequireDefault(__webpack_require__(658));
var _flatten = _interopRequireDefault(__webpack_require__(659));
var _flattenDeep = _interopRequireDefault(__webpack_require__(660));
var _getRange = _interopRequireDefault(__webpack_require__(661));
var _pull = _interopRequireDefault(__webpack_require__(662));
var _pullAt = _interopRequireDefault(__webpack_require__(376));
var _reduce = _interopRequireDefault(__webpack_require__(377));
var _remove = _interopRequireDefault(__webpack_require__(663));
var _sortBy = _interopRequireDefault(__webpack_require__(664));
var _union = _interopRequireDefault(__webpack_require__(665));
var _uniq = _interopRequireDefault(__webpack_require__(378));
var _valuesOfKey = _interopRequireDefault(__webpack_require__(666));
var _head = _interopRequireDefault(__webpack_require__(667));
var _last = _interopRequireDefault(__webpack_require__(668));
var _startsWith = _interopRequireDefault(__webpack_require__(669));
var _endsWith = _interopRequireDefault(__webpack_require__(670));
var _filter = _interopRequireDefault(__webpack_require__(371));
var _every = _interopRequireDefault(__webpack_require__(671));
var _some = _interopRequireDefault(__webpack_require__(672));
var _group = _interopRequireDefault(__webpack_require__(673));
var _groupBy = _interopRequireDefault(__webpack_require__(380));
var _groupToMap = _interopRequireDefault(__webpack_require__(379));
var _getWrapBehavior = _interopRequireDefault(__webpack_require__(674));
var _wrapBehavior = _interopRequireDefault(__webpack_require__(675));
var _number2color = _interopRequireDefault(__webpack_require__(676));
var _parseRadius = _interopRequireDefault(__webpack_require__(677));
var _clamp = _interopRequireDefault(__webpack_require__(678));
var _fixedBase = _interopRequireDefault(__webpack_require__(679));
var _isDecimal = _interopRequireDefault(__webpack_require__(680));
var _isEven = _interopRequireDefault(__webpack_require__(681));
var _isInteger = _interopRequireDefault(__webpack_require__(682));
var _isNegative = _interopRequireDefault(__webpack_require__(683));
var _isNumberEqual = _interopRequireDefault(__webpack_require__(684));
var _isOdd = _interopRequireDefault(__webpack_require__(685));
var _isPositive = _interopRequireDefault(__webpack_require__(686));
var _max = _interopRequireDefault(__webpack_require__(374));
var _maxBy = _interopRequireDefault(__webpack_require__(687));
var _min = _interopRequireDefault(__webpack_require__(375));
var _minBy = _interopRequireDefault(__webpack_require__(688));
var _mod = _interopRequireDefault(__webpack_require__(689));
var _toDegree = _interopRequireDefault(__webpack_require__(690));
var _toInteger = _interopRequireDefault(__webpack_require__(691));
var _toRadian = _interopRequireDefault(__webpack_require__(692));
var _forIn = _interopRequireDefault(__webpack_require__(693));
var _has = _interopRequireDefault(__webpack_require__(381));
var _hasKey = _interopRequireDefault(__webpack_require__(694));
var _hasValue = _interopRequireDefault(__webpack_require__(695));
var _keys = _interopRequireDefault(__webpack_require__(373));
var _isMatch = _interopRequireDefault(__webpack_require__(372));
var _values = _interopRequireDefault(__webpack_require__(240));
var _lowerCase = _interopRequireDefault(__webpack_require__(696));
var _lowerFirst = _interopRequireDefault(__webpack_require__(697));
var _substitute = _interopRequireDefault(__webpack_require__(698));
var _upperCase = _interopRequireDefault(__webpack_require__(699));
var _upperFirst = _interopRequireDefault(__webpack_require__(700));
var _getType = _interopRequireDefault(__webpack_require__(382));
var _isArguments = _interopRequireDefault(__webpack_require__(701));
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _isArrayLike = _interopRequireDefault(__webpack_require__(56));
var _isBoolean = _interopRequireDefault(__webpack_require__(702));
var _isDate = _interopRequireDefault(__webpack_require__(703));
var _isError = _interopRequireDefault(__webpack_require__(704));
var _isFunction = _interopRequireDefault(__webpack_require__(57));
var _isFinite = _interopRequireDefault(__webpack_require__(705));
var _isNil = _interopRequireDefault(__webpack_require__(95));
var _isNull = _interopRequireDefault(__webpack_require__(706));
var _isNumber = _interopRequireDefault(__webpack_require__(86));
var _isObject = _interopRequireDefault(__webpack_require__(169));
var _isObjectLike = _interopRequireDefault(__webpack_require__(239));
var _isPlainObject = _interopRequireDefault(__webpack_require__(138));
var _isPrototype = _interopRequireDefault(__webpack_require__(383));
var _isRegExp = _interopRequireDefault(__webpack_require__(707));
var _isString = _interopRequireDefault(__webpack_require__(85));
var _isType = _interopRequireDefault(__webpack_require__(68));
var _isUndefined = _interopRequireDefault(__webpack_require__(708));
var _isElement = _interopRequireDefault(__webpack_require__(709));
var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(710));
var _clearAnimationFrame = _interopRequireDefault(__webpack_require__(711));
var _augment = _interopRequireDefault(__webpack_require__(712));
var _clone = _interopRequireDefault(__webpack_require__(713));
var _debounce = _interopRequireDefault(__webpack_require__(714));
var _memoize = _interopRequireDefault(__webpack_require__(384));
var _deepMix = _interopRequireDefault(__webpack_require__(715));
var _each = _interopRequireDefault(__webpack_require__(107));
var _extend = _interopRequireDefault(__webpack_require__(716));
var _indexOf = _interopRequireDefault(__webpack_require__(717));
var _isEmpty = _interopRequireDefault(__webpack_require__(718));
var _isEqual = _interopRequireDefault(__webpack_require__(385));
var _isEqualWith = _interopRequireDefault(__webpack_require__(719));
var _map = _interopRequireDefault(__webpack_require__(720));
var _mapValues = _interopRequireDefault(__webpack_require__(721));
var _mix = _interopRequireDefault(__webpack_require__(241));
var _get = _interopRequireDefault(__webpack_require__(722));
var _set = _interopRequireDefault(__webpack_require__(723));
var _pick = _interopRequireDefault(__webpack_require__(724));
var _omit = _interopRequireDefault(__webpack_require__(725));
var _throttle = _interopRequireDefault(__webpack_require__(726));
var _toArray = _interopRequireDefault(__webpack_require__(727));
var _toString = _interopRequireDefault(__webpack_require__(108));
var _uniqueId = _interopRequireDefault(__webpack_require__(728));
var _noop = _interopRequireDefault(__webpack_require__(729));
var _identity = _interopRequireDefault(__webpack_require__(730));
var _size = _interopRequireDefault(__webpack_require__(731));
var _measureTextWidth = _interopRequireDefault(__webpack_require__(386));
var _getEllipsisText = _interopRequireDefault(__webpack_require__(732));
var _cache = _interopRequireDefault(__webpack_require__(733));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldIn = __classPrivateFieldIn;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = void 0;
exports.__decorate = __decorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__read = __read;
exports.__rest = __rest;
exports.__spread = __spread;
exports.__spreadArray = __spreadArray;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));

var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    }
  };
  return _extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  _extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var _assign = function __assign() {
  exports.__assign = _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return _assign.apply(this, arguments);
};
exports.__assign = _assign;
function __rest(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};
exports.__createBinding = __createBinding;
function __exportStar(m, o) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }
  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }
  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
;
var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (0, _typeof2.default)(receiver) !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__3__;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var defineProperties = __webpack_require__(364);
var callBind = __webpack_require__(368);
var implementation = __webpack_require__(369);
var getPolyfill = __webpack_require__(370);
var shim = __webpack_require__(654);
var polyfill = callBind.apply(getPolyfill());

var bound = function assign(target, source1) {
  return polyfill(Object, arguments);
};
defineProperties(bound, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = bound;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  flow: true,
  pick: true,
  template: true,
  log: true,
  invariant: true,
  LEVEL: true,
  getContainerSize: true,
  findViewById: true,
  getViews: true,
  getSiblingViews: true,
  transformLabel: true,
  getSplinePath: true,
  deepAssign: true,
  kebabCase: true,
  renderStatistic: true,
  renderGaugeStatistic: true,
  measureTextWidth: true,
  isBetween: true,
  isRealNumber: true
};
Object.defineProperty(exports, "LEVEL", {
  enumerable: true,
  get: function get() {
    return _invariant.LEVEL;
  }
});
Object.defineProperty(exports, "deepAssign", {
  enumerable: true,
  get: function get() {
    return _deepAssign.deepAssign;
  }
});
Object.defineProperty(exports, "findViewById", {
  enumerable: true,
  get: function get() {
    return _view.findViewById;
  }
});
Object.defineProperty(exports, "flow", {
  enumerable: true,
  get: function get() {
    return _flow.flow;
  }
});
Object.defineProperty(exports, "getContainerSize", {
  enumerable: true,
  get: function get() {
    return _dom.getContainerSize;
  }
});
Object.defineProperty(exports, "getSiblingViews", {
  enumerable: true,
  get: function get() {
    return _view.getSiblingViews;
  }
});
Object.defineProperty(exports, "getSplinePath", {
  enumerable: true,
  get: function get() {
    return _path.getSplinePath;
  }
});
Object.defineProperty(exports, "getViews", {
  enumerable: true,
  get: function get() {
    return _view.getViews;
  }
});
Object.defineProperty(exports, "invariant", {
  enumerable: true,
  get: function get() {
    return _invariant.invariant;
  }
});
Object.defineProperty(exports, "isBetween", {
  enumerable: true,
  get: function get() {
    return _number.isBetween;
  }
});
Object.defineProperty(exports, "isRealNumber", {
  enumerable: true,
  get: function get() {
    return _number.isRealNumber;
  }
});
Object.defineProperty(exports, "kebabCase", {
  enumerable: true,
  get: function get() {
    return _kebabCase.kebabCase;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _invariant.log;
  }
});
Object.defineProperty(exports, "measureTextWidth", {
  enumerable: true,
  get: function get() {
    return _measureText.measureTextWidth;
  }
});
Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function get() {
    return _pick.pick;
  }
});
Object.defineProperty(exports, "renderGaugeStatistic", {
  enumerable: true,
  get: function get() {
    return _statistic.renderGaugeStatistic;
  }
});
Object.defineProperty(exports, "renderStatistic", {
  enumerable: true,
  get: function get() {
    return _statistic.renderStatistic;
  }
});
Object.defineProperty(exports, "template", {
  enumerable: true,
  get: function get() {
    return _template.template;
  }
});
Object.defineProperty(exports, "transformLabel", {
  enumerable: true,
  get: function get() {
    return _label.transformLabel;
  }
});
var _flow = __webpack_require__(1160);
var _pick = __webpack_require__(538);
var _template = __webpack_require__(1161);
var _invariant = __webpack_require__(539);
var _dom = __webpack_require__(1162);
var _geometry = __webpack_require__(1163);
Object.keys(_geometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _geometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _geometry[key];
    }
  });
});
var _view = __webpack_require__(540);
var _label = __webpack_require__(1164);
var _path = __webpack_require__(1165);
var _deepAssign = __webpack_require__(541);
var _kebabCase = __webpack_require__(1166);
var _statistic = __webpack_require__(542);
var _measureText = __webpack_require__(1167);
var _number = __webpack_require__(302);
var _data = __webpack_require__(197);
Object.keys(_data).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _data[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _data[key];
    }
  });
});
var _padding = __webpack_require__(121);
Object.keys(_padding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _padding[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _padding[key];
    }
  });
});

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
 __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
 var _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(235);
 var _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(619);
 var _antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
 var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__);
 var _antv_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);
 var _antv_scale__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_antv_scale__WEBPACK_IMPORTED_MODULE_3__);
 __webpack_require__.d(__webpack_exports__, "registerScale", function() { return _antv_scale__WEBPACK_IMPORTED_MODULE_3__["registerScale"]; });

 __webpack_require__.d(__webpack_exports__, "getScale", function() { return _antv_scale__WEBPACK_IMPORTED_MODULE_3__["getScale"]; });

 __webpack_require__.d(__webpack_exports__, "registerTickMethod", function() { return _antv_scale__WEBPACK_IMPORTED_MODULE_3__["registerTickMethod"]; });

 var _antv_g2plot_lib_core_global__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(187);
 var _antv_g2plot_lib_core_global__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_antv_g2plot_lib_core_global__WEBPACK_IMPORTED_MODULE_4__);
 __webpack_require__.d(__webpack_exports__, "setGlobal", function() { return _antv_g2plot_lib_core_global__WEBPACK_IMPORTED_MODULE_4__["setGlobal"]; });

 __webpack_require__.d(__webpack_exports__, "GLOBAL", function() { return _antv_g2plot_lib_core_global__WEBPACK_IMPORTED_MODULE_4__["GLOBAL"]; });

 var _extend_scale_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1318);
 var _animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(950);
 var _theme__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(459);
 __webpack_require__.d(__webpack_exports__, "createThemeByStyleSheet", function() { return _theme__WEBPACK_IMPORTED_MODULE_7__["c"]; });

 __webpack_require__.d(__webpack_exports__, "antvLight", function() { return _theme__WEBPACK_IMPORTED_MODULE_7__["b"]; });

 __webpack_require__.d(__webpack_exports__, "antvDark", function() { return _theme__WEBPACK_IMPORTED_MODULE_7__["a"]; });

 for(var __WEBPACK_IMPORT_KEY__ in _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__) if(["default","registerScale","getScale","registerTickMethod","setGlobal","GLOBAL","VERSION","setDefaultErrorFallback","createThemeByStyleSheet","antvLight","antvDark"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 var _boundary_ErrorBoundary__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(67);
 __webpack_require__.d(__webpack_exports__, "setDefaultErrorFallback", function() { return _boundary_ErrorBoundary__WEBPACK_IMPORTED_MODULE_8__["c"]; });













Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__["registerEngine"])('canvas', _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__["registerEngine"])('svg', _antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1__);


var VERSION = '4.1.21';


var rawGetPointByClient = _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__["Canvas"].prototype.getPointByClient;
_antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__["Canvas"].prototype.getPointByClient = function (clientX, clientY) {
  
  var raw = rawGetPointByClient.call(this, clientX, clientY);
  
  
  var el = this.get('el');
  var bbox = el.getBoundingClientRect();
  var setWidth = this.get('width');
  var setHeight = this.get('height');
  var realWidth = bbox.width,
    realHeight = bbox.height;
  
  return {
    x: raw.x / (realWidth / setWidth),
    y: raw.y / (realHeight / setHeight)
  };
};



 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var slicedToArray = __webpack_require__(133);
var slicedToArray_default = __webpack_require__.n(slicedToArray);


var _object_assign_4_1_4_object_assign = __webpack_require__(4);
var _object_assign_4_1_4_object_assign_default = __webpack_require__.n(_object_assign_4_1_4_object_assign);


var toConsumableArray = __webpack_require__(45);
var toConsumableArray_default = __webpack_require__.n(toConsumableArray);


var classCallCheck = __webpack_require__(9);
var classCallCheck_default = __webpack_require__.n(classCallCheck);


var createClass = __webpack_require__(10);
var createClass_default = __webpack_require__.n(createClass);


var inherits = __webpack_require__(12);
var inherits_default = __webpack_require__.n(inherits);


var possibleConstructorReturn = __webpack_require__(13);
var possibleConstructorReturn_default = __webpack_require__.n(possibleConstructorReturn);


var getPrototypeOf = __webpack_require__(5);
var getPrototypeOf_default = __webpack_require__.n(getPrototypeOf);


var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = __webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);


var unique_id = __webpack_require__(93);
var unique_id_default = __webpack_require__.n(unique_id);


var is_function = __webpack_require__(28);
var is_function_default = __webpack_require__.n(is_function);


var withContainer = __webpack_require__(132);


var ErrorBoundary = __webpack_require__(67);


var root = __webpack_require__(76);


var view = __webpack_require__(47);


var plotTools = __webpack_require__(165);


var shallowEqual = __webpack_require__(82);


var pickWithout = __webpack_require__(78);


var cloneDeep = __webpack_require__(75);


var constant = __webpack_require__(94);


var resize_observer = __webpack_require__(231);


var esm = __webpack_require__(0);



function getElementSize(ele) {
  var ctlSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return {
    width: Object(esm["isNumber"])(ctlSize.width) ? ctlSize.width : ele.clientWidth,
    height: Object(esm["isNumber"])(ctlSize.height) ? ctlSize.height : ele.clientHeight
  };
}

var polyfill = __webpack_require__(16);



var isEqual_isEqual = function isEqual(value, other) {
  if (Object(esm["isObject"])(value) && Object(esm["isObject"])(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (Object(esm["isArray"])(value) && Object(esm["isArray"])(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var _rst = true;
    for (var _i = 0; _i < value.length; _i++) {
      _rst = isEqual(value[_i], other[_i]);
      if (!_rst) {
        break;
      }
    }
    return _rst;
  }
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  return false;
};
 var utils_isEqual = (isEqual_isEqual);

var warning = __webpack_require__(17);
var warning_default = __webpack_require__.n(warning);


var locale = __webpack_require__(131);


var en_US = __webpack_require__(627);


var zh_CN = __webpack_require__(628);










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






















Object(locale["registerLocale"])('en-US', en_US["EN_US_LOCALE"]);
Object(locale["registerLocale"])('zh-CN', zh_CN["ZH_CN_LOCALE"]);
var DEFAULT_PLACEHOLDER = external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
  style: {
    position: 'absolute',
    top: '48%',
    left: '50%',
    color: '#aaa',
    textAlign: 'center'
  }
}, "\u6682\u65E0\u6570\u636E");
var DESCRIPTION_STYLE = {
  padding: '8px 24px 10px 10px',
  fontFamily: 'PingFang SC',
  fontSize: 12,
  color: 'grey',
  textAlign: 'left',
  lineHeight: '16px'
};
var TITLE_STYLE = {
  padding: '10px 0 0 10px',
  fontFamily: 'PingFang SC',
  fontSize: 18,
  color: 'black',
  textAlign: 'left',
  lineHeight: '20px'
};
var createPlot_BasePlot = function (_React$Component) {
  inherits_default()(BasePlot, _React$Component);
  var _super = _createSuper(BasePlot);
  function BasePlot() {
    var _this;
    classCallCheck_default()(this, BasePlot);
    _this = _super.apply(this, arguments);
    _this._context = {
      chart: null
    };
    return _this;
  }
  createClass_default()(BasePlot, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.children && this.g2Instance.chart) {
        this.g2Instance.chart.render();
      }
      Object(polyfill["b" ])(this.g2Instance, {}, this.props);
      this.g2Instance.data = this.props.data;
      this.preConfig = Object(cloneDeep["a" ])(Object(pickWithout["a" ])(this.props, [].concat(toConsumableArray_default()(constant["a" ]), ['container', 'PlotClass', 'onGetG2Instance', 'data'])));
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.children && this.g2Instance.chart) {
        this.g2Instance.chart.render();
      }
      
      Object(polyfill["b" ])(this.g2Instance, prevProps, this.props);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this2 = this;
      if (this.g2Instance) {
        setTimeout(function () {
          _this2.g2Instance.destroy();
          _this2.g2Instance = null;
          _this2._context.chart = null;
        }, 0);
      }
    }
  }, {
    key: "getG2Instance",
    value: function getG2Instance() {
      return this.g2Instance;
    }
  }, {
    key: "getChartView",
    value: function getChartView() {
      return this.g2Instance.chart;
    }
  }, {
    key: "checkInstanceReady",
    value: function checkInstanceReady() {
      
      var currentConfig = Object(pickWithout["a" ])(this.props, [].concat(toConsumableArray_default()(constant["a" ]), ['container', 'PlotClass', 'onGetG2Instance', 'data']));
      if (!this.g2Instance) {
        this.initInstance();
        this.g2Instance.render();
      } else if (this.shouldReCreate()) {
        
        this.g2Instance.destroy();
        this.initInstance();
        this.g2Instance.render();
      } else if (this.diffConfig()) {
        
        this.g2Instance.update(_object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()({}, currentConfig), {
          data: this.props.data
        }));
      } else if (this.diffData()) {
        this.g2Instance.changeData(this.props.data);
      }
      this.preConfig = Object(cloneDeep["a" ])(currentConfig);
      this.g2Instance.data = this.props.data;
    }
  }, {
    key: "initInstance",
    value: function initInstance() {
      var _a = this.props,
        container = _a.container,
        PlotClass = _a.PlotClass,
        onGetG2Instance = _a.onGetG2Instance,
        children = _a.children,
        options = __rest(_a, ["container", "PlotClass", "onGetG2Instance", "children"]);
      this.g2Instance = new PlotClass(container, options);
      this._context.chart = this.g2Instance;
      if (is_function_default()(onGetG2Instance)) {
        onGetG2Instance(this.g2Instance);
      }
    }
  }, {
    key: "diffConfig",
    value: function diffConfig() {
      
      var preConfig = this.preConfig || {};
      var currentConfig = Object(pickWithout["a" ])(this.props, [].concat(toConsumableArray_default()(constant["a" ]), ['container', 'PlotClass', 'onGetG2Instance', 'data']));
      return !utils_isEqual(preConfig, currentConfig);
    }
  }, {
    key: "diffData",
    value: function diffData() {
      
      var preData = this.g2Instance.data;
      var data = this.props.data;
      if (!Object(esm["isArray"])(preData) || !Object(esm["isArray"])(data)) {
        
        return !preData === data;
      }
      if (preData.length !== data.length) {
        return true;
      }
      var isEqual = true;
      preData.forEach(function (element, index) {
        if (!Object(shallowEqual["a" ])(element, data[index])) {
          isEqual = false;
        }
      });
      return !isEqual;
    }
  }, {
    key: "shouldReCreate",
    value: function shouldReCreate() {
      var forceUpdate = this.props.forceUpdate;
      if (forceUpdate) {
        return true;
      }
      return false;
    }
  }, {
    key: "render",
    value: function render() {
      this.checkInstanceReady();
      var chartView = this.getChartView();
      return external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(root["a" ].Provider, {
        value: this._context
      }, external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(view["a" ].Provider, {
        value: chartView
      }, external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
        key: unique_id_default()('plot-chart')
      }, this.props.children)));
    }
  }]);
  return BasePlot;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);
var BxPlot = Object(withContainer["a" ])(createPlot_BasePlot);
function createPlot(PlotClass, name) {
  var transCfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (cfg) {
    return cfg;
  };
  var Com = external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.forwardRef(function (props, _ref) {
    
    var title = props.title,
      description = props.description,
      _props$autoFit = props.autoFit,
      autoFit = _props$autoFit === void 0 ? true : _props$autoFit,
      forceFit = props.forceFit,
      _props$errorContent = props.errorContent,
      errorContent = _props$errorContent === void 0 ? ErrorBoundary["a" ] : _props$errorContent,
      containerStyle = props.containerStyle,
      containerProps = props.containerProps,
      placeholder = props.placeholder,
      ErrorBoundaryProps = props.ErrorBoundaryProps,
      isMaterial = props.isMaterial,
      cfg = __rest(props, ["title", "description", "autoFit", "forceFit", "errorContent", "containerStyle", "containerProps", "placeholder", "ErrorBoundaryProps", "isMaterial"]);
    var realCfg = transCfg(cfg);
    var container = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var titleDom = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var descDom = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var _useState = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useState"])(0),
      _useState2 = slicedToArray_default()(_useState, 2),
      chartHeight = _useState2[0],
      setChartHeight = _useState2[1];
    var resizeObserver = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var resizeFn = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(function () {
      if (!container.current) {
        return;
      }
      var containerSize = getElementSize(container.current, props);
      var titleSize = titleDom.current ? getElementSize(titleDom.current) : {
        width: 0,
        height: 0
      };
      var descSize = descDom.current ? getElementSize(descDom.current) : {
        width: 0,
        height: 0
      };
      var ch = containerSize.height - titleSize.height - descSize.height;
      if (ch === 0) {
        
        ch = 350;
      }
      if (ch < 20) {
        
        ch = 20;
      }
      
      if (Math.abs(chartHeight - ch) > 1) {
        setChartHeight(ch);
      }
    }, [container.current, titleDom.current, chartHeight, descDom.current]);
    var resize = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(Object(esm["debounce"])(resizeFn, 500), [resizeFn]);
    var FallbackComponent = external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.isValidElement(errorContent) ? function () {
      return errorContent;
    } : errorContent;
    
    if (placeholder && !realCfg.data) {
      var pl = placeholder === true ? DEFAULT_PLACEHOLDER : placeholder;
      
      return external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" ], _object_assign_4_1_4_object_assign_default()({
        FallbackComponent: FallbackComponent
      }, ErrorBoundaryProps), external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
        style: {
          width: props.width || '100%',
          height: props.height || 400,
          textAlign: 'center',
          position: 'relative'
        }
      }, pl));
    }
    var titleCfg = Object(plotTools["a" ])(title, false);
    var descriptionCfg = Object(plotTools["a" ])(description, false);
    var titleStyle = _object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()({}, TITLE_STYLE), titleCfg.style);
    var descStyle = _object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()({}, DESCRIPTION_STYLE), descriptionCfg.style), {
      top: titleStyle.height
    });
    var isAutoFit = forceFit !== undefined ? forceFit : autoFit;
    if (!Object(esm["isNil"])(forceFit)) {
      warning_default()(false, '请使用autoFit替代forceFit');
    }
    Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useEffect"])(function () {
      if (!isAutoFit) {
        if (container.current) {
          resizeFn();
          resizeObserver.current && resizeObserver.current.unobserve(container.current);
        }
      } else {
        if (container.current) {
          resizeFn();
          resizeObserver.current = new resize_observer["ResizeObserver"](resize);
          resizeObserver.current.observe(container.current);
        } else {
          setChartHeight(0);
        }
      }
      return function () {
        resizeObserver.current && container.current && resizeObserver.current.unobserve(container.current);
      };
    }, [container.current, isAutoFit]);
    return external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" ], _object_assign_4_1_4_object_assign_default()({
      FallbackComponent: FallbackComponent
    }, ErrorBoundaryProps), external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", _object_assign_4_1_4_object_assign_default()({
      ref: function ref(el) {
        container.current = el; 
        
        if (isMaterial) {
          if (Object(esm["isFunction"])(_ref)) {
            _ref(el);
          } else if (_ref) {
            _ref.current = el;
          }
        }
      },
      className: "bizcharts-plot"
    }, containerProps, {
      style: {
        position: 'relative',
        height: props.height || '100%',
        width: props.width || '100%'
      }
    }), titleCfg.visible && external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", _object_assign_4_1_4_object_assign_default()({
      ref: titleDom
    }, Object(polyfill["d" ])(realCfg), {
      className: "bizcharts-plot-title",
      style: titleStyle
    }), titleCfg.text), descriptionCfg.visible && external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", _object_assign_4_1_4_object_assign_default()({
      ref: descDom
    }, Object(polyfill["a" ])(realCfg), {
      className: "bizcharts-plot-description",
      style: descStyle
    }), descriptionCfg.text), !!chartHeight && external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(BxPlot
    
    , _object_assign_4_1_4_object_assign_default()({
      
      appendPadding: [10, 5, 10, 10],
      autoFit: isAutoFit,
      
      ref: isMaterial ? undefined : _ref
    }, realCfg, {
      PlotClass: PlotClass,
      containerStyle: _object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()({}, containerStyle), {
        height: chartHeight
      })
    }))));
  });
  Com.displayName = name || PlotClass.name;
  return Com;
}
 var src_createPlot = __webpack_exports__["a"] = (createPlot);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(734);
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6)["default"];
var assertThisInitialized = __webpack_require__(735);
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ELEMENT_RANGE_HIGHLIGHT_EVENTS = exports.BRUSH_FILTER_EVENTS = exports.VIEW_LIFE_CIRCLE = void 0;
var tslib_1 = __webpack_require__(1);

var core_1 = __webpack_require__(25);
var dark_1 = __webpack_require__(206);
var create_by_style_sheet_1 = __webpack_require__(106);
(0, core_1.registerTheme)('dark', (0, create_by_style_sheet_1.createThemeByStyleSheet)(dark_1.antvDark));

var CanvasEngine = (0, tslib_1.__importStar)(__webpack_require__(205));
var SVGEngine = (0, tslib_1.__importStar)(__webpack_require__(324));
var core_2 = __webpack_require__(25);
(0, core_2.registerEngine)('canvas', CanvasEngine);
(0, core_2.registerEngine)('svg', SVGEngine);

var core_3 = __webpack_require__(25);
var area_1 = (0, tslib_1.__importDefault)(__webpack_require__(325));
var edge_1 = (0, tslib_1.__importDefault)(__webpack_require__(326));
var heatmap_1 = (0, tslib_1.__importDefault)(__webpack_require__(327));
var interval_1 = (0, tslib_1.__importDefault)(__webpack_require__(328));
var line_1 = (0, tslib_1.__importDefault)(__webpack_require__(329));
var path_1 = (0, tslib_1.__importDefault)(__webpack_require__(158));
var point_1 = (0, tslib_1.__importDefault)(__webpack_require__(330));
var polygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(331));
var schema_1 = (0, tslib_1.__importDefault)(__webpack_require__(332));
var violin_1 = (0, tslib_1.__importDefault)(__webpack_require__(989));
(0, core_3.registerGeometry)('Polygon', polygon_1.default);
(0, core_3.registerGeometry)('Interval', interval_1.default);
(0, core_3.registerGeometry)('Schema', schema_1.default);
(0, core_3.registerGeometry)('Path', path_1.default);
(0, core_3.registerGeometry)('Point', point_1.default);
(0, core_3.registerGeometry)('Line', line_1.default);
(0, core_3.registerGeometry)('Area', area_1.default);
(0, core_3.registerGeometry)('Edge', edge_1.default);
(0, core_3.registerGeometry)('Heatmap', heatmap_1.default);
(0, core_3.registerGeometry)('Violin', violin_1.default);

__webpack_require__(991);
__webpack_require__(992);
__webpack_require__(993);
__webpack_require__(994);
__webpack_require__(995);
__webpack_require__(996);
__webpack_require__(465);
__webpack_require__(466);
__webpack_require__(467);
__webpack_require__(468);
__webpack_require__(469);
__webpack_require__(281);
__webpack_require__(470);
__webpack_require__(471);
__webpack_require__(472);
__webpack_require__(473);
__webpack_require__(474);
__webpack_require__(475);
__webpack_require__(997);
__webpack_require__(998);

var core_4 = __webpack_require__(25);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(100));
var interval_2 = (0, tslib_1.__importDefault)(__webpack_require__(163));
var pie_1 = (0, tslib_1.__importDefault)(__webpack_require__(164));
var polar_1 = (0, tslib_1.__importDefault)(__webpack_require__(214));
(0, core_4.registerGeometryLabel)('base', base_1.default);
(0, core_4.registerGeometryLabel)('interval', interval_2.default);
(0, core_4.registerGeometryLabel)('pie', pie_1.default);
(0, core_4.registerGeometryLabel)('polar', polar_1.default);

var core_5 = __webpack_require__(25);
var distribute_1 = __webpack_require__(333);
var outer_1 = __webpack_require__(999);
var spider_1 = __webpack_require__(1000);
var limit_in_canvas_1 = __webpack_require__(334);
var limit_in_shape_1 = __webpack_require__(335);
var overlap_1 = __webpack_require__(225);
var hide_overlap_1 = __webpack_require__(1001);
var adjust_color_1 = __webpack_require__(1003);
var adjust_position_1 = __webpack_require__(1005);
var hide_overlap_2 = __webpack_require__(1006);
var adjust_position_2 = __webpack_require__(1007);
var adjust_position_3 = __webpack_require__(1008);
var limit_in_plot_1 = __webpack_require__(1009);
(0, core_5.registerGeometryLabelLayout)('overlap', overlap_1.overlap);
(0, core_5.registerGeometryLabelLayout)('distribute', distribute_1.distribute);
(0, core_5.registerGeometryLabelLayout)('fixed-overlap', overlap_1.fixedOverlap);
(0, core_5.registerGeometryLabelLayout)('hide-overlap', hide_overlap_1.hideOverlap);
(0, core_5.registerGeometryLabelLayout)('limit-in-shape', limit_in_shape_1.limitInShape);
(0, core_5.registerGeometryLabelLayout)('limit-in-canvas', limit_in_canvas_1.limitInCanvas);
(0, core_5.registerGeometryLabelLayout)('limit-in-plot', limit_in_plot_1.limitInPlot);
(0, core_5.registerGeometryLabelLayout)('pie-outer', outer_1.pieOuterLabelLayout);
(0, core_5.registerGeometryLabelLayout)('adjust-color', adjust_color_1.adjustColor);
(0, core_5.registerGeometryLabelLayout)('interval-adjust-position', adjust_position_1.intervalAdjustPosition);
(0, core_5.registerGeometryLabelLayout)('interval-hide-overlap', hide_overlap_2.intervalHideOverlap);
(0, core_5.registerGeometryLabelLayout)('point-adjust-position', adjust_position_2.pointAdjustPosition);
(0, core_5.registerGeometryLabelLayout)('pie-spider', spider_1.pieSpiderLabelLayout);
(0, core_5.registerGeometryLabelLayout)('path-adjust-position', adjust_position_3.pathAdjustPosition);

var fade_1 = __webpack_require__(222);
var grow_in_1 = __webpack_require__(167);
var path_in_1 = __webpack_require__(162);
var position_update_1 = __webpack_require__(320);
var scale_in_1 = __webpack_require__(223);
var sector_path_update_1 = __webpack_require__(321);
var wave_in_1 = __webpack_require__(322);
var zoom_1 = __webpack_require__(224);
var core_6 = __webpack_require__(25);
(0, core_6.registerAnimation)('fade-in', fade_1.fadeIn);
(0, core_6.registerAnimation)('fade-out', fade_1.fadeOut);
(0, core_6.registerAnimation)('grow-in-x', grow_in_1.growInX);
(0, core_6.registerAnimation)('grow-in-xy', grow_in_1.growInXY);
(0, core_6.registerAnimation)('grow-in-y', grow_in_1.growInY);
(0, core_6.registerAnimation)('scale-in-x', scale_in_1.scaleInX);
(0, core_6.registerAnimation)('scale-in-y', scale_in_1.scaleInY);
(0, core_6.registerAnimation)('wave-in', wave_in_1.waveIn);
(0, core_6.registerAnimation)('zoom-in', zoom_1.zoomIn);
(0, core_6.registerAnimation)('zoom-out', zoom_1.zoomOut);
(0, core_6.registerAnimation)('position-update', position_update_1.positionUpdate);
(0, core_6.registerAnimation)('sector-path-update', sector_path_update_1.sectorPathUpdate);
(0, core_6.registerAnimation)('path-in', path_in_1.pathIn);

var core_7 = __webpack_require__(25);
var circle_1 = (0, tslib_1.__importDefault)(__webpack_require__(336));
var list_1 = (0, tslib_1.__importDefault)(__webpack_require__(337));
var matrix_1 = (0, tslib_1.__importDefault)(__webpack_require__(338));
var mirror_1 = (0, tslib_1.__importDefault)(__webpack_require__(339));
var rect_1 = (0, tslib_1.__importDefault)(__webpack_require__(340));
var tree_1 = (0, tslib_1.__importDefault)(__webpack_require__(341));
(0, core_7.registerFacet)('rect', rect_1.default);
(0, core_7.registerFacet)('mirror', mirror_1.default);
(0, core_7.registerFacet)('list', list_1.default);
(0, core_7.registerFacet)('matrix', matrix_1.default);
(0, core_7.registerFacet)('circle', circle_1.default);
(0, core_7.registerFacet)('tree', tree_1.default);

var core_8 = __webpack_require__(25);
var annotation_1 = (0, tslib_1.__importDefault)(__webpack_require__(319));
var axis_1 = (0, tslib_1.__importDefault)(__webpack_require__(342));
var legend_1 = (0, tslib_1.__importDefault)(__webpack_require__(343));
var slider_1 = (0, tslib_1.__importDefault)(__webpack_require__(344));
var tooltip_1 = (0, tslib_1.__importDefault)(__webpack_require__(204));
var scrollbar_1 = (0, tslib_1.__importDefault)(__webpack_require__(1013));

(0, core_8.registerComponentController)('axis', axis_1.default);
(0, core_8.registerComponentController)('legend', legend_1.default);
(0, core_8.registerComponentController)('tooltip', tooltip_1.default);
(0, core_8.registerComponentController)('annotation', annotation_1.default);
(0, core_8.registerComponentController)('slider', slider_1.default);
(0, core_8.registerComponentController)('scrollbar', scrollbar_1.default);

var core_9 = __webpack_require__(25);
var active_region_1 = (0, tslib_1.__importDefault)(__webpack_require__(345));
var sibling_1 = (0, tslib_1.__importDefault)(__webpack_require__(346));
var geometry_1 = (0, tslib_1.__importDefault)(__webpack_require__(127));
var ellipsis_text_1 = (0, tslib_1.__importDefault)(__webpack_require__(347));
var active_1 = (0, tslib_1.__importDefault)(__webpack_require__(348));
var link_by_color_1 = (0, tslib_1.__importDefault)(__webpack_require__(349));
var range_active_1 = (0, tslib_1.__importDefault)(__webpack_require__(350));
var single_active_1 = (0, tslib_1.__importDefault)(__webpack_require__(351));
var highlight_1 = (0, tslib_1.__importDefault)(__webpack_require__(159));
var highlight_by_color_1 = (0, tslib_1.__importDefault)(__webpack_require__(352));
var highlight_by_x_1 = (0, tslib_1.__importDefault)(__webpack_require__(353));
var range_highlight_1 = (0, tslib_1.__importStar)(__webpack_require__(226));
Object.defineProperty(exports, "ELEMENT_RANGE_HIGHLIGHT_EVENTS", {
  enumerable: true,
  get: function get() {
    return range_highlight_1.ELEMENT_RANGE_HIGHLIGHT_EVENTS;
  }
});
var single_highlight_1 = (0, tslib_1.__importDefault)(__webpack_require__(354));
var range_selected_1 = (0, tslib_1.__importDefault)(__webpack_require__(355));
var selected_1 = (0, tslib_1.__importDefault)(__webpack_require__(356));
var single_selected_1 = (0, tslib_1.__importDefault)(__webpack_require__(357));
var list_active_1 = (0, tslib_1.__importDefault)(__webpack_require__(358));
var list_highlight_1 = (0, tslib_1.__importDefault)(__webpack_require__(227));
var list_selected_1 = (0, tslib_1.__importDefault)(__webpack_require__(359));
var list_unchecked_1 = (0, tslib_1.__importDefault)(__webpack_require__(360));
var list_checked_1 = (0, tslib_1.__importDefault)(__webpack_require__(1015));
var circle_2 = (0, tslib_1.__importDefault)(__webpack_require__(1016));
var dim_rect_1 = (0, tslib_1.__importDefault)(__webpack_require__(1017));
var path_2 = (0, tslib_1.__importDefault)(__webpack_require__(478));
var rect_2 = (0, tslib_1.__importDefault)(__webpack_require__(477));
var smooth_path_1 = (0, tslib_1.__importDefault)(__webpack_require__(1018));
var cursor_1 = (0, tslib_1.__importDefault)(__webpack_require__(361));
var filter_1 = (0, tslib_1.__importDefault)(__webpack_require__(362));
var range_filter_1 = (0, tslib_1.__importStar)(__webpack_require__(479));
Object.defineProperty(exports, "BRUSH_FILTER_EVENTS", {
  enumerable: true,
  get: function get() {
    return range_filter_1.BRUSH_FILTER_EVENTS;
  }
});
var sibling_filter_1 = (0, tslib_1.__importDefault)(__webpack_require__(1019));
var filter_2 = (0, tslib_1.__importDefault)(__webpack_require__(1020));
var sibling_filter_2 = (0, tslib_1.__importDefault)(__webpack_require__(1021));
var button_1 = (0, tslib_1.__importDefault)(__webpack_require__(1022));
var drag_1 = (0, tslib_1.__importDefault)(__webpack_require__(1023));
var move_1 = (0, tslib_1.__importDefault)(__webpack_require__(1024));
var scale_translate_1 = (0, tslib_1.__importDefault)(__webpack_require__(1025));
var scale_zoom_1 = (0, tslib_1.__importDefault)(__webpack_require__(1026));
var mousewheel_scroll_1 = (0, tslib_1.__importDefault)(__webpack_require__(1027));
(0, core_9.registerAction)('tooltip', geometry_1.default);
(0, core_9.registerAction)('sibling-tooltip', sibling_1.default);
(0, core_9.registerAction)('ellipsis-text', ellipsis_text_1.default);
(0, core_9.registerAction)('element-active', active_1.default);
(0, core_9.registerAction)('element-single-active', single_active_1.default);
(0, core_9.registerAction)('element-range-active', range_active_1.default);
(0, core_9.registerAction)('element-highlight', highlight_1.default);
(0, core_9.registerAction)('element-highlight-by-x', highlight_by_x_1.default);
(0, core_9.registerAction)('element-highlight-by-color', highlight_by_color_1.default);
(0, core_9.registerAction)('element-single-highlight', single_highlight_1.default);
(0, core_9.registerAction)('element-range-highlight', range_highlight_1.default);
(0, core_9.registerAction)('element-sibling-highlight', range_highlight_1.default, {
  effectSiblings: true,
  effectByRecord: true
});
(0, core_9.registerAction)('element-selected', selected_1.default);
(0, core_9.registerAction)('element-single-selected', single_selected_1.default);
(0, core_9.registerAction)('element-range-selected', range_selected_1.default);
(0, core_9.registerAction)('element-link-by-color', link_by_color_1.default);
(0, core_9.registerAction)('active-region', active_region_1.default);
(0, core_9.registerAction)('list-active', list_active_1.default);
(0, core_9.registerAction)('list-selected', list_selected_1.default);
(0, core_9.registerAction)('list-highlight', list_highlight_1.default);
(0, core_9.registerAction)('list-unchecked', list_unchecked_1.default);
(0, core_9.registerAction)('list-checked', list_checked_1.default);
(0, core_9.registerAction)('legend-item-highlight', list_highlight_1.default, {
  componentNames: ['legend']
});
(0, core_9.registerAction)('axis-label-highlight', list_highlight_1.default, {
  componentNames: ['axis']
});
(0, core_9.registerAction)('rect-mask', rect_2.default);
(0, core_9.registerAction)('x-rect-mask', dim_rect_1.default, {
  dim: 'x'
});
(0, core_9.registerAction)('y-rect-mask', dim_rect_1.default, {
  dim: 'y'
});
(0, core_9.registerAction)('circle-mask', circle_2.default);
(0, core_9.registerAction)('path-mask', path_2.default);
(0, core_9.registerAction)('smooth-path-mask', smooth_path_1.default);
(0, core_9.registerAction)('cursor', cursor_1.default);
(0, core_9.registerAction)('data-filter', filter_1.default);
(0, core_9.registerAction)('brush', range_filter_1.default);
(0, core_9.registerAction)('brush-x', range_filter_1.default, {
  dims: ['x']
});
(0, core_9.registerAction)('brush-y', range_filter_1.default, {
  dims: ['y']
});
(0, core_9.registerAction)('sibling-filter', sibling_filter_1.default);
(0, core_9.registerAction)('sibling-x-filter', sibling_filter_1.default);
(0, core_9.registerAction)('sibling-y-filter', sibling_filter_1.default);
(0, core_9.registerAction)('element-filter', filter_2.default);
(0, core_9.registerAction)('element-sibling-filter', sibling_filter_2.default);
(0, core_9.registerAction)('element-sibling-filter-record', sibling_filter_2.default, {
  byRecord: true
});
(0, core_9.registerAction)('view-drag', drag_1.default);
(0, core_9.registerAction)('view-move', move_1.default);
(0, core_9.registerAction)('scale-translate', scale_translate_1.default);
(0, core_9.registerAction)('scale-zoom', scale_zoom_1.default);
(0, core_9.registerAction)('reset-button', button_1.default, {
  name: 'reset-button',
  text: 'reset'
});
(0, core_9.registerAction)('mousewheel-scroll', mousewheel_scroll_1.default);

var core_10 = __webpack_require__(25);
function isPointInView(context) {
  return context.isInPlot();
}

(0, core_10.registerInteraction)('tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:touchmove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:leave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:touchend',
    action: 'tooltip:hide'
  }]
});
(0, core_10.registerInteraction)('ellipsis-text', {
  start: [{
    trigger: 'legend-item-name:mousemove',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'legend-item-name:touchstart',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'axis-label:mousemove',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'axis-label:touchstart',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'legend-item-name:mouseleave',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'legend-item-name:touchend',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'axis-label:mouseleave',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'axis-label:touchend',
    action: 'ellipsis-text:hide'
  }]
});

(0, core_10.registerInteraction)('element-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-active:active'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-active:reset'
  }]
});

(0, core_10.registerInteraction)('element-selected', {
  start: [{
    trigger: 'element:click',
    action: 'element-selected:toggle'
  }]
});

(0, core_10.registerInteraction)('element-highlight', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight:reset'
  }]
});

(0, core_10.registerInteraction)('element-highlight-by-x', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-x:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-x:reset'
  }]
});

(0, core_10.registerInteraction)('element-highlight-by-color', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-color:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-color:reset'
  }]
});

(0, core_10.registerInteraction)('legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: ['list-active:active', 'element-active:active']
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: ['list-active:reset', 'element-active:reset']
  }]
});

(0, core_10.registerInteraction)('legend-highlight', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: ['legend-item-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: ['legend-item-highlight:reset', 'element-highlight:reset']
  }]
});

(0, core_10.registerInteraction)('axis-label-highlight', {
  start: [{
    trigger: 'axis-label:mouseenter',
    action: ['axis-label-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'axis-label:mouseleave',
    action: ['axis-label-highlight:reset', 'element-highlight:reset']
  }]
});

(0, core_10.registerInteraction)('element-list-highlight', {
  start: [{
    trigger: 'element:mouseenter',
    action: ['list-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: ['list-highlight:reset', 'element-highlight:reset']
  }]
});

(0, core_10.registerInteraction)('element-range-highlight', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'mask:mouseenter',
    action: 'cursor:move'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }, {
    trigger: 'mask:mouseleave',
    action: 'cursor:crosshair'
  }],
  start: [{
    trigger: 'plot:mousedown',
    isEnable: function isEnable(context) {
      
      return !context.isInShape('mask');
    },
    action: ['rect-mask:start', 'rect-mask:show']
  }, {
    trigger: 'mask:dragstart',
    action: ['rect-mask:moveStart']
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: ['rect-mask:resize']
  }, {
    trigger: 'mask:drag',
    action: ['rect-mask:move']
  }, {
    trigger: 'mask:change',
    action: ['element-range-highlight:highlight']
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: ['rect-mask:end']
  }, {
    trigger: 'mask:dragend',
    action: ['rect-mask:moveEnd']
  }, {
    trigger: 'document:mouseup',
    isEnable: function isEnable(context) {
      return !context.isInPlot();
    },
    action: ['element-range-highlight:clear', 'rect-mask:end', 'rect-mask:hide']
  }],
  rollback: [{
    trigger: 'dblclick',
    action: ['element-range-highlight:clear', 'rect-mask:hide']
  }]
});
(0, core_10.registerInteraction)('brush', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: ['brush:start', 'rect-mask:start', 'rect-mask:show']
  }],
  processing: [{
    trigger: 'mousemove',
    isEnable: isPointInView,
    action: ['rect-mask:resize']
  }],
  end: [{
    trigger: 'mouseup',
    isEnable: isPointInView,
    action: ['brush:filter', 'brush:end', 'rect-mask:end', 'rect-mask:hide', 'reset-button:show']
  }],
  rollback: [{
    trigger: 'reset-button:click',
    action: ['brush:reset', 'reset-button:hide', 'cursor:crosshair']
  }]
});
(0, core_10.registerInteraction)('brush-visible', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'plot:mousedown',
    action: ['rect-mask:start', 'rect-mask:show']
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: ['rect-mask:resize']
  }, {
    trigger: 'mask:change',
    action: ['element-range-highlight:highlight']
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: ['rect-mask:end', 'rect-mask:hide', 'element-filter:filter', 'element-range-highlight:clear']
  }],
  rollback: [{
    trigger: 'dblclick',
    action: ['element-filter:clear']
  }]
});
(0, core_10.registerInteraction)('brush-x', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: ['brush-x:start', 'x-rect-mask:start', 'x-rect-mask:show']
  }],
  processing: [{
    trigger: 'mousemove',
    isEnable: isPointInView,
    action: ['x-rect-mask:resize']
  }],
  end: [{
    trigger: 'mouseup',
    isEnable: isPointInView,
    action: ['brush-x:filter', 'brush-x:end', 'x-rect-mask:end', 'x-rect-mask:hide']
  }],
  rollback: [{
    trigger: 'dblclick',
    action: ['brush-x:reset']
  }]
});
(0, core_10.registerInteraction)('element-path-highlight', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: 'path-mask:start'
  }, {
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: 'path-mask:show'
  }],
  processing: [{
    trigger: 'mousemove',
    action: 'path-mask:addPoint'
  }],
  end: [{
    trigger: 'mouseup',
    action: 'path-mask:end'
  }],
  rollback: [{
    trigger: 'dblclick',
    action: 'path-mask:hide'
  }]
});

(0, core_10.registerInteraction)('element-single-selected', {
  start: [{
    trigger: 'element:click',
    action: 'element-single-selected:toggle'
  }]
});

(0, core_10.registerInteraction)('legend-filter', {
  showEnable: [{
    trigger: 'legend-item:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'legend-item:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'legend-item:click',
    action: ['list-unchecked:toggle', 'data-filter:filter']
  }]
});

(0, core_10.registerInteraction)('continuous-filter', {
  start: [{
    trigger: 'legend:valuechanged',
    action: 'data-filter:filter'
  }]
});

(0, core_10.registerInteraction)('continuous-visible-filter', {
  start: [{
    trigger: 'legend:valuechanged',
    action: 'element-filter:filter'
  }]
});

(0, core_10.registerInteraction)('legend-visible-filter', {
  showEnable: [{
    trigger: 'legend-item:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'legend-item:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'legend-item:click',
    action: ['list-unchecked:toggle', 'element-filter:filter']
  }]
});

(0, core_10.registerInteraction)('active-region', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'active-region:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'active-region:hide'
  }]
});
function isWheelDown(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}
(0, core_10.registerInteraction)('view-zoom', {
  start: [{
    trigger: 'plot:mousewheel',
    isEnable: function isEnable(context) {
      return isWheelDown(context.event);
    },
    action: 'scale-zoom:zoomOut',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:mousewheel',
    isEnable: function isEnable(context) {
      return !isWheelDown(context.event);
    },
    action: 'scale-zoom:zoomIn',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }]
});
(0, core_10.registerInteraction)('sibling-tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'sibling-tooltip:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'sibling-tooltip:hide'
  }]
});
(0, core_10.registerInteraction)('plot-mousewheel-scroll', {
  start: [{
    trigger: 'plot:mousewheel',
    action: 'mousewheel-scroll:scroll'
  }]
});

var constant_1 = __webpack_require__(21);
Object.defineProperty(exports, "VIEW_LIFE_CIRCLE", {
  enumerable: true,
  get: function get() {
    return constant_1.VIEW_LIFE_CIRCLE;
  }
});
(0, tslib_1.__exportStar)(__webpack_require__(25), exports);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var flow_1 = __webpack_require__(1056);
Object.defineProperty(exports, "flow", {
  enumerable: true,
  get: function get() {
    return flow_1.flow;
  }
});
var pick_1 = __webpack_require__(499);
Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function get() {
    return pick_1.pick;
  }
});
var template_1 = __webpack_require__(1057);
Object.defineProperty(exports, "template", {
  enumerable: true,
  get: function get() {
    return template_1.template;
  }
});
var invariant_1 = __webpack_require__(500);
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return invariant_1.log;
  }
});
Object.defineProperty(exports, "invariant", {
  enumerable: true,
  get: function get() {
    return invariant_1.invariant;
  }
});
Object.defineProperty(exports, "LEVEL", {
  enumerable: true,
  get: function get() {
    return invariant_1.LEVEL;
  }
});
var dom_1 = __webpack_require__(1058);
Object.defineProperty(exports, "getContainerSize", {
  enumerable: true,
  get: function get() {
    return dom_1.getContainerSize;
  }
});
tslib_1.__exportStar(__webpack_require__(1059), exports);
var view_1 = __webpack_require__(501);
Object.defineProperty(exports, "findViewById", {
  enumerable: true,
  get: function get() {
    return view_1.findViewById;
  }
});
Object.defineProperty(exports, "getViews", {
  enumerable: true,
  get: function get() {
    return view_1.getViews;
  }
});
Object.defineProperty(exports, "getSiblingViews", {
  enumerable: true,
  get: function get() {
    return view_1.getSiblingViews;
  }
});
var label_1 = __webpack_require__(1060);
Object.defineProperty(exports, "transformLabel", {
  enumerable: true,
  get: function get() {
    return label_1.transformLabel;
  }
});
var path_1 = __webpack_require__(1061);
Object.defineProperty(exports, "getSplinePath", {
  enumerable: true,
  get: function get() {
    return path_1.getSplinePath;
  }
});
var deep_assign_1 = __webpack_require__(502);
Object.defineProperty(exports, "deepAssign", {
  enumerable: true,
  get: function get() {
    return deep_assign_1.deepAssign;
  }
});
var kebab_case_1 = __webpack_require__(1062);
Object.defineProperty(exports, "kebabCase", {
  enumerable: true,
  get: function get() {
    return kebab_case_1.kebabCase;
  }
});
var statistic_1 = __webpack_require__(503);
Object.defineProperty(exports, "renderStatistic", {
  enumerable: true,
  get: function get() {
    return statistic_1.renderStatistic;
  }
});
Object.defineProperty(exports, "renderGaugeStatistic", {
  enumerable: true,
  get: function get() {
    return statistic_1.renderGaugeStatistic;
  }
});
var measure_text_1 = __webpack_require__(1063);
Object.defineProperty(exports, "measureTextWidth", {
  enumerable: true,
  get: function get() {
    return measure_text_1.measureTextWidth;
  }
});
var number_1 = __webpack_require__(291);
Object.defineProperty(exports, "isBetween", {
  enumerable: true,
  get: function get() {
    return number_1.isBetween;
  }
});
Object.defineProperty(exports, "isRealNumber", {
  enumerable: true,
  get: function get() {
    return number_1.isRealNumber;
  }
});
tslib_1.__exportStar(__webpack_require__(292), exports);
tslib_1.__exportStar(__webpack_require__(293), exports);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "f", function() { return replaceApi; });
 __webpack_require__.d(__webpack_exports__, "e", function() { return polyfillVisible; });
 __webpack_require__.d(__webpack_exports__, "c", function() { return polyfillOptions; });
 __webpack_require__.d(__webpack_exports__, "b", function() { return polyfillEvents; });
 __webpack_require__.d(__webpack_exports__, "d", function() { return polyfillTitleEvent; });
 __webpack_require__.d(__webpack_exports__, "a", function() { return polyfillDescriptionEvent; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
 var warning__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
 var _antv_util__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_util__WEBPACK_IMPORTED_MODULE_2__);
 var _utils_data_transform_sum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(230);
 var _components_Chart_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(137);






var replaceApi = function replaceApi(replaceApiList, options) {
  replaceApiList.forEach(function (item) {
    var sourceKey = item.sourceKey,
      targetKey = item.targetKey,
      notice = item.notice;
    var value = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, sourceKey);
    if (value) {
      warning__WEBPACK_IMPORTED_MODULE_1___default()(false, notice);
      Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(options, targetKey, value);
    }
  });
};
var polyfillAxis = function polyfillAxis(cfg, name) {
  var options = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(cfg, name);
  if (options === false || options === null) {
    cfg[name] = null;
    return;
  }
  if (options === undefined) {
    return;
  }
  if (options === true) {
    cfg[name] = {};
    return;
  }
  if (!Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isObject"])(options)) {
    warning__WEBPACK_IMPORTED_MODULE_1___default()(true, "".concat(name, " \u914D\u7F6E\u53C2\u6570\u4E0D\u6B63\u786E"));
    return;
  }
  polyfillVisible(options, 'line', null);
  polyfillVisible(options, 'grid', null);
  polyfillVisible(options, 'label', null);
  polyfillVisible(options, 'tickLine', null);
  polyfillVisible(options, 'title', null);
  var label = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, 'label');
  if (label) {
    if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isObject"])(label)) {
      var suffix = label.suffix;
      if (suffix) {
        
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(label, 'formatter', function (val) {
          return "".concat(val).concat(suffix);
        });
      }
      // @ts-ignore
      var offsetX = label.offsetX,
        offsetY = label.offsetY,
        offset = label.offset;
      if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offset) && (!Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetX) || !Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetY))) {
        if (name === 'xAxis') {
          Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(label, 'offset', !Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetX) ? offsetX : offsetY);
        }
        if (name === 'yAxis') {
          Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(label, 'offset', !Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetY) ? offsetY : offsetX);
        }
      }
    }
  }
  cfg[name] = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, options), {
    label: label
  });
};

var polyfillVisible = function polyfillVisible(polyfillOpt, path) {
  var negativeValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var vis = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, "".concat(path, ".visible"));
  if (vis === false || vis === null) {
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, path, negativeValue);
  }
  return vis;
};
var polyfillOptions = function polyfillOptions(opt) {
  var polyfillOpt = object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, opt);
  
  polyfillVisible(polyfillOpt, 'tooltip');
  
  var legendVis = polyfillVisible(polyfillOpt, 'legend');
  if (legendVis) {
    polyfillVisible(polyfillOpt, 'legend.title');
    var position = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.position');
    if (position) {
      Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'legend.position', {
        'top-center': 'top',
        'right-center': 'right',
        'left-center': 'left',
        'bottom-center': 'bottom'
      }[position] || position);
    }
  }
  var formatter = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.formatter');
  if (formatter) {
    var itemName = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.itemName', {});
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'legend.itemName', object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, itemName), {
      formatter: formatter
    }));
  }
  var textConfig = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.text');
  if (textConfig) {
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'legend.itemName', textConfig);
  }
  
  polyfillVisible(polyfillOpt, 'label');
  
  polyfillAxis(polyfillOpt, 'xAxis');
  polyfillAxis(polyfillOpt, 'yAxis');
  
  var guideLine = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'guideLine', []);
  var data = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'data', []);
  var yField = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'yField', 'y');
  guideLine.forEach(function (element) {
    if (data.length > 0) {
      var y = 'median';
      switch (element.type) {
        case 'max':
          y = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["maxBy"])(data, function (d) {
            return d[yField];
          })[yField];
          break;
        case 'mean':
          y = Object(_utils_data_transform_sum__WEBPACK_IMPORTED_MODULE_3__[ "a"])(data.map(function (d) {
            return d[yField];
          })) / data.length;
          break;
        default:
          
          y = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["minBy"])(data, function (d) {
            return d[yField];
          })[yField];
          break;
      }
      var line = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        start: ['min', y],
        end: ['max', y],
        style: element.lineStyle,
        text: {
          content: y
        }
      }, element), {
        type: 'line'
      });
      if (!Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'annotations')) {
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'annotations', []);
      }
      polyfillOpt.annotations.push(line);
      Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'point', false);
    }
  });
  
  var interactions = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'interactions', []);
  var slider = interactions.find(function (it) {
    return it.type === 'slider';
  });
  if (slider && Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(polyfillOpt.slider)) {
    polyfillOpt.slider = slider.cfg;
  }
  return polyfillOpt;
};
var polyfillEvents = function polyfillEvents(chart, preOptions, newOptions) {
  
  var eventNames = Object(_components_Chart_events__WEBPACK_IMPORTED_MODULE_4__[ "a"])(Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(preOptions, 'events', []));
  var newEventNames = Object(_components_Chart_events__WEBPACK_IMPORTED_MODULE_4__[ "a"])(Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(newOptions, 'events', []));
  
  eventNames.forEach(function (ev) {
    chart.off(ev[1], preOptions.events[ev[0]]);
  });
  
  newEventNames.forEach(function (ev) {
    chart.on(ev[1], newOptions.events[ev[0]]);
  });
};
var polyfillTitleEvent = function polyfillTitleEvent(options) {
  var events = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, 'events', {});
  var titleEvents = {};
  ['onTitleClick', 'onTitleDblClick', 'onTitleMouseleave', 'onTitleMousemove', 'onTitleMousedown', 'onTitleMouseup', 'onTitleMouseenter'].forEach(function (e) {
    if (events[e]) {
      titleEvents[e.replace('Title', '')] = events[e];
    }
  });
  return titleEvents;
};
var polyfillDescriptionEvent = function polyfillDescriptionEvent(options) {
  var events = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, 'events', {});
  var titleEvents = {};
  ['onDescriptionClick', 'onDescriptionDblClick', 'onDescriptionMouseleave', 'onDescriptionMousemove', 'onDescriptionMousedown', 'onDescriptionMouseup', 'onDescriptionMouseenter'].forEach(function (e) {
    if (events[e]) {
      titleEvents[e.replace('Description', '')] = events[e];
    }
  });
  return titleEvents;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var __DEV__ = "production" !== 'production';
var warning = function warning() {};
if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      
      
      
      throw new Error(message);
    } catch (x) {}
  };
  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}
module.exports = warning;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_string_1 = __webpack_require__(50);
exports.default = function (obj, key, defaultValue) {
  var p = 0;
  var keyArr = is_string_1.default(key) ? key.split('.') : key;
  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }
  return obj === undefined || p < keyArr.length ? defaultValue : obj;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plot = exports.PLOT_CONTAINER_OPTIONS = void 0;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var _util = __webpack_require__(0);
var _eventEmitter = _interopRequireDefault(__webpack_require__(126));
var _sizeSensor = __webpack_require__(505);
var _utils = __webpack_require__(7);
var SOURCE_ATTRIBUTE_NAME = 'data-chart-source-type';
var PLOT_CONTAINER_OPTIONS = ['padding', 'appendPadding', 'renderer', 'pixelRatio', 'syncViewPadding', 'supportCSSTransform', 'limitInPlot'];
exports.PLOT_CONTAINER_OPTIONS = PLOT_CONTAINER_OPTIONS;
var Plot = function (_super) {
  (0, _tslib.__extends)(Plot, _super);
  function Plot(container, options) {
    var _this = _super.call(this) || this;
    _this.container = typeof container === 'string' ? document.getElementById(container) : container;
    _this.options = (0, _utils.deepAssign)({}, _this.getDefaultOptions(), options);
    _this.createG2();
    _this.bindEvents();
    return _this;
  }
    Plot.getDefaultOptions = function () {
    return {
      renderer: 'canvas',
      xAxis: {
        nice: true,
        label: {
          autoRotate: false,
          autoHide: {
            type: 'equidistance',
            cfg: {
              minGap: 6
            }
          }
        }
      },
      yAxis: {
        nice: true,
        label: {
          autoHide: true,
          autoRotate: false
        }
      },
      animation: true
    };
  };
    Plot.prototype.createG2 = function () {
    var _a = this.options,
      width = _a.width,
      height = _a.height,
      defaultInteractions = _a.defaultInteractions;
    this.chart = new _g.Chart((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({
      container: this.container,
      autoFit: false
    }, this.getChartSize(width, height)), {
      localRefresh: false
    }), (0, _utils.pick)(this.options, PLOT_CONTAINER_OPTIONS)), {
      defaultInteractions: defaultInteractions
    }));
    
    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, 'G2Plot');
  };
    Plot.prototype.getChartSize = function (width, height) {
    var chartSize = (0, _utils.getContainerSize)(this.container);
    return {
      width: width || chartSize.width || 400,
      height: height || chartSize.height || 400
    };
  };
    Plot.prototype.bindEvents = function () {
    var _this = this;
    if (this.chart) {
      this.chart.on('*', function (e) {
        if (e === null || e === void 0 ? void 0 : e.type) {
          _this.emit(e.type, e);
        }
      });
    }
  };
    Plot.prototype.getDefaultOptions = function () {
    return Plot.getDefaultOptions();
  };
    Plot.prototype.render = function () {
    
    this.chart.clear();
    
    
    
    
    
    this.chart.options = {
      data: [],
      animate: true
    };
    this.chart.views = []; 
    
    this.execAdaptor();
    
    this.chart.render();
    
    this.bindSizeSensor();
  };
    Plot.prototype.update = function (options) {
    this.updateOption(options);
    this.render();
  };
    Plot.prototype.updateOption = function (options) {
    this.options = (0, _utils.deepAssign)({}, this.options, options);
  };
    Plot.prototype.setState = function (type, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = (0, _utils.getAllElementsRecursively)(this.chart);
    (0, _util.each)(elements, function (ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
    Plot.prototype.getStates = function () {
    var elements = (0, _utils.getAllElementsRecursively)(this.chart);
    var stateObjects = [];
    (0, _util.each)(elements, function (element) {
      var data = element.getData();
      var states = element.getStates();
      (0, _util.each)(states, function (state) {
        stateObjects.push({
          data: data,
          state: state,
          geometry: element.geometry,
          element: element
        });
      });
    });
    return stateObjects;
  };
    Plot.prototype.changeData = function (data) {
    
    this.update({
      data: data
    });
    
    
  };
    Plot.prototype.changeSize = function (width, height) {
    this.chart.changeSize(width, height);
  };
    Plot.prototype.addAnnotations = function (annotations) {
    var incoming = (0, _tslib.__spreadArrays)(annotations);
    var controller = this.chart.getController('annotation');
    var current = controller.getComponents().map(function (co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_1 = function _loop_1(i) {
      var annotation = current[i];
      var findIndex = incoming.findIndex(function (item) {
        return item.id && item.id === annotation.id;
      });
      if (findIndex !== -1) {
        annotation = (0, _utils.deepAssign)({}, annotation, incoming[findIndex]);
        incoming.splice(findIndex, 1);
      }
      controller.annotation(annotation);
    };
    for (var i = 0; i < current.length; i++) {
      _loop_1(i);
    }
    incoming.forEach(function (annotation) {
      return controller.annotation(annotation);
    });
    this.chart.render(true);
  };
    Plot.prototype.removeAnnotations = function (annotations) {
    var controller = this.chart.getController('annotation');
    var current = controller.getComponents().map(function (co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_2 = function _loop_2(i) {
      var annotation = current[i];
      if (!annotations.find(function (item) {
        return item.id && item.id === annotation.id;
      })) {
        controller.annotation(annotation);
      }
    };
    for (var i = 0; i < current.length; i++) {
      _loop_2(i);
    }
    this.chart.render(true);
  };
    Plot.prototype.destroy = function () {
    
    this.unbindSizeSensor();
    
    this.chart.destroy();
    
    this.off();
    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
  };
    Plot.prototype.execAdaptor = function () {
    var adaptor = this.getSchemaAdaptor();
    var _a = this.options,
      padding = _a.padding,
      appendPadding = _a.appendPadding;
    
    this.chart.padding = padding;
    
    this.chart.appendPadding = appendPadding;
    
    adaptor({
      chart: this.chart,
      options: this.options
    });
  };
    Plot.prototype.triggerResize = function () {
    this.chart.forceFit();
  };
    Plot.prototype.bindSizeSensor = function () {
    var _this = this;
    if (this.unbind) {
      return;
    }
    var _a = this.options.autoFit,
      autoFit = _a === void 0 ? true : _a;
    if (autoFit) {
      this.unbind = (0, _sizeSensor.bind)(this.container, function () {
        
        var _a = (0, _utils.getContainerSize)(_this.container),
          width = _a.width,
          height = _a.height;
        
        if (width !== _this.chart.width || height !== _this.chart.height) {
          _this.triggerResize();
        }
      });
    }
  };
    Plot.prototype.unbindSizeSensor = function () {
    if (this.unbind) {
      this.unbind();
      this.unbind = undefined;
    }
  };
  return Plot;
}(_eventEmitter.default);
exports.Plot = Plot;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_object_1 = __webpack_require__(61);
var is_string_1 = __webpack_require__(50);
var is_number_1 = __webpack_require__(1055);
exports.default = function (obj, path, value) {
  var o = obj;
  var keyArr = is_string_1.default(path) ? path.split('.') : path;
  keyArr.forEach(function (key, idx) {
    
    if (idx < keyArr.length - 1) {
      if (!is_object_1.default(o[key])) {
        o[key] = is_number_1.default(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value;
    }
  });
  return obj;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COMPONENT_MAX_VIEW_PERCENTAGE = exports.MIN_CHART_HEIGHT = exports.MIN_CHART_WIDTH = exports.FIELD_ORIGIN = exports.GROUP_ATTRS = exports.ELEMENT_STATE = exports.PLOT_EVENTS = exports.GEOMETRY_LIFE_CIRCLE = exports.VIEW_LIFE_CIRCLE = exports.GROUP_Z_INDEX = exports.COMPONENT_TYPE = exports.DIRECTION = exports.LAYER = void 0;
var LAYER;
(function (LAYER) {
    LAYER["FORE"] = "fore";
    LAYER["MID"] = "mid";
    LAYER["BG"] = "bg";
})(LAYER = exports.LAYER || (exports.LAYER = {}));
var DIRECTION;
(function (DIRECTION) {
  DIRECTION["TOP"] = "top";
  DIRECTION["TOP_LEFT"] = "top-left";
  DIRECTION["TOP_RIGHT"] = "top-right";
  DIRECTION["RIGHT"] = "right";
  DIRECTION["RIGHT_TOP"] = "right-top";
  DIRECTION["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION["LEFT"] = "left";
  DIRECTION["LEFT_TOP"] = "left-top";
  DIRECTION["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION["BOTTOM"] = "bottom";
  DIRECTION["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION["RADIUS"] = "radius";
  DIRECTION["CIRCLE"] = "circle";
  
  DIRECTION["NONE"] = "none";
})(DIRECTION = exports.DIRECTION || (exports.DIRECTION = {}));
var COMPONENT_TYPE;
(function (COMPONENT_TYPE) {
    COMPONENT_TYPE["AXIS"] = "axis";
    COMPONENT_TYPE["GRID"] = "grid";
    COMPONENT_TYPE["LEGEND"] = "legend";
    COMPONENT_TYPE["TOOLTIP"] = "tooltip";
    COMPONENT_TYPE["ANNOTATION"] = "annotation";
    COMPONENT_TYPE["SLIDER"] = "slider";
    COMPONENT_TYPE["SCROLLBAR"] = "scrollbar";
    COMPONENT_TYPE["OTHER"] = "other";
})(COMPONENT_TYPE = exports.COMPONENT_TYPE || (exports.COMPONENT_TYPE = {}));
exports.GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
var VIEW_LIFE_CIRCLE;
(function (VIEW_LIFE_CIRCLE) {
  VIEW_LIFE_CIRCLE["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE = exports.VIEW_LIFE_CIRCLE || (exports.VIEW_LIFE_CIRCLE = {}));
var GEOMETRY_LIFE_CIRCLE;
(function (GEOMETRY_LIFE_CIRCLE) {
  GEOMETRY_LIFE_CIRCLE["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE["AFTER_DRAW_ANIMATE"] = "afteranimate";
})(GEOMETRY_LIFE_CIRCLE = exports.GEOMETRY_LIFE_CIRCLE || (exports.GEOMETRY_LIFE_CIRCLE = {}));
var PLOT_EVENTS;
(function (PLOT_EVENTS) {
  
  PLOT_EVENTS["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS["MOUSE_LEAVE"] = "plot:mouseleave";
  
  PLOT_EVENTS["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS["TOUCH_CANCEL"] = "plot:touchcancel";
  
  PLOT_EVENTS["CLICK"] = "plot:click";
  PLOT_EVENTS["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS["LEAVE"] = "plot:leave";
  PLOT_EVENTS["ENTER"] = "plot:enter";
})(PLOT_EVENTS = exports.PLOT_EVENTS || (exports.PLOT_EVENTS = {}));
var ELEMENT_STATE;
(function (ELEMENT_STATE) {
  ELEMENT_STATE["ACTIVE"] = "active";
  ELEMENT_STATE["INACTIVE"] = "inactive";
  ELEMENT_STATE["SELECTED"] = "selected";
  ELEMENT_STATE["DEFAULT"] = "default";
})(ELEMENT_STATE = exports.ELEMENT_STATE || (exports.ELEMENT_STATE = {}));
exports.GROUP_ATTRS = ['color', 'shape', 'size'];
exports.FIELD_ORIGIN = '_origin';
exports.MIN_CHART_WIDTH = 1;
exports.MIN_CHART_HEIGHT = 1;
exports.COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animation = animation;
exports.annotation = annotation;
exports.interaction = interaction;
exports.legend = legend;
exports.limitInPlot = limitInPlot;
Object.defineProperty(exports, "pattern", {
  enumerable: true,
  get: function get() {
    return _pattern.pattern;
  }
});
exports.scale = scale;
exports.scrollbar = scrollbar;
exports.slider = slider;
exports.state = state;
exports.theme = theme;
exports.tooltip = tooltip;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _constant = __webpack_require__(99);
var _utils = __webpack_require__(7);
var _pattern = __webpack_require__(122);
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    colorField = options.colorField,
    seriesField = options.seriesField;
  if (legend === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend);
  }
  return params;
}
function tooltip(params) {
  var chart = params.chart,
    options = params.options;
  var tooltip = options.tooltip;
  if (tooltip !== undefined) {
    chart.tooltip(tooltip);
  }
  return params;
}
function interaction(params) {
  var chart = params.chart,
    options = params.options;
  var interactions = options.interactions;
  (0, _util.each)(interactions, function (i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function animation(params) {
  var chart = params.chart,
    options = params.options;
  var animation = options.animation;
  
  if (typeof animation === 'boolean') {
    chart.animate(animation);
  } else {
    chart.animate(true);
  }
  
  (0, _util.each)(chart.geometries, function (g) {
    g.animate(animation);
  });
  return params;
}
function theme(params) {
  var chart = params.chart,
    options = params.options;
  var theme = options.theme;
  
  if (theme) {
    chart.theme(theme);
  }
  return params;
}
function state(params) {
  var chart = params.chart,
    options = params.options;
  var state = options.state;
  if (state) {
    (0, _util.each)(chart.geometries, function (geometry) {
      geometry.state(state);
    });
  }
  return params;
}
function slider(params) {
  var chart = params.chart,
    options = params.options;
  var slider = options.slider;
  chart.option('slider', slider);
  return params;
}
function scrollbar(params) {
  var chart = params.chart,
    options = params.options;
  var scrollbar = options.scrollbar;
  chart.option('scrollbar', scrollbar);
  return params;
}
function scale(axes, meta) {
  return function (params) {
    var chart = params.chart,
      options = params.options;
    
    var scales = {};
    (0, _util.each)(axes, function (axis, field) {
      scales[field] = (0, _utils.pick)(axis, _constant.AXIS_META_CONFIG_KEYS);
    });
    
    scales = (0, _utils.deepAssign)({}, meta, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
function annotation(annotationOptions) {
  return function (params) {
    var chart = params.chart,
      options = params.options;
    var annotationController = chart.getController('annotation');
        (0, _util.each)((0, _tslib.__spreadArrays)(options.annotations || [], annotationOptions || []), function (annotationOption) {
      
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
function limitInPlot(params) {
  var chart = params.chart,
    options = params.options;
  var yAxis = options.yAxis,
    limitInPlot = options.limitInPlot;
  var value = limitInPlot;
  
  if ((0, _util.isObject)(yAxis) && (0, _util.isNil)(limitInPlot)) {
    if (Object.values((0, _utils.pick)(yAxis, ['min', 'max', 'minLimit', 'maxLimit'])).some(function (value) {
      return !(0, _util.isNil)(value);
    })) {
      value = true;
    } else {
      value = false;
    }
  }
  chart.limitInPlot = value;
  return params;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_type_1 = __webpack_require__(117);
exports.default = function (value) {
  return Array.isArray ? Array.isArray(value) : is_type_1.default(value, 'Array');
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plot = exports.PLOT_CONTAINER_OPTIONS = void 0;
var tslib_1 = __webpack_require__(1);
var g2_1 = __webpack_require__(14);
var util_1 = __webpack_require__(0);
var event_emitter_1 = tslib_1.__importDefault(__webpack_require__(126));
var size_sensor_1 = __webpack_require__(505);
var utils_1 = __webpack_require__(15);
var SOURCE_ATTRIBUTE_NAME = 'data-chart-source-type';
exports.PLOT_CONTAINER_OPTIONS = ['padding', 'appendPadding', 'renderer', 'pixelRatio', 'syncViewPadding', 'supportCSSTransform', 'limitInPlot'];
var Plot = function (_super) {
  tslib_1.__extends(Plot, _super);
  function Plot(container, options) {
    var _this = _super.call(this) || this;
    _this.container = typeof container === 'string' ? document.getElementById(container) : container;
    _this.options = utils_1.deepAssign({}, _this.getDefaultOptions(), options);
    _this.createG2();
    _this.bindEvents();
    return _this;
  }
    Plot.getDefaultOptions = function () {
    return {
      renderer: 'canvas',
      xAxis: {
        nice: true,
        label: {
          autoRotate: false,
          autoHide: {
            type: 'equidistance',
            cfg: {
              minGap: 6
            }
          }
        }
      },
      yAxis: {
        nice: true,
        label: {
          autoHide: true,
          autoRotate: false
        }
      },
      animation: true
    };
  };
    Plot.prototype.createG2 = function () {
    var _a = this.options,
      width = _a.width,
      height = _a.height,
      defaultInteractions = _a.defaultInteractions;
    this.chart = new g2_1.Chart(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({
      container: this.container,
      autoFit: false
    }, this.getChartSize(width, height)), {
      localRefresh: false
    }), utils_1.pick(this.options, exports.PLOT_CONTAINER_OPTIONS)), {
      defaultInteractions: defaultInteractions
    }));
    
    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, 'G2Plot');
  };
    Plot.prototype.getChartSize = function (width, height) {
    var chartSize = utils_1.getContainerSize(this.container);
    return {
      width: width || chartSize.width || 400,
      height: height || chartSize.height || 400
    };
  };
    Plot.prototype.bindEvents = function () {
    var _this = this;
    if (this.chart) {
      this.chart.on('*', function (e) {
        if (e === null || e === void 0 ? void 0 : e.type) {
          _this.emit(e.type, e);
        }
      });
    }
  };
    Plot.prototype.getDefaultOptions = function () {
    return Plot.getDefaultOptions();
  };
    Plot.prototype.render = function () {
    
    this.chart.clear();
    
    
    
    
    
    this.chart.options = {
      data: [],
      animate: true
    };
    this.chart.views = []; 
    
    this.execAdaptor();
    
    this.chart.render();
    
    this.bindSizeSensor();
  };
    Plot.prototype.update = function (options) {
    this.updateOption(options);
    this.render();
  };
    Plot.prototype.updateOption = function (options) {
    this.options = utils_1.deepAssign({}, this.options, options);
  };
    Plot.prototype.setState = function (type, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = utils_1.getAllElementsRecursively(this.chart);
    util_1.each(elements, function (ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
    Plot.prototype.getStates = function () {
    var elements = utils_1.getAllElementsRecursively(this.chart);
    var stateObjects = [];
    util_1.each(elements, function (element) {
      var data = element.getData();
      var states = element.getStates();
      util_1.each(states, function (state) {
        stateObjects.push({
          data: data,
          state: state,
          geometry: element.geometry,
          element: element
        });
      });
    });
    return stateObjects;
  };
    Plot.prototype.changeData = function (data) {
    
    this.update({
      data: data
    });
    
    
  };
    Plot.prototype.changeSize = function (width, height) {
    this.chart.changeSize(width, height);
  };
    Plot.prototype.addAnnotations = function (annotations) {
    var incoming = tslib_1.__spreadArrays(annotations);
    var controller = this.chart.getController('annotation');
    var current = controller.getComponents().map(function (co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_1 = function _loop_1(i) {
      var annotation = current[i];
      var findIndex = incoming.findIndex(function (item) {
        return item.id && item.id === annotation.id;
      });
      if (findIndex !== -1) {
        annotation = utils_1.deepAssign({}, annotation, incoming[findIndex]);
        incoming.splice(findIndex, 1);
      }
      controller.annotation(annotation);
    };
    for (var i = 0; i < current.length; i++) {
      _loop_1(i);
    }
    incoming.forEach(function (annotation) {
      return controller.annotation(annotation);
    });
    this.chart.render(true);
  };
    Plot.prototype.removeAnnotations = function (annotations) {
    var controller = this.chart.getController('annotation');
    var current = controller.getComponents().map(function (co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_2 = function _loop_2(i) {
      var annotation = current[i];
      if (!annotations.find(function (item) {
        return item.id && item.id === annotation.id;
      })) {
        controller.annotation(annotation);
      }
    };
    for (var i = 0; i < current.length; i++) {
      _loop_2(i);
    }
    this.chart.render(true);
  };
    Plot.prototype.destroy = function () {
    
    this.unbindSizeSensor();
    
    this.chart.destroy();
    
    this.off();
    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
  };
    Plot.prototype.execAdaptor = function () {
    var adaptor = this.getSchemaAdaptor();
    var _a = this.options,
      padding = _a.padding,
      appendPadding = _a.appendPadding;
    
    this.chart.padding = padding;
    
    this.chart.appendPadding = appendPadding;
    
    adaptor({
      chart: this.chart,
      options: this.options
    });
  };
    Plot.prototype.triggerResize = function () {
    this.chart.forceFit();
  };
    Plot.prototype.bindSizeSensor = function () {
    var _this = this;
    if (this.unbind) {
      return;
    }
    var _a = this.options.autoFit,
      autoFit = _a === void 0 ? true : _a;
    if (autoFit) {
      this.unbind = size_sensor_1.bind(this.container, function () {
        
        var _a = utils_1.getContainerSize(_this.container),
          width = _a.width,
          height = _a.height;
        
        if (width !== _this.chart.width || height !== _this.chart.height) {
          _this.triggerResize();
        }
      });
    }
  };
    Plot.prototype.unbindSizeSensor = function () {
    if (this.unbind) {
      this.unbind();
      this.unbind = undefined;
    }
  };
  return Plot;
}(event_emitter_1.default);
exports.Plot = Plot;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Util = exports.Scale = exports.Coordinate = exports.DIRECTION = exports.LAYER = exports.getAnimation = exports.registerAnimation = exports.getEngine = exports.registerEngine = exports.registerTheme = exports.getTheme = exports.registerFacet = exports.getFacet = exports.getActionClass = exports.registerAction = exports.registerInteraction = exports.getInteraction = exports.getGeometryLabelLayout = exports.getGeometryLabel = exports.registerGeometryLabelLayout = exports.registerGeometryLabel = exports.getShapeFactory = exports.registerShapeFactory = exports.registerShape = exports.registerGeometry = exports.registerComponentController = exports.InteractionAction = exports.Facet = exports.Action = exports.Interaction = exports.GeometryLabel = exports.Element = exports.Geometry = exports.TooltipController = exports.ComponentController = exports.Event = exports.View = exports.Chart = exports.VERSION = void 0;
var tslib_1 = __webpack_require__(1);
exports.VERSION = '4.1.32';

var chart_1 = __webpack_require__(98); 
Object.defineProperty(exports, "Chart", {
  enumerable: true,
  get: function get() {
    return chart_1.Chart;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function get() {
    return chart_1.View;
  }
});
Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return chart_1.Event;
  }
});
var base_1 = __webpack_require__(104); 
Object.defineProperty(exports, "ComponentController", {
  enumerable: true,
  get: function get() {
    return base_1.Controller;
  }
});
var tooltip_1 = __webpack_require__(204); 
Object.defineProperty(exports, "TooltipController", {
  enumerable: true,
  get: function get() {
    return (0, tslib_1.__importDefault)(tooltip_1).default;
  }
});
var base_2 = __webpack_require__(91); 
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function get() {
    return (0, tslib_1.__importDefault)(base_2).default;
  }
});
var element_1 = __webpack_require__(269); 
Object.defineProperty(exports, "Element", {
  enumerable: true,
  get: function get() {
    return (0, tslib_1.__importDefault)(element_1).default;
  }
});
var base_3 = __webpack_require__(100); 
Object.defineProperty(exports, "GeometryLabel", {
  enumerable: true,
  get: function get() {
    return (0, tslib_1.__importDefault)(base_3).default;
  }
});
var interaction_1 = __webpack_require__(266); 
Object.defineProperty(exports, "Interaction", {
  enumerable: true,
  get: function get() {
    return interaction_1.Interaction;
  }
});
Object.defineProperty(exports, "Action", {
  enumerable: true,
  get: function get() {
    return interaction_1.Action;
  }
});
var facet_1 = __webpack_require__(264); 
Object.defineProperty(exports, "Facet", {
  enumerable: true,
  get: function get() {
    return facet_1.Facet;
  }
});
var base_4 = __webpack_require__(44); 
Object.defineProperty(exports, "InteractionAction", {
  enumerable: true,
  get: function get() {
    return (0, tslib_1.__importDefault)(base_4).default;
  }
});

var chart_2 = __webpack_require__(98);
Object.defineProperty(exports, "registerComponentController", {
  enumerable: true,
  get: function get() {
    return chart_2.registerComponentController;
  }
});

var chart_3 = __webpack_require__(98);
Object.defineProperty(exports, "registerGeometry", {
  enumerable: true,
  get: function get() {
    return chart_3.registerGeometry;
  }
});

var base_5 = __webpack_require__(27);
Object.defineProperty(exports, "registerShape", {
  enumerable: true,
  get: function get() {
    return base_5.registerShape;
  }
});
Object.defineProperty(exports, "registerShapeFactory", {
  enumerable: true,
  get: function get() {
    return base_5.registerShapeFactory;
  }
});
Object.defineProperty(exports, "getShapeFactory", {
  enumerable: true,
  get: function get() {
    return base_5.getShapeFactory;
  }
});

var label_1 = __webpack_require__(271);
Object.defineProperty(exports, "registerGeometryLabel", {
  enumerable: true,
  get: function get() {
    return label_1.registerGeometryLabel;
  }
});
Object.defineProperty(exports, "registerGeometryLabelLayout", {
  enumerable: true,
  get: function get() {
    return label_1.registerGeometryLabelLayout;
  }
});
Object.defineProperty(exports, "getGeometryLabel", {
  enumerable: true,
  get: function get() {
    return label_1.getGeometryLabel;
  }
});
Object.defineProperty(exports, "getGeometryLabelLayout", {
  enumerable: true,
  get: function get() {
    return label_1.getGeometryLabelLayout;
  }
});

var interaction_2 = __webpack_require__(266);
Object.defineProperty(exports, "getInteraction", {
  enumerable: true,
  get: function get() {
    return interaction_2.getInteraction;
  }
});
Object.defineProperty(exports, "registerInteraction", {
  enumerable: true,
  get: function get() {
    return interaction_2.registerInteraction;
  }
});
Object.defineProperty(exports, "registerAction", {
  enumerable: true,
  get: function get() {
    return interaction_2.registerAction;
  }
});
Object.defineProperty(exports, "getActionClass", {
  enumerable: true,
  get: function get() {
    return interaction_2.getActionClass;
  }
});

var facet_2 = __webpack_require__(264);
Object.defineProperty(exports, "getFacet", {
  enumerable: true,
  get: function get() {
    return facet_2.getFacet;
  }
});
Object.defineProperty(exports, "registerFacet", {
  enumerable: true,
  get: function get() {
    return facet_2.registerFacet;
  }
});

var theme_1 = __webpack_require__(92);
Object.defineProperty(exports, "getTheme", {
  enumerable: true,
  get: function get() {
    return theme_1.getTheme;
  }
});
Object.defineProperty(exports, "registerTheme", {
  enumerable: true,
  get: function get() {
    return theme_1.registerTheme;
  }
});

var engine_1 = __webpack_require__(443);
Object.defineProperty(exports, "registerEngine", {
  enumerable: true,
  get: function get() {
    return engine_1.registerEngine;
  }
});
Object.defineProperty(exports, "getEngine", {
  enumerable: true,
  get: function get() {
    return engine_1.getEngine;
  }
});

var animation_1 = __webpack_require__(436);
Object.defineProperty(exports, "registerAnimation", {
  enumerable: true,
  get: function get() {
    return animation_1.registerAnimation;
  }
});
Object.defineProperty(exports, "getAnimation", {
  enumerable: true,
  get: function get() {
    return animation_1.getAnimation;
  }
});
var constant_1 = __webpack_require__(21);
Object.defineProperty(exports, "LAYER", {
  enumerable: true,
  get: function get() {
    return constant_1.LAYER;
  }
});
Object.defineProperty(exports, "DIRECTION", {
  enumerable: true,
  get: function get() {
    return constant_1.DIRECTION;
  }
});

var Types = (0, tslib_1.__importStar)(__webpack_require__(272));
var dependents_1 = __webpack_require__(69);
Object.defineProperty(exports, "Coordinate", {
  enumerable: true,
  get: function get() {
    return dependents_1.Coordinate;
  }
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return dependents_1.Scale;
  }
});

var attr_1 = __webpack_require__(451);
var legend_1 = __webpack_require__(452);
var graphics_1 = __webpack_require__(46);
var transform_1 = __webpack_require__(114);
var tooltip_2 = __webpack_require__(186);
var util_1 = __webpack_require__(31);
exports.Util = {
  getLegendItems: legend_1.getLegendItems,
  translate: transform_1.translate,
  rotate: transform_1.rotate,
  zoom: transform_1.zoom,
  transform: transform_1.transform,
  getAngle: graphics_1.getAngle,
  getSectorPath: graphics_1.getSectorPath,
  polarToCartesian: graphics_1.polarToCartesian,
  getDelegationObject: util_1.getDelegationObject,
  getTooltipItems: tooltip_2.getTooltipItems,
  getMappingValue: attr_1.getMappingValue
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  PathUtil: true,
  Event: true,
  Base: true,
  AbstractCanvas: true,
  AbstractGroup: true,
  AbstractShape: true,
  getBBoxMethod: true,
  registerBBox: true,
  getTextHeight: true,
  assembleFont: true,
  isAllowCapture: true,
  multiplyVec2: true,
  invert: true,
  getOffScreenContext: true,
  registerEasing: true
};
Object.defineProperty(exports, "AbstractCanvas", {
  enumerable: true,
  get: function get() {
    return _canvas.default;
  }
});
Object.defineProperty(exports, "AbstractGroup", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
Object.defineProperty(exports, "AbstractShape", {
  enumerable: true,
  get: function get() {
    return _shape.default;
  }
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return _graphEvent.default;
  }
});
exports.PathUtil = void 0;
Object.defineProperty(exports, "assembleFont", {
  enumerable: true,
  get: function get() {
    return _text.assembleFont;
  }
});
Object.defineProperty(exports, "getBBoxMethod", {
  enumerable: true,
  get: function get() {
    return _bbox.getBBoxMethod;
  }
});
Object.defineProperty(exports, "getOffScreenContext", {
  enumerable: true,
  get: function get() {
    return _offscreen.getOffScreenContext;
  }
});
Object.defineProperty(exports, "getTextHeight", {
  enumerable: true,
  get: function get() {
    return _text.getTextHeight;
  }
});
Object.defineProperty(exports, "invert", {
  enumerable: true,
  get: function get() {
    return _matrix.invert;
  }
});
Object.defineProperty(exports, "isAllowCapture", {
  enumerable: true,
  get: function get() {
    return _util.isAllowCapture;
  }
});
Object.defineProperty(exports, "multiplyVec2", {
  enumerable: true,
  get: function get() {
    return _matrix.multiplyVec2;
  }
});
Object.defineProperty(exports, "registerBBox", {
  enumerable: true,
  get: function get() {
    return _bbox.registerBBox;
  }
});
Object.defineProperty(exports, "registerEasing", {
  enumerable: true,
  get: function get() {
    return _register.registerEasing;
  }
});
exports.version = void 0;
var PathUtil = _interopRequireWildcard(__webpack_require__(389));
exports.PathUtil = PathUtil;
var _types = __webpack_require__(744);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});
var _interfaces = __webpack_require__(745);
Object.keys(_interfaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interfaces[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interfaces[key];
    }
  });
});
var _graphEvent = _interopRequireDefault(__webpack_require__(390));
var _base = _interopRequireDefault(__webpack_require__(391));
var _canvas = _interopRequireDefault(__webpack_require__(746));
var _group = _interopRequireDefault(__webpack_require__(785));
var _shape = _interopRequireDefault(__webpack_require__(786));
var _bbox = __webpack_require__(787);
var _text = __webpack_require__(412);
var _util = __webpack_require__(102);
var _matrix = __webpack_require__(243);
var _offscreen = __webpack_require__(413);
var _register = __webpack_require__(407);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var version = '0.5.11';
exports.version = version;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShapeFactory = exports.registerShape = exports.registerShapeFactory = void 0;
var tslib_1 = __webpack_require__(1);
var path_util_1 = __webpack_require__(88);
var util_1 = __webpack_require__(0);
var path_1 = __webpack_require__(112);
var ShapeFactoryBase = {
    coordinate: null,
    defaultShapeType: null,
    theme: null,
    getShapePoints: function getShapePoints(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);
    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }
    return this.getDefaultPoints(shapePoint);
  },
    getShape: function getShape(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },
    getDefaultPoints: function getDefaultPoints() {
    return [];
  },
    getDefaultStyle: function getDefaultStyle(geometryTheme) {
    return (0, util_1.get)(geometryTheme, [this.defaultShapeType, 'default', 'style'], {});
  },
    getMarker: function getMarker(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);
    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }
    var theme = this.theme;
    var shapeStyle = (0, util_1.get)(theme, [shapeType, 'default'], {});
    var markerStyle = shape.getMarker(markerCfg);
    return (0, util_1.deepMix)({}, shapeStyle, markerStyle);
  },
    drawShape: function drawShape(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
var ShapeBase = {
    coordinate: null,
    parsePath: function parsePath(path) {
    var coordinate = this.coordinate;
    var parsedPath = (0, path_util_1.parsePathString)(path);
    if (coordinate.isPolar) {
      parsedPath = (0, path_1.convertPolarPath)(coordinate, parsedPath);
    } else {
      parsedPath = (0, path_1.convertNormalPath)(coordinate, parsedPath);
    }
    return parsedPath;
  },
    parsePoint: function parsePoint(point) {
    var coordinate = this.coordinate;
    return coordinate.convert(point);
  },
    parsePoints: function parsePoints(points) {
    var coordinate = this.coordinate;
    return points.map(function (point) {
      return coordinate.convert(point);
    });
  },
    draw: function draw(cfg, container) {}
};
var ShapeFactoryMap = {};
function registerShapeFactory(factoryName, cfg) {
  var className = (0, util_1.upperFirst)(factoryName);
  var geomObj = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, ShapeFactoryBase), cfg), {
    geometryType: factoryName
  });
  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}
exports.registerShapeFactory = registerShapeFactory;
function registerShape(factoryName, shapeType, cfg) {
  var className = (0, util_1.upperFirst)(factoryName);
  var factory = ShapeFactoryMap[className];
  var shapeObj = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, ShapeBase), cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}
exports.registerShape = registerShape;
function getShapeFactory(factoryName) {
  var className = (0, util_1.upperFirst)(factoryName);
  return ShapeFactoryMap[className];
}
exports.getShapeFactory = getShapeFactory;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_type_1 = __webpack_require__(117);
exports.default = function (value) {
  return is_type_1.default(value, 'Function');
};

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "b", function() { return withGroupContext; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);



var GroupContext = react__WEBPACK_IMPORTED_MODULE_1___default.a.createContext(null);
GroupContext.displayName = 'GroupContext';
function withGroupContext(Component) {
  var Com = react__WEBPACK_IMPORTED_MODULE_1___default.a.forwardRef(function (props, ref) {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(GroupContext.Consumer, null, function (ctx) {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        ref: ref,
        group: ctx
      }, props));
    });
  });
  Com.displayName = Component.name;
  return Com;
}
;
 __webpack_exports__["a"] = (GroupContext);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function get() {
    return _area.area;
  }
});
Object.defineProperty(exports, "edge", {
  enumerable: true,
  get: function get() {
    return _edge.edge;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function get() {
    return _interval.interval;
  }
});
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function get() {
    return _line.line;
  }
});
Object.defineProperty(exports, "point", {
  enumerable: true,
  get: function get() {
    return _point.point;
  }
});
Object.defineProperty(exports, "polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.polygon;
  }
});
Object.defineProperty(exports, "schema", {
  enumerable: true,
  get: function get() {
    return _schema.schema;
  }
});
Object.defineProperty(exports, "violin", {
  enumerable: true,
  get: function get() {
    return _violin.violin;
  }
});
var _area = __webpack_require__(1186);
var _line = __webpack_require__(1187);
var _point = __webpack_require__(546);
var _interval = __webpack_require__(1188);
var _polygon = __webpack_require__(547);
var _edge = __webpack_require__(1189);
var _schema = __webpack_require__(1190);
var _violin = __webpack_require__(1191);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScaleByField = exports.isInRecords = exports.getSiblingPoint = exports.getSilbings = exports.isInBox = exports.getSpline = exports.distance = exports.getComponents = exports.getElementsByPath = exports.getIntersectElements = exports.intersectRect = exports.getElementValue = exports.getElementsByState = exports.getElementsByField = exports.getElements = exports.getSiblingMaskElements = exports.getMaskedElements = exports.isMask = exports.isSlider = exports.isList = exports.isElementChange = exports.getDelegationObject = exports.getCurrentElement = void 0;
var util_1 = __webpack_require__(0);
var path_1 = __webpack_require__(112);
var bbox_1 = __webpack_require__(80);
var path_util_1 = __webpack_require__(88);
function getMaskBBox(context, tolerance) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  
  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {
    return null;
  }
  return maskBBox;
}
function getMaskPath(context, tolerance) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  
  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {
    return null;
  }
  return maskShape.attr('path');
}
function getCurrentElement(context) {
  var event = context.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get('element');
  }
  return element;
}
exports.getCurrentElement = getCurrentElement;
function getDelegationObject(context) {
  var event = context.event;
  var target = event.target;
  var delegateObject;
  if (target) {
    delegateObject = target.get('delegateObject');
  }
  return delegateObject;
}
exports.getDelegationObject = getDelegationObject;
function isElementChange(context) {
  var event = context.event.gEvent;
  
  if (event && event.fromShape && event.toShape && event.fromShape.get('element') === event.toShape.get('element')) {
    return false;
  }
  return true;
}
exports.isElementChange = isElementChange;
function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}
exports.isList = isList;
function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
exports.isSlider = isSlider;
function isMask(context) {
  var event = context.event;
  var target = event.target;
  return target && target.get('name') === 'mask';
}
exports.isMask = isMask;
function getMaskedElements(context, tolerance) {
  var target = context.event.target;
  if (target.get('type') === 'path') {
    var maskPath = getMaskPath(context, tolerance);
    if (!maskPath) {
      return;
    }
    return getElementsByPath(context.view, maskPath);
  }
  var maskBBox = getMaskBBox(context, tolerance);
  
  if (!maskBBox) {
    return null;
  }
  return getIntersectElements(context.view, maskBBox);
}
exports.getMaskedElements = getMaskedElements;
function getSiblingMaskElements(context, sibling, tolerance) {
  var maskBBox = getMaskBBox(context, tolerance);
  
  if (!maskBBox) {
    return null;
  }
  var view = context.view;
  var start = getSiblingPoint(view, sibling, {
    x: maskBBox.x,
    y: maskBBox.y
  });
  var end = getSiblingPoint(view, sibling, {
    x: maskBBox.maxX,
    y: maskBBox.maxY
  });
  var box = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box);
}
exports.getSiblingMaskElements = getSiblingMaskElements;
function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  (0, util_1.each)(geometries, function (geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });
  if (view.views && view.views.length) {
    (0, util_1.each)(view.views, function (subView) {
      rst = rst.concat(getElements(subView));
    });
  }
  return rst;
}
exports.getElements = getElements;
function getElementsByField(view, field, value) {
  var elements = getElements(view);
  return elements.filter(function (el) {
    return getElementValue(el, field) === value;
  });
}
exports.getElementsByField = getElementsByField;
function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  (0, util_1.each)(geometries, function (geom) {
    var elements = geom.getElementsBy(function (el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}
exports.getElementsByState = getElementsByState;
function getElementValue(element, field) {
  var model = element.getModel();
  var record = model.data;
  var value;
  if ((0, util_1.isArray)(record)) {
    value = record[0][field];
  } else {
    value = record[field];
  }
  return value;
}
exports.getElementValue = getElementValue;
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
exports.intersectRect = intersectRect;
function getIntersectElements(view, box) {
  var elements = getElements(view);
  var rst = [];
  (0, util_1.each)(elements, function (el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();
    if (intersectRect(box, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}
exports.getIntersectElements = getIntersectElements;
function pathToPoints(path) {
  var points = [];
  (0, util_1.each)(path, function (seg) {
    var command = seg[0];
    if (command !== 'A') {
      for (var i = 1; i < seg.length; i = i + 2) {
        points.push([seg[i], seg[i + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
}
function getElementsByPath(view, path) {
  var elements = getElements(view);
  var points = pathToPoints(path);
  var rst = elements.filter(function (el) {
    var shape = el.shape;
    var shapePoints;
    if (shape.get('type') === 'path') {
      shapePoints = pathToPoints(shape.attr('path'));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = (0, bbox_1.toPoints)(shapeBBox);
    }
    return (0, path_util_1.isPolygonsIntersect)(points, shapePoints);
  });
  return rst;
}
exports.getElementsByPath = getElementsByPath;
function getComponents(view) {
  return view.getComponents().map(function (co) {
    return co.component;
  });
}
exports.getComponents = getComponents;
function distance(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
exports.distance = distance;
function getSpline(points, z) {
  if (points.length <= 2) {
    return (0, path_1.getLinePath)(points, false);
  }
  var first = points[0];
  var arr = [];
  (0, util_1.each)(points, function (point) {
    arr.push(point.x);
    arr.push(point.y);
  });
  var path = (0, path_1.catmullRom2bezier)(arr, z, null);
  path.unshift(['M', first.x, first.y]);
  return path;
}
exports.getSpline = getSpline;
function isInBox(box, point) {
  return box.x <= point.x && box.maxX >= point.x && box.y <= point.y && box.maxY > point.y;
}
exports.isInBox = isInBox;
function getSilbings(view) {
  var parent = view.parent;
  var siblings = null;
  if (parent) {
    siblings = parent.views.filter(function (sub) {
      return sub !== view;
    });
  }
  return siblings;
}
exports.getSilbings = getSilbings;
function point2Normalize(view, point) {
  var coord = view.getCoordinate();
  return coord.invert(point);
}
function getSiblingPoint(view, sibling, point) {
  var normalPoint = point2Normalize(view, point);
  return sibling.getCoordinate().convert(normalPoint);
}
exports.getSiblingPoint = getSiblingPoint;
function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  (0, util_1.each)(records, function (r) {
    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}
exports.isInRecords = isInRecords;

function getScaleByField(view, field) {
  var scale = view.getScaleByField(field);
  if (!scale && view.views) {
    (0, util_1.each)(view.views, function (subView) {
      scale = getScaleByField(subView, field);
      if (scale) {
        return false; 
      }
    });
  }

  return scale;
}
exports.getScaleByField = getScaleByField;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ext = void 0;
Object.defineProperty(exports, "mat3", {
  enumerable: true,
  get: function get() {
    return _glMatrix.mat3;
  }
});
Object.defineProperty(exports, "vec2", {
  enumerable: true,
  get: function get() {
    return _glMatrix.vec2;
  }
});
Object.defineProperty(exports, "vec3", {
  enumerable: true,
  get: function get() {
    return _glMatrix.vec3;
  }
});
var _glMatrix = __webpack_require__(170);
var ext = _interopRequireWildcard(__webpack_require__(751));
exports.ext = ext;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBackgroundRectStyle = exports.getStyle = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
function getStyle(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = '';
  }
  var _a = cfg.style,
    style = _a === void 0 ? {} : _a,
    defaultStyle = cfg.defaultStyle,
    color = cfg.color,
    size = cfg.size;
  var attrs = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, defaultStyle), style);
  if (color) {
    if (isStroke) {
      if (!style.stroke) {
        // 如果用户在 style() 中配置了 stroke，则以用户配置的为准
        attrs.stroke = color;
      }
    }
    if (isFill) {
      if (!style.fill) {
        // 如果用户在 style() 中配置了 fill
        attrs.fill = color;
      }
    }
  }
  if (sizeName && (0, util_1.isNil)(style[sizeName]) && !(0, util_1.isNil)(size)) {
    // 如果用户在 style() 中配置了 lineWidth 或者 r 属性
    attrs[sizeName] = size;
  }
  return attrs;
}
exports.getStyle = getStyle;
/**
 * 获取 矩形背景 的样式
 * @param cfg
 */
function getBackgroundRectStyle(cfg) {
  return (0, util_1.deepMix)({}, {
    // 默认背景色，copy from active-region
    fill: '#CCD6EC',
    fillOpacity: 0.3
  }, (0, util_1.get)(cfg, ['background', 'style']));
}
exports.getBackgroundRectStyle = getBackgroundRectStyle;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInPlot = exports.annotation = exports.scale = exports.scrollbar = exports.slider = exports.state = exports.theme = exports.animation = exports.interaction = exports.tooltip = exports.legend = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(509);
var utils_1 = __webpack_require__(15);
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    colorField = options.colorField,
    seriesField = options.seriesField;
  if (legend === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend);
  }
  return params;
}
exports.legend = legend;
function tooltip(params) {
  var chart = params.chart,
    options = params.options;
  var tooltip = options.tooltip;
  if (tooltip !== undefined) {
    chart.tooltip(tooltip);
  }
  return params;
}
exports.tooltip = tooltip;
function interaction(params) {
  var chart = params.chart,
    options = params.options;
  var interactions = options.interactions;
  util_1.each(interactions, function (i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
exports.interaction = interaction;
function animation(params) {
  var chart = params.chart,
    options = params.options;
  var animation = options.animation;
  
  if (typeof animation === 'boolean') {
    chart.animate(animation);
  } else {
    chart.animate(true);
  }
  
  util_1.each(chart.geometries, function (g) {
    g.animate(animation);
  });
  return params;
}
exports.animation = animation;
function theme(params) {
  var chart = params.chart,
    options = params.options;
  var theme = options.theme;
  
  if (theme) {
    chart.theme(theme);
  }
  return params;
}
exports.theme = theme;
function state(params) {
  var chart = params.chart,
    options = params.options;
  var state = options.state;
  if (state) {
    util_1.each(chart.geometries, function (geometry) {
      geometry.state(state);
    });
  }
  return params;
}
exports.state = state;
function slider(params) {
  var chart = params.chart,
    options = params.options;
  var slider = options.slider;
  chart.option('slider', slider);
  return params;
}
exports.slider = slider;
function scrollbar(params) {
  var chart = params.chart,
    options = params.options;
  var scrollbar = options.scrollbar;
  chart.option('scrollbar', scrollbar);
  return params;
}
exports.scrollbar = scrollbar;
function scale(axes, meta) {
  return function (params) {
    var chart = params.chart,
      options = params.options;
    
    var scales = {};
    util_1.each(axes, function (axis, field) {
      scales[field] = utils_1.pick(axis, constant_1.AXIS_META_CONFIG_KEYS);
    });
    
    scales = utils_1.deepAssign({}, meta, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
exports.scale = scale;
function annotation(annotationOptions) {
  return function (params) {
    var chart = params.chart,
      options = params.options;
    var annotationController = chart.getController('annotation');
        util_1.each(tslib_1.__spreadArrays(options.annotations || [], annotationOptions || []), function (annotationOption) {
      
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
exports.annotation = annotation;
function limitInPlot(params) {
  var chart = params.chart,
    options = params.options;
  var yAxis = options.yAxis,
    limitInPlot = options.limitInPlot;
  var value = limitInPlot;
  
  if (util_1.isObject(yAxis) && util_1.isNil(limitInPlot)) {
    if (Object.values(utils_1.pick(yAxis, ['min', 'max', 'minLimit', 'maxLimit'])).some(function (value) {
      return !util_1.isNil(value);
    })) {
      value = true;
    } else {
      value = false;
    }
  }
  chart.limitInPlot = value;
  return params;
}
exports.limitInPlot = limitInPlot;
var pattern_1 = __webpack_require__(153);
Object.defineProperty(exports, "pattern", {
  enumerable: true,
  get: function get() {
    return pattern_1.pattern;
  }
});

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var _object_assign_4_1_4_object_assign = __webpack_require__(4);
var _object_assign_4_1_4_object_assign_default = __webpack_require__.n(_object_assign_4_1_4_object_assign);


var classCallCheck = __webpack_require__(9);
var classCallCheck_default = __webpack_require__.n(classCallCheck);


var createClass = __webpack_require__(10);
var createClass_default = __webpack_require__.n(createClass);


var inherits = __webpack_require__(12);
var inherits_default = __webpack_require__.n(inherits);


var possibleConstructorReturn = __webpack_require__(13);
var possibleConstructorReturn_default = __webpack_require__.n(possibleConstructorReturn);


var getPrototypeOf = __webpack_require__(5);
var getPrototypeOf_default = __webpack_require__.n(getPrototypeOf);


var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = __webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);


var annotation_html = __webpack_require__(618);
var html_default = __webpack_require__.n(annotation_html);


var util = __webpack_require__(202);


var external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_ = __webpack_require__(221);
var external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_default = __webpack_require__.n(external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_);


var esm = __webpack_require__(0);


var dom = __webpack_require__(160);









html_default.a.prototype.render = function () {
  if (this.get('isReactElement')) {
    var container = this.getContainer();
    var content = this.get('content');
    var refreshDeps = this.get('refreshDeps');
    var rst = external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.isValidElement(content) ? content : content(container);
    if (this.preRefreshDeps === undefined || !Object(esm["isEqual"])(this.preRefreshDeps, refreshDeps)) {
      external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_default.a.render(rst, container);
      this.preRefreshDeps = refreshDeps;
    }
  } else {
    var _container = this.getContainer();
    var html = this.get('html');
    Object(util["clearDom"])(_container);
    var _rst = Object(esm["isFunction"])(html) ? html(_container) : html;
    if (Object(esm["isElement"])(_rst)) {
      _container.appendChild(_rst);
    } else if (Object(esm["isString"])(_rst)) {
      _container.appendChild(Object(dom["createDom"])(_rst));
    }
  }
  this.resetPosition();
};

var annotation = __webpack_require__(319);
var annotation_default = __webpack_require__.n(annotation);


var view = __webpack_require__(47);


var core = __webpack_require__(8);








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






Object(core["registerComponentController"])('annotation', annotation_default.a);

var base_Annotation = function (_React$Component) {
  inherits_default()(Annotation, _React$Component);
  var _super = _createSuper(Annotation);
  function Annotation() {
    var _this;
    classCallCheck_default()(this, Annotation);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'line'; 
    return _this;
  }
  createClass_default()(Annotation, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var chartIns = this.getChartIns();
      this.id = esm["uniqueId"]('annotation');
      this.annotation = chartIns.annotation();
      
      if (this.annotationType === 'ReactElement') {
        this.annotation.annotation(_object_assign_4_1_4_object_assign_default()({
          type: 'html',
          isReactElement: true
        }, this.props));
      } else {
        this.annotation.annotation(_object_assign_4_1_4_object_assign_default()({
          type: this.annotationType
        }, this.props));
      }
      this.annotation.option[this.annotation.option.length - 1].__id = this.id;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;
      var index = null;
      this.annotation.option.forEach(function (item, i) {
        if (item.__id === _this2.id) {
          index = i;
        }
      });
      if (this.annotationType === 'ReactElement') {
        this.annotation.option[index] = _object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()({
          type: 'html',
          isReactElement: true
        }, this.props), {
          __id: this.id
        });
      } else {
        this.annotation.option[index] = _object_assign_4_1_4_object_assign_default()(_object_assign_4_1_4_object_assign_default()({
          type: this.annotationType
        }, this.props), {
          __id: this.id
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this3 = this;
      var index = null;
      if (!this.annotation) {
        return;
      }
      this.annotation.option.forEach(function (item, i) {
        if (item.__id === _this3.id) {
          index = i;
        }
      });
      if (index !== null) {
        this.annotation.option.splice(index, 1);
      }
      this.annotation = null;
    }
  }, {
    key: "getChartIns",
    value: function getChartIns() {
      return this.context;
    }
  }, {
    key: "render",
    value: function render() {
      return external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null);
    }
  }]);
  return Annotation;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);
base_Annotation.contextType = view["a" ];
 var base = __webpack_exports__["a"] = (base_Annotation);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isType = _interopRequireDefault(__webpack_require__(68));
var _default = function _default(value) {
  return Array.isArray ? Array.isArray(value) : (0, _isType.default)(value, 'Array');
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var isNil = function isNil(value) {
    return value === null || value === undefined;
};
exports.default = isNil;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Arc", {
  enumerable: true,
  get: function get() {
    return _arc.default;
  }
});
Object.defineProperty(exports, "Cubic", {
  enumerable: true,
  get: function get() {
    return _cubic.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return _polyline.default;
  }
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function get() {
    return _quadratic.default;
  }
});
exports.Util = void 0;
var _quadratic = _interopRequireDefault(__webpack_require__(792));
var _cubic = _interopRequireDefault(__webpack_require__(793));
var _arc = _interopRequireDefault(__webpack_require__(794));
var _line = _interopRequireDefault(__webpack_require__(174));
var _polygon = _interopRequireDefault(__webpack_require__(796));
var _polyline = _interopRequireDefault(__webpack_require__(411));
var Util = _interopRequireWildcard(__webpack_require__(87));
exports.Util = Util;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";




var inherits = __webpack_require__(12);
var inherits_default = __webpack_require__.n(inherits);


var possibleConstructorReturn = __webpack_require__(13);
var possibleConstructorReturn_default = __webpack_require__.n(possibleConstructorReturn);


var getPrototypeOf = __webpack_require__(5);
var getPrototypeOf_default = __webpack_require__.n(getPrototypeOf);


var toConsumableArray = __webpack_require__(45);
var toConsumableArray_default = __webpack_require__.n(toConsumableArray);


var classCallCheck = __webpack_require__(9);
var classCallCheck_default = __webpack_require__.n(classCallCheck);


var createClass = __webpack_require__(10);
var createClass_default = __webpack_require__.n(createClass);


var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = __webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);


var is_string = __webpack_require__(50);
var is_string_default = __webpack_require__.n(is_string);


var is_function = __webpack_require__(28);
var is_function_default = __webpack_require__.n(is_function);


var base = __webpack_require__(100);
var base_default = __webpack_require__.n(base);


var src_interface = __webpack_require__(491);


var view = __webpack_require__(47);


var core = __webpack_require__(8);


var each = __webpack_require__(55);
var each_default = __webpack_require__.n(each);


var is_array = __webpack_require__(23);
var is_array_default = __webpack_require__.n(is_array);


var shallowEqual = __webpack_require__(82);





 var compareProps = (function (preProps, nextProps, keys, callback) {
  
  if (preProps === null) {
    each_default()(keys, function (key) {
      var value = nextProps[key];
      if (value !== undefined) {
        if (!is_array_default()(value)) {
          value = [value];
        }
        callback(value, key);
      }
    });
    return;
  }
  var value;
  var nextValue;
  each_default()(keys, function (key) {
    value = preProps[key];
    nextValue = nextProps[key];
    if (!Object(shallowEqual["a" ])(nextValue, value)) {
      if (!is_array_default()(nextValue)) {
        nextValue = [nextValue];
      }
      callback(nextValue, key);
    }
  });
});

var warning = __webpack_require__(17);
var warning_default = __webpack_require__.n(warning);


var Label = __webpack_require__(290);


var active = __webpack_require__(348);
var active_default = __webpack_require__.n(active);


var link_by_color = __webpack_require__(349);
var link_by_color_default = __webpack_require__.n(link_by_color);


var range_active = __webpack_require__(350);
var range_active_default = __webpack_require__.n(range_active);


var single_active = __webpack_require__(351);
var single_active_default = __webpack_require__.n(single_active);


var highlight = __webpack_require__(159);
var highlight_default = __webpack_require__.n(highlight);


var highlight_by_x = __webpack_require__(353);
var highlight_by_x_default = __webpack_require__.n(highlight_by_x);


var highlight_by_color = __webpack_require__(352);
var highlight_by_color_default = __webpack_require__.n(highlight_by_color);


var single_highlight = __webpack_require__(354);
var single_highlight_default = __webpack_require__.n(single_highlight);


var range_highlight = __webpack_require__(226);
var range_highlight_default = __webpack_require__.n(range_highlight);


var selected = __webpack_require__(356);
var selected_default = __webpack_require__.n(selected);


var single_selected = __webpack_require__(357);
var single_selected_default = __webpack_require__.n(single_selected);


var range_selected = __webpack_require__(355);
var range_selected_default = __webpack_require__.n(range_selected);


var cursor = __webpack_require__(361);
var cursor_default = __webpack_require__.n(cursor);

















Object(core["registerAction"])('cursor', cursor_default.a);
Object(core["registerAction"])('element-active', active_default.a);
Object(core["registerAction"])('element-single-active', single_active_default.a);
Object(core["registerAction"])('element-range-active', range_active_default.a);
Object(core["registerAction"])('element-highlight', highlight_default.a);
Object(core["registerAction"])('element-highlight-by-x', highlight_by_x_default.a);
Object(core["registerAction"])('element-highlight-by-color', highlight_by_color_default.a);
Object(core["registerAction"])('element-single-highlight', single_highlight_default.a);
Object(core["registerAction"])('element-range-highlight', range_highlight_default.a);
Object(core["registerAction"])('element-sibling-highlight', range_highlight_default.a, {
  effectSiblings: true,
  effectByRecord: true
});
Object(core["registerAction"])('element-selected', selected_default.a);
Object(core["registerAction"])('element-single-selected', single_selected_default.a);
Object(core["registerAction"])('element-range-selected', range_selected_default.a);
Object(core["registerAction"])('element-link-by-color', link_by_color_default.a);

Object(core["registerInteraction"])('element-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-active:active'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-active:reset'
  }]
});

Object(core["registerInteraction"])('element-selected', {
  start: [{
    trigger: 'element:click',
    action: 'element-selected:toggle'
  }]
});

Object(core["registerInteraction"])('element-highlight', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight:reset'
  }]
});

Object(core["registerInteraction"])('element-highlight-by-x', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-x:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-x:reset'
  }]
});

Object(core["registerInteraction"])('element-highlight-by-color', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-color:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-color:reset'
  }]
});

var cloneDeep = __webpack_require__(75);








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }













Object(core["registerGeometryLabel"])('base', base_default.a);

var DEFAULT_SORT_GEOMETRYS = ['line', 'area'];
var Base_GeomHelper = function () {
  function GeomHelper() {
    classCallCheck_default()(this, GeomHelper);
    this.config = {};
  }
  createClass_default()(GeomHelper, [{
    key: "setView",
    value: function setView(view) {
      this.view = view;
      this.rootChart = view.rootChart || view; 
    }
  }, {
    key: "createGeomInstance",
    value: function createGeomInstance(GemoBaseClassName, cfg) {
      this.geom = this.view[GemoBaseClassName](cfg);
      var sortable = cfg.sortable;
      
      
      this.geom.__beforeMapping = this.geom.beforeMapping;
      
      this.geom.beforeMapping = function (data) {
        var xScale = this.getXScale();
        if (sortable !== false && data && data[0] && DEFAULT_SORT_GEOMETRYS.includes(GemoBaseClassName) && ['time', 'timeCat'].includes(xScale.type)) {
          this.sort(data);
        }
        return this.__beforeMapping(data);
      };
      this.GemoBaseClassName = GemoBaseClassName;
    }
  }, {
    key: "update",
    value: function update(newConfig, component) {
      var _this = this;
      if (!this.geom) {
        this.setView(component.context);
        
        this.createGeomInstance(component.GemoBaseClassName, newConfig);
        this.interactionTypes = component.interactionTypes;
      }
      compareProps(this.config, newConfig, ['position', 'shape', 'color', 'label', 'style', 'tooltip', 'size', 'animate', 'state', 'customInfo'], function (value, key) {
        var _this$geom;
        
        warning_default()(!(key === 'label' && value[0] === true), 'label 值类型错误，应为false | LabelOption | FieldString');
        (_this$geom = _this.geom)[key].apply(_this$geom, toConsumableArray_default()(value));
      });
      compareProps(this.config, newConfig, ['adjust'], function (value, key) {
        if (is_string_default()(value[0])) {
          _this.geom[key](value[0]);
        } else {
          _this.geom[key](value);
        }
      });
      
      this.geom.state(newConfig.state || {});
      
      
      this.rootChart.on('processElemens', function () {
        if (is_function_default()(newConfig.setElements)) {
          newConfig.setElements(_this.geom.elements);
        }
      });
      
      
      compareProps(this.config, newConfig, this.interactionTypes, function (value, key) {
        if (value[0]) {
          _this.rootChart.interaction(key);
        } else {
          _this.rootChart.removeInteraction(key);
        }
      });
      
      this.config = Object(cloneDeep["a" ])(newConfig);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.geom) {
        this.geom.destroy();
        this.geom = null;
      }
      this.config = {};
    }
  }]);
  return GeomHelper;
}();
var Base_BaseGeom = function (_React$Component) {
  inherits_default()(BaseGeom, _React$Component);
  var _super = _createSuper(BaseGeom);
  function BaseGeom(props) {
    var _this2;
    classCallCheck_default()(this, BaseGeom);
    _this2 = _super.call(this, props);
    _this2.interactionTypes = [];
    _this2.geomHelper = new Base_GeomHelper();
    return _this2;
  }
  createClass_default()(BaseGeom, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.geomHelper.destroy();
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      this.geomHelper.update(this.props, this);
      return external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null, external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Children.map(this.props.children, function (ele) {
        return external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.isValidElement(ele) ? external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.cloneElement(ele, {
          parentInstance: _this3.geomHelper.geom
        }) : external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null);
      }));
    }
  }]);
  return BaseGeom;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);
Base_BaseGeom.contextType = view["a" ];
 var Base = __webpack_exports__["a"] = (Base_BaseGeom);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return useView; });
 var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 var _context_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);


function useView() {
  
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(_context_view__WEBPACK_IMPORTED_MODULE_1__[ "a"]);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _event = __webpack_require__(432);
var _matrix = __webpack_require__(90);
var _util2 = __webpack_require__(42);
var _component = _interopRequireDefault(__webpack_require__(254));
var STATUS_UPDATE = 'update_status';
var COPY_PROPERTIES = ['visible', 'tip', 'delegateObject']; 
var COPY_PROPERTIES_EXCLUDES = ['container', 'group', 'shapesMap', 'isRegister', 'isUpdating', 'destroyed']; 
var GroupComponent = function (_super) {
  (0, _tslib.__extends)(GroupComponent, _super);
  function GroupComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GroupComponent.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      container: null,
            shapesMap: {},
      group: null,
      capture: true,
            isRegister: false,
            isUpdating: false,
            isInit: true
    });
  };
  GroupComponent.prototype.remove = function () {
    this.clear();
    var group = this.get('group');
    group.remove();
  };
  GroupComponent.prototype.clear = function () {
    var group = this.get('group');
    group.clear();
    this.set('shapesMap', {});
    this.clearOffScreenCache();
    this.set('isInit', true);
  };
  GroupComponent.prototype.getChildComponentById = function (id) {
    var group = this.getElementById(id);
    var inst = group && group.get('component');
    return inst;
  };
  GroupComponent.prototype.getElementById = function (id) {
    return this.get('shapesMap')[id];
  };
  GroupComponent.prototype.getElementByLocalId = function (localId) {
    var id = this.getElementId(localId);
    return this.getElementById(id);
  };
  GroupComponent.prototype.getElementsByName = function (name) {
    var rst = [];
    (0, _util.each)(this.get('shapesMap'), function (elem) {
      if (elem.get('name') === name) {
        rst.push(elem);
      }
    });
    return rst;
  };
  GroupComponent.prototype.getContainer = function () {
    return this.get('container');
  };
  GroupComponent.prototype.updateInner = function (cfg) {
    
    
    this.offScreenRender();
    if (this.get('updateAutoRender')) {
      this.render();
    }
  };
  GroupComponent.prototype.render = function () {
    var offScreenGroup = this.get('offScreenGroup');
    if (!offScreenGroup) {
      offScreenGroup = this.offScreenRender();
    }
    var group = this.get('group');
    this.updateElements(offScreenGroup, group);
    this.deleteElements();
    this.applyOffset();
    if (!this.get('eventInitted')) {
      this.initEvent();
      this.set('eventInitted', true);
    }
    this.set('isInit', false);
  };
  GroupComponent.prototype.show = function () {
    var group = this.get('group');
    group.show();
    this.set('visible', true);
  };
  GroupComponent.prototype.hide = function () {
    var group = this.get('group');
    group.hide();
    this.set('visible', false);
  };
  GroupComponent.prototype.setCapture = function (capture) {
    var group = this.get('group');
    group.set('capture', capture);
    this.set('capture', capture);
  };
  GroupComponent.prototype.destroy = function () {
    this.removeEvent();
    this.remove();
    _super.prototype.destroy.call(this);
  };
  GroupComponent.prototype.getBBox = function () {
    return this.get('group').getCanvasBBox();
  };
  GroupComponent.prototype.getLayoutBBox = function () {
    var group = this.get('group');
    
    var bbox = this.getInnerLayoutBBox();
    var matrix = group.getTotalMatrix();
    if (matrix) {
      bbox = (0, _matrix.applyMatrix2BBox)(matrix, bbox);
    }
    return bbox; 
  };
  
  GroupComponent.prototype.on = function (evt, callback, once) {
    var group = this.get('group');
    group.on(evt, callback, once);
    return this;
  };
  GroupComponent.prototype.off = function (evt, callback) {
    var group = this.get('group');
    group && group.off(evt, callback);
    return this;
  };
  GroupComponent.prototype.emit = function (eventName, eventObject) {
    var group = this.get('group');
    group.emit(eventName, eventObject);
  };
  GroupComponent.prototype.init = function () {
    _super.prototype.init.call(this);
    if (!this.get('group')) {
      this.initGroup();
    }
    this.offScreenRender(); 
  };
  
  GroupComponent.prototype.getInnerLayoutBBox = function () {
    return this.get('offScreenBBox') || this.get('group').getBBox();
  };
  
  GroupComponent.prototype.delegateEmit = function (eventName, eventObject) {
    var group = this.get('group');
    eventObject.target = group;
    group.emit(eventName, eventObject);
    (0, _event.propagationDelegate)(group, eventName, eventObject);
  };
  
  GroupComponent.prototype.createOffScreenGroup = function () {
    var group = this.get('group');
    var GroupClass = group.getGroupBase(); 
    var newGroup = new GroupClass({
      delegateObject: this.getDelegateObject()
    });
    return newGroup;
  };
  
  GroupComponent.prototype.applyOffset = function () {
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');
    this.moveElementTo(this.get('group'), {
      x: offsetX,
      y: offsetY
    });
  };
  GroupComponent.prototype.initGroup = function () {
    var container = this.get('container');
    this.set('group', container.addGroup({
      id: this.get('id'),
      name: this.get('name'),
      capture: this.get('capture'),
      visible: this.get('visible'),
      isComponent: true,
      component: this,
      delegateObject: this.getDelegateObject()
    }));
  };
  
  GroupComponent.prototype.offScreenRender = function () {
    this.clearOffScreenCache();
    var offScreenGroup = this.createOffScreenGroup();
    this.renderInner(offScreenGroup);
    this.set('offScreenGroup', offScreenGroup);
    
    this.set('offScreenBBox', (0, _util2.getBBoxWithClip)(offScreenGroup));
    return offScreenGroup;
  };
    GroupComponent.prototype.addGroup = function (parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var group = parent.addGroup(cfg);
    if (this.get('isRegister')) {
      this.registerElement(group);
    }
    return group;
  };
    GroupComponent.prototype.addShape = function (parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var shape = parent.addShape(cfg);
    if (this.get('isRegister')) {
      this.registerElement(shape);
    }
    return shape;
  };
    GroupComponent.prototype.addComponent = function (parent, cfg) {
    var id = cfg.id,
      Ctor = cfg.component,
      restCfg = (0, _tslib.__rest)(cfg, ["id", "component"]);
    
    var inst = new Ctor((0, _tslib.__assign)((0, _tslib.__assign)({}, restCfg), {
      id: id,
      container: parent,
      updateAutoRender: this.get('updateAutoRender')
    }));
    inst.init();
    inst.render();
    if (this.get('isRegister')) {
      this.registerElement(inst.get('group'));
    }
    return inst;
  };
  GroupComponent.prototype.initEvent = function () {};
  GroupComponent.prototype.removeEvent = function () {
    var group = this.get('group');
    group.off();
  };
  GroupComponent.prototype.getElementId = function (localId) {
    var id = this.get('id'); 
    var name = this.get('name'); 
    return id + "-" + name + "-" + localId;
  };
  GroupComponent.prototype.registerElement = function (element) {
    var id = element.get('id');
    this.get('shapesMap')[id] = element;
  };
  GroupComponent.prototype.unregisterElement = function (element) {
    var id = element.get('id');
    delete this.get('shapesMap')[id];
  };
  
  GroupComponent.prototype.moveElementTo = function (element, point) {
    var matrix = (0, _matrix.getMatrixByTranslate)(point);
    element.attr('matrix', matrix);
  };
    GroupComponent.prototype.addAnimation = function (elmentName, newElement, animateCfg) {
    
    var originOpacity = newElement.attr('opacity');
    if ((0, _util.isNil)(originOpacity)) {
      originOpacity = 1;
    }
    newElement.attr('opacity', 0);
    newElement.animate({
      opacity: originOpacity
    }, animateCfg);
  };
    GroupComponent.prototype.removeAnimation = function (elementName, originElement, animateCfg) {
    originElement.animate({
      opacity: 0
    }, animateCfg);
  };
    GroupComponent.prototype.updateAnimation = function (elementName, originElement, newAttrs, animateCfg) {
    originElement.animate(newAttrs, animateCfg);
  };
  
  GroupComponent.prototype.updateElements = function (newGroup, originGroup) {
    var _this = this;
    var animate = this.get('animate');
    var animateOption = this.get('animateOption');
    var children = newGroup.getChildren().slice(0); 
    var preElement; 
    (0, _util.each)(children, function (element) {
      var elementId = element.get('id');
      var originElement = _this.getElementById(elementId);
      var elementName = element.get('name');
      if (originElement) {
        if (element.get('isComponent')) {
          
          var childComponent = element.get('component');
          var origChildComponent = originElement.get('component');
          var newCfg = (0, _util.pick)(childComponent.cfg, (0, _util.difference)((0, _util.keys)(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
          origChildComponent.update(newCfg);
          originElement.set(STATUS_UPDATE, 'update');
        } else {
          var replaceAttrs = _this.getReplaceAttrs(originElement, element);
          
          if (animate && animateOption.update) {
            
            _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
          } else {
            
            originElement.attr(replaceAttrs);
          }
          
          if (element.isGroup()) {
            _this.updateElements(element, originElement);
          }
          
          (0, _util.each)(COPY_PROPERTIES, function (name) {
            originElement.set(name, element.get(name));
          });
          (0, _util2.updateClip)(originElement, element);
          preElement = originElement;
          
          originElement.set(STATUS_UPDATE, 'update');
        }
      } else {
        
        originGroup.add(element); 
        var siblings = originGroup.getChildren(); 
        siblings.splice(siblings.length - 1, 1); 
        if (preElement) {
          
          var index = siblings.indexOf(preElement);
          siblings.splice(index + 1, 0, element); 
        } else {
          siblings.unshift(element);
        }
        _this.registerElement(element); 
        element.set(STATUS_UPDATE, 'add'); 
        if (element.get('isComponent')) {
          
          var childComponent = element.get('component');
          childComponent.set('container', originGroup);
        } else if (element.isGroup()) {
          
          _this.registerNewGroup(element);
        }
        preElement = element;
        if (animate) {
          var animateCfg = _this.get('isInit') ? animateOption.appear : animateOption.enter;
          if (animateCfg) {
            _this.addAnimation(elementName, element, animateCfg);
          }
        }
      }
    });
  };
  GroupComponent.prototype.clearUpdateStatus = function (group) {
    var children = group.getChildren();
    (0, _util.each)(children, function (el) {
      el.set(STATUS_UPDATE, null); 
    });
  };
  
  GroupComponent.prototype.clearOffScreenCache = function () {
    var offScreenGroup = this.get('offScreenGroup');
    if (offScreenGroup) {
      
      offScreenGroup.destroy();
    }
    this.set('offScreenGroup', null);
    this.set('offScreenBBox', null);
  };
  
  
  
  
  
  
  
  
  
  
  GroupComponent.prototype.getDelegateObject = function () {
    var _a;
    var name = this.get('name');
    var delegateObject = (_a = {}, _a[name] = this, _a.component = this, _a);
    return delegateObject;
  };
  
  GroupComponent.prototype.appendDelegateObject = function (parent, cfg) {
    var parentObject = parent.get('delegateObject');
    if (!cfg.delegateObject) {
      cfg.delegateObject = {};
    }
    (0, _util.mix)(cfg.delegateObject, parentObject); 
  };
  
  GroupComponent.prototype.getReplaceAttrs = function (originElement, newElement) {
    var originAttrs = originElement.attr();
    var newAttrs = newElement.attr();
    (0, _util.each)(originAttrs, function (v, k) {
      if (newAttrs[k] === undefined) {
        newAttrs[k] = undefined;
      }
    });
    return newAttrs;
  };
  GroupComponent.prototype.registerNewGroup = function (group) {
    var _this = this;
    var children = group.getChildren();
    (0, _util.each)(children, function (element) {
      _this.registerElement(element); 
      element.set(STATUS_UPDATE, 'add'); 
      if (element.isGroup()) {
        _this.registerNewGroup(element);
      }
    });
  };
  
  GroupComponent.prototype.deleteElements = function () {
    var _this = this;
    var shapesMap = this.get('shapesMap');
    var deleteArray = [];
    
    (0, _util.each)(shapesMap, function (element, id) {
      if (!element.get(STATUS_UPDATE) || element.destroyed) {
        deleteArray.push([id, element]);
      } else {
        element.set(STATUS_UPDATE, null); 
      }
    });

    var animate = this.get('animate');
    var animateOption = this.get('animateOption');
    
    (0, _util.each)(deleteArray, function (item) {
      var id = item[0],
        element = item[1];
      if (!element.destroyed) {
        var elementName = element.get('name');
        if (animate && animateOption.leave) {
          
          var callbackAnimCfg = (0, _util.mix)({
            callback: function callback() {
              _this.removeElement(element);
            }
          }, animateOption.leave);
          _this.removeAnimation(elementName, element, callbackAnimCfg);
        } else {
          _this.removeElement(element);
        }
      }
      delete shapesMap[id]; 
    });
  };

  GroupComponent.prototype.removeElement = function (element) {
    if (element.get('isGroup')) {
      var component = element.get('component');
      if (component) {
        component.destroy();
      }
    }
    element.remove();
  };
  return GroupComponent;
}(_component.default);
var _default = GroupComponent;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearDom = clearDom;
exports.createBBox = createBBox;
exports.distance = distance;
exports.formatPadding = formatPadding;
exports.getBBoxWithClip = getBBoxWithClip;
exports.getCirclePoint = getCirclePoint;
exports.getTextPoint = getTextPoint;
exports.getValueByPercent = getValueByPercent;
exports.hasClass = hasClass;
exports.intersectBBox = intersectBBox;
exports.mergeBBox = mergeBBox;
exports.near = void 0;
exports.pointsToBBox = pointsToBBox;
exports.regionToBBox = regionToBBox;
exports.toPx = toPx;
exports.updateClip = updateClip;
exports.wait = void 0;
var _util = __webpack_require__(0);
function formatPadding(padding) {
  var top = 0;
  var left = 0;
  var right = 0;
  var bottom = 0;
  if ((0, _util.isNumber)(padding)) {
    top = left = right = bottom = padding;
  } else if ((0, _util.isArray)(padding)) {
    top = padding[0];
    right = !(0, _util.isNil)(padding[1]) ? padding[1] : padding[0];
    bottom = !(0, _util.isNil)(padding[2]) ? padding[2] : padding[0];
    left = !(0, _util.isNil)(padding[3]) ? padding[3] : right;
  }
  return [top, right, bottom, left];
}
function clearDom(container) {
  var children = container.childNodes;
  var length = children.length;
  for (var i = length - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
  var start = region.start,
    end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function pointsToBBox(points) {
  var xs = points.map(function (point) {
    return point.x;
  });
  var ys = points.map(function (point) {
    return point.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY = y + height;
  return {
    x: x,
    y: y,
    width: width,
    height: height,
    minX: x,
    minY: y,
    
    
    
    
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY) ? 0 : maxY
  };
}
function getValueByPercent(min, max, percent) {
  return (1 - percent) * min + max * percent;
}
function getCirclePoint(center, radius, angle) {
  return {
    x: center.x + Math.cos(angle) * radius,
    y: center.y + Math.sin(angle) * radius
  };
}
function distance(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
var wait = function wait(interval) {
  return new Promise(function (resolve) {
    setTimeout(resolve, interval);
  });
};
exports.wait = wait;
var near = function near(x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }
  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
exports.near = near;
function intersectBBox(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}
function mergeBBox(box1, box2) {
  var minX = Math.min(box1.minX, box2.minX);
  var minY = Math.min(box1.minY, box2.minY);
  var maxX = Math.max(box1.maxX, box2.maxX);
  var maxY = Math.max(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      (0, _util.each)(children, function (child) {
        if (child.get('visible')) {
          
          if (child.isGroup() && child.get('children').length === 0) {
            return true;
          }
          var box = getBBoxWithClip(child);
          
          var leftTop = child.applyToMatrix([box.minX, box.minY, 1]);
          var leftBottom = child.applyToMatrix([box.minX, box.maxY, 1]);
          var rightTop = child.applyToMatrix([box.maxX, box.minY, 1]);
          var rightBottom = child.applyToMatrix([box.maxX, box.maxY, 1]);
          
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox(bbox, clipBBox);
  } else {
    return bbox;
  }
}
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    
    element.setClip(null); 
    return;
  }
  var clipCfg = {
    type: newClipShape.get('type'),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
function toPx(number) {
  return number + "px";
}
function getTextPoint(start, end, position, offset) {
  var lineLength = distance(start, end);
  var offsetPercent = offset / lineLength; 
  var percent = 0;
  if (position === 'start') {
    percent = 0 - offsetPercent;
  } else if (position === 'end') {
    percent = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent),
    y: getValueByPercent(start.y, end.y, percent)
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var area_1 = __webpack_require__(1074);
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function get() {
    return area_1.area;
  }
});
var line_1 = __webpack_require__(1075);
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function get() {
    return line_1.line;
  }
});
var point_1 = __webpack_require__(1076);
Object.defineProperty(exports, "point", {
  enumerable: true,
  get: function get() {
    return point_1.point;
  }
});
var interval_1 = __webpack_require__(1077);
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function get() {
    return interval_1.interval;
  }
});
var polygon_1 = __webpack_require__(510);
Object.defineProperty(exports, "polygon", {
  enumerable: true,
  get: function get() {
    return polygon_1.polygon;
  }
});
var edge_1 = __webpack_require__(1078);
Object.defineProperty(exports, "edge", {
  enumerable: true,
  get: function get() {
    return edge_1.edge;
  }
});
var schema_1 = __webpack_require__(1079);
Object.defineProperty(exports, "schema", {
  enumerable: true,
  get: function get() {
    return schema_1.schema;
  }
});
var violin_1 = __webpack_require__(1080);
Object.defineProperty(exports, "violin", {
  enumerable: true,
  get: function get() {
    return violin_1.violin;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(0);
var Action = function () {
  function Action(context, cfg) {
    this.context = context;
    this.cfg = cfg;
    context.addAction(this);
  }
    Action.prototype.applyCfg = function (cfg) {
    (0, util_1.assign)(this, cfg);
  };
    Action.prototype.init = function () {
    this.applyCfg(this.cfg);
  };
    Action.prototype.destroy = function () {
    
    this.context.removeAction(this);
    
    this.context = null;
  };
  return Action;
}();
exports.default = Action;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var arrayWithoutHoles = __webpack_require__(1036);
var iterableToArray = __webpack_require__(1037);
var unsupportedIterableToArray = __webpack_require__(481);
var nonIterableSpread = __webpack_require__(1038);
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getReplaceAttrs = exports.getPolygonCentroid = exports.getAngle = exports.getArcPath = exports.getSectorPath = exports.polarToCartesian = void 0;
var util_1 = __webpack_require__(0);

function getPointsBox(points) {
  if ((0, util_1.isEmpty)(points)) {
    return null;
  }
  var minX = points[0].x;
  var maxX = points[0].x;
  var minY = points[0].y;
  var maxY = points[0].y;
  (0, util_1.each)(points, function (point) {
    minX = minX > point.x ? point.x : minX;
    maxX = maxX < point.x ? point.x : maxX;
    minY = minY > point.y ? point.y : minY;
    maxY = maxY < point.y ? point.y : maxY;
  });
  return {
    minX: minX,
    maxX: maxX,
    minY: minY,
    maxY: maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2
  };
}
function uniqueValues(array) {
  return Array.from(new Set(array)).length === 1;
}
function mid(array) {
  return ((0, util_1.min)(array) + (0, util_1.max)(array)) / 2;
}
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}
exports.polarToCartesian = polarToCartesian;
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, end.x, end.y], ['M', innerStart.x, innerStart.y]];
    if (innerRadius) {
      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }
    circlePathCommands.push(['M', start.x, start.y]);
    circlePathCommands.push(['Z']);
    return circlePathCommands;
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y], ['L', innerEnd.x, innerEnd.y]];
  if (innerRadius) {
    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }
  sectorPathCommands.push(['L', start.x, start.y]);
  sectorPathCommands.push(['Z']);
  return sectorPathCommands;
}
exports.getSectorPath = getSectorPath;
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  if ((0, util_1.isNumberEqual)(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, start.x, start.y], ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 0, start.x, start.y], ['Z']];
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y]];
}
exports.getArcPath = getArcPath;
function getAngle(shapeModel, coordinate) {
  var points = shapeModel.points;
  var box = getPointsBox(points);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate.startAngle,
    coordEndAngle = coordinate.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;
  if (coordinate.isTransposed) {
    endAngle = box.maxY * diffAngle;
    startAngle = box.minY * diffAngle;
  } else {
    endAngle = box.maxX * diffAngle;
    startAngle = box.minX * diffAngle;
  }
  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle: startAngle,
    endAngle: endAngle
  };
}
exports.getAngle = getAngle;
function getPolygonCentroid(xs, ys) {
  if ((0, util_1.isNumber)(xs) && (0, util_1.isNumber)(ys)) {
    
    return [xs, ys];
  }
  xs = xs;
  ys = ys;
  
  
  
  
  
  
  if (uniqueValues(xs) || uniqueValues(ys)) return [mid(xs), mid(ys)];
  var i = -1;
  var x = 0;
  var y = 0;
  var former;
  var current = xs.length - 1;
  var diff;
  var k = 0;
  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff;
    y += (ys[former] + ys[current]) * diff;
  }
  k *= 3;
  return [x / k, y / k];
}
exports.getPolygonCentroid = getPolygonCentroid;
function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  (0, util_1.each)(originAttrs, function (v, k) {
    if (newAttrs[k] === undefined) {
      newAttrs[k] = undefined;
    }
  });
  return newAttrs;
}
exports.getReplaceAttrs = getReplaceAttrs;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "b", function() { return withView; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);



var ChartViewContext = react__WEBPACK_IMPORTED_MODULE_1___default.a.createContext(null);
ChartViewContext.displayName = 'ChartViewContext';
var Consumer = ChartViewContext.Consumer;
function withView(Component) {
  return function (props) {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Consumer, null, function (ctx) {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        chartView: ctx
      }, props));
    });
  };
}
 __webpack_exports__["a"] = (ChartViewContext);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCoordinateBBox = exports.getCoordinateClipCfg = exports.getAngleByPoint = exports.isPointInCoordinate = exports.getDistanceToCenter = exports.isFullCircle = exports.getXDimensionLength = void 0;
var graphics_1 = __webpack_require__(46);
var helper_1 = __webpack_require__(70);
var bbox_1 = __webpack_require__(80);
function getXDimensionLength(coordinate) {
  if (coordinate.isPolar && !coordinate.isTransposed) {
    
    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();
  }
  
  var start = coordinate.convert({
    x: 0,
    y: 0
  });
  var end = coordinate.convert({
    x: 1,
    y: 0
  });
  
  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
exports.getXDimensionLength = getXDimensionLength;
function isFullCircle(coordinate) {
  if (coordinate.isPolar) {
    var startAngle = coordinate.startAngle,
      endAngle = coordinate.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }
  return false;
}
exports.isFullCircle = isFullCircle;
function getDistanceToCenter(coordinate, point) {
  var center = coordinate.getCenter();
  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
}
exports.getDistanceToCenter = getDistanceToCenter;
function isPointInCoordinate(coordinate, point) {
  var result = false;
  if (coordinate) {
    if (coordinate.type === 'theta') {
      var start = coordinate.start,
        end = coordinate.end;
      result = (0, helper_1.isBetween)(point.x, start.x, end.x) && (0, helper_1.isBetween)(point.y, start.y, end.y);
    } else {
      var invertPoint = coordinate.invert(point);
      result = (0, helper_1.isBetween)(invertPoint.x, 0, 1) && (0, helper_1.isBetween)(invertPoint.y, 0, 1);
    }
  }
  return result;
}
exports.isPointInCoordinate = isPointInCoordinate;
function getAngleByPoint(coordinate, point) {
  var center = coordinate.getCenter();
  return Math.atan2(point.y - center.y, point.x - center.x);
}
exports.getAngleByPoint = getAngleByPoint;
function getCoordinateClipCfg(coordinate, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate.start,
    end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  if (coordinate.isPolar) {
    var startAngle_1 = coordinate.startAngle,
      endAngle_1 = coordinate.endAngle;
    var center_1 = coordinate.getCenter();
    var radius_1 = coordinate.getRadius();
    return {
      type: 'path',
      startState: {
        path: (0, graphics_1.getSectorPath)(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function endState(ratio) {
        var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path = (0, graphics_1.getSectorPath)(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);
        return {
          path: path
        };
      },
      attrs: {
        path: (0, graphics_1.getSectorPath)(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }
  var endState;
  if (coordinate.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }
  return {
    type: 'rect',
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate.isTransposed ? width + margin * 2 : 0,
      height: coordinate.isTransposed ? 0 : height + margin * 2
    },
    endState: endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}
exports.getCoordinateClipCfg = getCoordinateClipCfg;
function getCoordinateBBox(coordinate, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate.start,
    end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return bbox_1.BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}
exports.getCoordinateBBox = getCoordinateBBox;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geometry = geometry;
exports.getMappingField = getMappingField;
exports.getMappingFunction = getMappingFunction;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
function getMappingField(o, field) {
  var type = o.type,
    xField = o.xField,
    yField = o.yField,
    colorField = o.colorField,
    shapeField = o.shapeField,
    sizeField = o.sizeField,
    styleField = o.styleField,
    _a = o.rawFields,
    rawFields = _a === void 0 ? [] : _a;
  var fields = [];
  
  
  
  if (field === 'color') {
    fields = (0, _tslib.__spreadArrays)([colorField || xField], rawFields);
  } else if (field === 'shape') {
    fields = (0, _tslib.__spreadArrays)([shapeField || xField], rawFields);
  } else if (field === 'size') {
    fields = (0, _tslib.__spreadArrays)([sizeField || xField], rawFields);
  } else {
    fields = (0, _tslib.__spreadArrays)([xField, yField, colorField, shapeField, sizeField, styleField], rawFields);
    
    var idx = ['x', 'y', 'color', 'shape', 'size', 'style'].indexOf(field);
    var f = fields[idx];
    
    fields.splice(idx, 1);
    
    fields.unshift(f);
  }
  var mappingFields = (0, _util.uniq)(fields.filter(function (f) {
    return !!f;
  }));
    var tileMappingField = type === 'line' && [xField, yField].includes(mappingFields.join('*')) ? '' : mappingFields.join('*');
  return {
    mappingFields: mappingFields,
    tileMappingField: tileMappingField
  };
}
/**
 * 获得映射函数
 * @param mappingFields
 * @param func
 */
function getMappingFunction(mappingFields, func) {
  if (!func) return undefined;
  // 返回函数
  return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {};
    mappingFields.forEach(function (f, idx) {
      params[f] = args[idx];
    });
    // 删除 undefined
    delete params['undefined'];
    return func(params);
  };
}
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var type = options.type,
    args = options.args,
    mapping = options.mapping,
    xField = options.xField,
    yField = options.yField,
    colorField = options.colorField,
    shapeField = options.shapeField,
    sizeField = options.sizeField,
    tooltipFields = options.tooltipFields,
    label = options.label,
    state = options.state,
    customInfo = options.customInfo;
  
  if (!mapping) {
    return params;
  }
  var color = mapping.color,
    shape = mapping.shape,
    size = mapping.size,
    style = mapping.style,
    tooltip = mapping.tooltip;
  
  var geometry = chart[type](args).position(xField + "*" + yField);
    if ((0, _util.isString)(color)) {
    colorField ? geometry.color(colorField, color) : geometry.color(color);
  } else if ((0, _util.isFunction)(color)) {
    var _a = getMappingField(options, 'color'),
      mappingFields = _a.mappingFields,
      tileMappingField = _a.tileMappingField;
    geometry.color(tileMappingField, getMappingFunction(mappingFields, color));
  } else {
    colorField && geometry.color(colorField, color);
  }
    if ((0, _util.isString)(shape)) {
    shapeField ? geometry.shape(shapeField, [shape]) : geometry.shape(shape); 
  } else if ((0, _util.isFunction)(shape)) {
    var _b = getMappingField(options, 'shape'),
      mappingFields = _b.mappingFields,
      tileMappingField = _b.tileMappingField;
    geometry.shape(tileMappingField, getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry.shape(shapeField, shape);
  }
    if ((0, _util.isNumber)(size)) {
    sizeField ? geometry.size(sizeField, size) : geometry.size(size);
  } else if ((0, _util.isFunction)(size)) {
    var _c = getMappingField(options, 'size'),
      mappingFields = _c.mappingFields,
      tileMappingField = _c.tileMappingField;
    geometry.size(tileMappingField, getMappingFunction(mappingFields, size));
  } else {
    sizeField && geometry.size(sizeField, size);
  }
    if ((0, _util.isFunction)(style)) {
    var _d = getMappingField(options, 'style'),
      mappingFields = _d.mappingFields,
      tileMappingField = _d.tileMappingField;
    geometry.style(tileMappingField, getMappingFunction(mappingFields, style));
  } else if ((0, _util.isObject)(style)) {
    geometry.style(style);
  }
    if (tooltipFields === false) {
    geometry.tooltip(false);
  } else if (!(0, _util.isEmpty)(tooltipFields)) {
    geometry.tooltip(tooltipFields.join('*'), getMappingFunction(tooltipFields, tooltip));
  }
    if (label === false) {
    geometry.label(false);
  } else if (label) {
    var callback = label.callback,
      fields = label.fields,
      cfg = (0, _tslib.__rest)(label, ["callback", "fields"]);
    geometry.label({
      fields: fields || [yField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }
    if (state) {
    geometry.state(state);
  }
    if (customInfo) {
    geometry.customInfo(customInfo);
  }
  
  [xField, yField].filter(function (f) {
    return f !== colorField;
  }).forEach(function (f) {
    chart.legend(f, false);
  });
  return (0, _tslib.__assign)((0, _tslib.__assign)({}, params), {
    
    ext: {
      geometry: geometry
    }
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_type_1 = __webpack_require__(117);
exports.default = function (str) {
  return is_type_1.default(str, 'String');
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearAnimationFrame = exports.requestAnimationFrame = exports.isNumberEqual = exports.mod = exports.toRadian = exports.each = exports.isArray = exports.isFunction = exports.isString = exports.isNil = exports.isSamePoint = exports.mergeRegion = exports.intersectRect = exports.inBox = exports.distance = exports.getPixelRatio = void 0;
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
exports.getPixelRatio = getPixelRatio;
function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
exports.distance = distance;
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
exports.inBox = inBox;
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
exports.intersectRect = intersectRect;

function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
exports.mergeRegion = mergeRegion;
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
exports.isSamePoint = isSamePoint;
var util_1 = __webpack_require__(0);
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return util_1.isNil;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return util_1.isString;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return util_1.isFunction;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return util_1.isArray;
  }
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return util_1.each;
  }
});
Object.defineProperty(exports, "toRadian", {
  enumerable: true,
  get: function get() {
    return util_1.toRadian;
  }
});
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return util_1.mod;
  }
});
Object.defineProperty(exports, "isNumberEqual", {
  enumerable: true,
  get: function get() {
    return util_1.isNumberEqual;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return util_1.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "clearAnimationFrame", {
  enumerable: true,
  get: function get() {
    return util_1.clearAnimationFrame;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EVENTS = exports.SVG_ATTR_MAP = exports.SHAPE_TO_TAGS = void 0;
exports.SHAPE_TO_TAGS = {
  rect: 'path',
  circle: 'circle',
  line: 'line',
  path: 'path',
  marker: 'path',
  text: 'text',
  polyline: 'polyline',
  polygon: 'polygon',
  image: 'image',
  ellipse: 'ellipse',
  dom: 'foreignObject'
};
exports.SVG_ATTR_MAP = {
  opacity: 'opacity',
  fillStyle: 'fill',
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  strokeStyle: 'stroke',
  strokeOpacity: 'stroke-opacity',
  stroke: 'stroke',
  x: 'x',
  y: 'y',
  r: 'r',
  rx: 'rx',
  ry: 'ry',
  width: 'width',
  height: 'height',
  x1: 'x1',
  x2: 'x2',
  y1: 'y1',
  y2: 'y2',
  lineCap: 'stroke-linecap',
  lineJoin: 'stroke-linejoin',
  lineWidth: 'stroke-width',
  lineDash: 'stroke-dasharray',
  lineDashOffset: 'stroke-dashoffset',
  miterLimit: 'stroke-miterlimit',
  font: 'font',
  fontSize: 'font-size',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  fontFamily: 'font-family',
  startArrow: 'marker-start',
  endArrow: 'marker-end',
  path: 'd',
  class: 'class',
  id: 'id',
  style: 'style',
  preserveAspectRatio: 'preserveAspectRatio'
};
exports.EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mouseenter', 'mouseleave', 'mouseover', 'mouseout', 'mousemove', 'wheel'];

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "clearAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _util.clearAnimationFrame;
  }
});
exports.distance = distance;
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return _util.each;
  }
});
exports.getPixelRatio = getPixelRatio;
exports.inBox = inBox;
exports.intersectRect = intersectRect;
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _util.isArray;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return _util.isFunction;
  }
});
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return _util.isNil;
  }
});
Object.defineProperty(exports, "isNumberEqual", {
  enumerable: true,
  get: function get() {
    return _util.isNumberEqual;
  }
});
exports.isSamePoint = isSamePoint;
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return _util.isString;
  }
});
exports.mergeRegion = mergeRegion;
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return _util.mod;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _util.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "toRadian", {
  enumerable: true,
  get: function get() {
    return _util.toRadian;
  }
});
var _util = __webpack_require__(0);
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}

function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVG_ATTR_MAP = exports.SHAPE_TO_TAGS = exports.EVENTS = void 0;
var SHAPE_TO_TAGS = {
  rect: 'path',
  circle: 'circle',
  line: 'line',
  path: 'path',
  marker: 'path',
  text: 'text',
  polyline: 'polyline',
  polygon: 'polygon',
  image: 'image',
  ellipse: 'ellipse',
  dom: 'foreignObject'
};
exports.SHAPE_TO_TAGS = SHAPE_TO_TAGS;
var SVG_ATTR_MAP = {
  opacity: 'opacity',
  fillStyle: 'fill',
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  strokeStyle: 'stroke',
  strokeOpacity: 'stroke-opacity',
  stroke: 'stroke',
  x: 'x',
  y: 'y',
  r: 'r',
  rx: 'rx',
  ry: 'ry',
  width: 'width',
  height: 'height',
  x1: 'x1',
  x2: 'x2',
  y1: 'y1',
  y2: 'y2',
  lineCap: 'stroke-linecap',
  lineJoin: 'stroke-linejoin',
  lineWidth: 'stroke-width',
  lineDash: 'stroke-dasharray',
  lineDashOffset: 'stroke-dashoffset',
  miterLimit: 'stroke-miterlimit',
  font: 'font',
  fontSize: 'font-size',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  fontFamily: 'font-family',
  startArrow: 'marker-start',
  endArrow: 'marker-end',
  path: 'd',
  class: 'class',
  id: 'id',
  style: 'style',
  preserveAspectRatio: 'preserveAspectRatio'
};
exports.SVG_ATTR_MAP = SVG_ATTR_MAP;
var EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mouseenter', 'mouseleave', 'mouseover', 'mouseout', 'mousemove', 'wheel'];
exports.EVENTS = EVENTS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_array_1 = __webpack_require__(23);
var is_object_1 = __webpack_require__(61);
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_1.default(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_1.default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
exports.default = each;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var isArrayLike = function isArrayLike(value) {
    return value !== null && typeof value !== 'function' && isFinite(value.length);
};
var _default = isArrayLike;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isType = _interopRequireDefault(__webpack_require__(68));
var _default = function _default(value) {
  return (0, _isType.default)(value, 'Function');
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  fontFamily: "\n  BlinkMacSystemFont, \"Segoe UI\", Roboto,\"Helvetica Neue\",\n  Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\",\n  SimSun, \"sans-serif\"",
  textColor: '#2C3542',
  activeTextColor: '#333333',
  uncheckedColor: '#D8D8D8',
  lineColor: '#416180',
  regionColor: '#CCD7EB',
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4,
  
  descriptionIconStroke: '#fff',
  descriptionIconFill: 'rgba(58, 73, 101, .25)'
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geometry = exports.getMappingFunction = exports.getMappingField = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
function getMappingField(o, field) {
  var type = o.type,
    xField = o.xField,
    yField = o.yField,
    colorField = o.colorField,
    shapeField = o.shapeField,
    sizeField = o.sizeField,
    styleField = o.styleField,
    _a = o.rawFields,
    rawFields = _a === void 0 ? [] : _a;
  var fields = [];
  
  
  
  if (field === 'color') {
    fields = tslib_1.__spreadArrays([colorField || xField], rawFields);
  } else if (field === 'shape') {
    fields = tslib_1.__spreadArrays([shapeField || xField], rawFields);
  } else if (field === 'size') {
    fields = tslib_1.__spreadArrays([sizeField || xField], rawFields);
  } else {
    fields = tslib_1.__spreadArrays([xField, yField, colorField, shapeField, sizeField, styleField], rawFields);
    
    var idx = ['x', 'y', 'color', 'shape', 'size', 'style'].indexOf(field);
    var f = fields[idx];
    
    fields.splice(idx, 1);
    
    fields.unshift(f);
  }
  var mappingFields = util_1.uniq(fields.filter(function (f) {
    return !!f;
  }));
    var tileMappingField = type === 'line' && [xField, yField].includes(mappingFields.join('*')) ? '' : mappingFields.join('*');
  return {
    mappingFields: mappingFields,
    tileMappingField: tileMappingField
  };
}
exports.getMappingField = getMappingField;
/**
 * 获得映射函数
 * @param mappingFields
 * @param func
 */
function getMappingFunction(mappingFields, func) {
  if (!func) return undefined;
  // 返回函数
  return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {};
    mappingFields.forEach(function (f, idx) {
      params[f] = args[idx];
    });
    // 删除 undefined
    delete params['undefined'];
    return func(params);
  };
}
exports.getMappingFunction = getMappingFunction;
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var type = options.type,
    args = options.args,
    mapping = options.mapping,
    xField = options.xField,
    yField = options.yField,
    colorField = options.colorField,
    shapeField = options.shapeField,
    sizeField = options.sizeField,
    tooltipFields = options.tooltipFields,
    label = options.label,
    state = options.state,
    customInfo = options.customInfo;
  
  if (!mapping) {
    return params;
  }
  var color = mapping.color,
    shape = mapping.shape,
    size = mapping.size,
    style = mapping.style,
    tooltip = mapping.tooltip;
  
  var geometry = chart[type](args).position(xField + "*" + yField);
    if (util_1.isString(color)) {
    colorField ? geometry.color(colorField, color) : geometry.color(color);
  } else if (util_1.isFunction(color)) {
    var _a = getMappingField(options, 'color'),
      mappingFields = _a.mappingFields,
      tileMappingField = _a.tileMappingField;
    geometry.color(tileMappingField, getMappingFunction(mappingFields, color));
  } else {
    colorField && geometry.color(colorField, color);
  }
    if (util_1.isString(shape)) {
    shapeField ? geometry.shape(shapeField, [shape]) : geometry.shape(shape); 
  } else if (util_1.isFunction(shape)) {
    var _b = getMappingField(options, 'shape'),
      mappingFields = _b.mappingFields,
      tileMappingField = _b.tileMappingField;
    geometry.shape(tileMappingField, getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry.shape(shapeField, shape);
  }
    if (util_1.isNumber(size)) {
    sizeField ? geometry.size(sizeField, size) : geometry.size(size);
  } else if (util_1.isFunction(size)) {
    var _c = getMappingField(options, 'size'),
      mappingFields = _c.mappingFields,
      tileMappingField = _c.tileMappingField;
    geometry.size(tileMappingField, getMappingFunction(mappingFields, size));
  } else {
    sizeField && geometry.size(sizeField, size);
  }
    if (util_1.isFunction(style)) {
    var _d = getMappingField(options, 'style'),
      mappingFields = _d.mappingFields,
      tileMappingField = _d.tileMappingField;
    geometry.style(tileMappingField, getMappingFunction(mappingFields, style));
  } else if (util_1.isObject(style)) {
    geometry.style(style);
  }
    if (tooltipFields === false) {
    geometry.tooltip(false);
  } else if (!util_1.isEmpty(tooltipFields)) {
    geometry.tooltip(tooltipFields.join('*'), getMappingFunction(tooltipFields, tooltip));
  }
    if (label === false) {
    geometry.label(false);
  } else if (label) {
    var callback = label.callback,
      fields = label.fields,
      cfg = tslib_1.__rest(label, ["callback", "fields"]);
    geometry.label({
      fields: fields || [yField],
      callback: callback,
      cfg: utils_1.transformLabel(cfg)
    });
  }
    if (state) {
    geometry.state(state);
  }
    if (customInfo) {
    geometry.customInfo(customInfo);
  }
  
  [xField, yField].filter(function (f) {
    return f !== colorField;
  }).forEach(function (f) {
    chart.legend(f, false);
  });
  return tslib_1.__assign(tslib_1.__assign({}, params), {
    
    ext: {
      geometry: geometry
    }
  });
}
exports.geometry = geometry;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "color", {
  enumerable: true,
  get: function get() {
    return _color.default;
  }
});
Object.defineProperty(exports, "cubehelix", {
  enumerable: true,
  get: function get() {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "gray", {
  enumerable: true,
  get: function get() {
    return _lab.gray;
  }
});
Object.defineProperty(exports, "hcl", {
  enumerable: true,
  get: function get() {
    return _lab.hcl;
  }
});
Object.defineProperty(exports, "hsl", {
  enumerable: true,
  get: function get() {
    return _color.hsl;
  }
});
Object.defineProperty(exports, "lab", {
  enumerable: true,
  get: function get() {
    return _lab.default;
  }
});
Object.defineProperty(exports, "lch", {
  enumerable: true,
  get: function get() {
    return _lab.lch;
  }
});
Object.defineProperty(exports, "rgb", {
  enumerable: true,
  get: function get() {
    return _color.rgb;
  }
});
var _color = _interopRequireWildcard(__webpack_require__(245));
var _lab = _interopRequireWildcard(__webpack_require__(757));
var _cubehelix = _interopRequireDefault(__webpack_require__(758));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = function (value) {
    var type = (0, _typeof2.default)(value);
  return value !== null && type === 'object' || type === 'function';
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var g_base_1 = __webpack_require__(26);
var svg_1 = __webpack_require__(145);
var dom_1 = __webpack_require__(72);
var draw_1 = __webpack_require__(261);
var constant_1 = __webpack_require__(52);
var Shape = __webpack_require__(184);
var group_1 = __webpack_require__(262);
var g_base_2 = __webpack_require__(26);
var ShapeBase = function (_super) {
  tslib_1.__extends(ShapeBase, _super);
  function ShapeBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'svg';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    
    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  };
  
  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get('canvas');
    
    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.draw(context, targetAttrs);
    }
  };
  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };
  ShapeBase.prototype.getGroupBase = function () {
    return group_1.default;
  };
    ShapeBase.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };
  ShapeBase.prototype.calculateBBox = function () {
    var el = this.get('el');
    var bbox = null;
    
    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = g_base_2.getBBoxMethod(this.get('type'));
      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }
    if (bbox) {
      var x = bbox.x,
        y = bbox.y,
        width = bbox.width,
        height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x - halfWidth;
      var minY = y - halfWidth;
      var maxX = x + width + halfWidth;
      var maxY = y + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }
    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };
  ShapeBase.prototype.isFill = function () {
    var _a = this.attr(),
      fill = _a.fill,
      fillStyle = _a.fillStyle;
    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };
  ShapeBase.prototype.isStroke = function () {
    var _a = this.attr(),
      stroke = _a.stroke,
      strokeStyle = _a.strokeStyle;
    return (stroke || strokeStyle) && this.canStroke;
  };
  ShapeBase.prototype.draw = function (context, targetAttrs) {
    var el = this.get('el');
    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        dom_1.createDom(this);
      }
      svg_1.setClip(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
    ShapeBase.prototype.createPath = function (context, targetAttrs) {};
  
  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill,
      fillStyle = attrs.fillStyle,
      stroke = attrs.stroke,
      strokeStyle = attrs.strokeStyle,
      fillOpacity = attrs.fillOpacity,
      strokeOpacity = attrs.strokeOpacity,
      lineWidth = attrs.lineWidth;
    var el = this.get('el');
    if (this.canFill) {
      
      if (!targetAttrs) {
        this._setColor(context, 'fill', fill || fillStyle);
      } else if ('fill' in attrs) {
        this._setColor(context, 'fill', fill);
      } else if ('fillStyle' in attrs) {
        
        this._setColor(context, 'fill', fillStyle);
      }
      if (fillOpacity) {
        el.setAttribute(constant_1.SVG_ATTR_MAP['fillOpacity'], fillOpacity);
      }
    }
    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, 'stroke', stroke || strokeStyle);
      } else if ('stroke' in attrs) {
        this._setColor(context, 'stroke', stroke);
      } else if ('strokeStyle' in attrs) {
        
        this._setColor(context, 'stroke', strokeStyle);
      }
      if (strokeOpacity) {
        el.setAttribute(constant_1.SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);
      }
      if (lineWidth) {
        el.setAttribute(constant_1.SVG_ATTR_MAP['lineWidth'], lineWidth);
      }
    }
  };
  ShapeBase.prototype._setColor = function (context, attr, value) {
    var el = this.get('el');
    if (!value) {
      
      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], 'none');
      return;
    }
    value = value.trim();
    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id = context.find('gradient', value);
      if (!id) {
        id = context.addGradient(value);
      }
      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var id = context.find('pattern', value);
      if (!id) {
        id = context.addPattern(value);
      }
      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else {
      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
    }
  };
  ShapeBase.prototype.shadow = function (context, targetAttrs) {
    var attrs = this.attr();
    var _a = targetAttrs || attrs,
      shadowOffsetX = _a.shadowOffsetX,
      shadowOffsetY = _a.shadowOffsetY,
      shadowBlur = _a.shadowBlur,
      shadowColor = _a.shadowColor;
    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      svg_1.setShadow(this, context);
    }
  };
  ShapeBase.prototype.transform = function (targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;
    if (matrix) {
      svg_1.setTransform(this);
    }
  };
  ShapeBase.prototype.isInShape = function (refX, refY) {
    return this.isPointInPath(refX, refY);
  };
  ShapeBase.prototype.isPointInPath = function (refX, refY) {
    var el = this.get('el');
    var canvas = this.get('canvas');
    var bbox = canvas.get('el').getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);
    if (element && element.isEqualNode(el)) {
      return true;
    }
    return false;
  };
    ShapeBase.prototype.getHitLineWidth = function () {
    var _a = this.attrs,
      lineWidth = _a.lineWidth,
      lineAppendWidth = _a.lineAppendWidth;
    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }
    return 0;
  };
  return ShapeBase;
}(g_base_1.AbstractShape);
exports.default = ShapeBase;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _gBase = __webpack_require__(26);
var _svg = __webpack_require__(149);
var _dom = __webpack_require__(74);
var _draw = __webpack_require__(274);
var _constant = __webpack_require__(54);
var Shape = _interopRequireWildcard(__webpack_require__(190));
var _group = _interopRequireDefault(__webpack_require__(275));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var ShapeBase = function (_super) {
  (0, _tslib.__extends)(ShapeBase, _super);
  function ShapeBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'svg';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  };
  
  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get('canvas');
    
    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.draw(context, targetAttrs);
    }
  };
  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };
  ShapeBase.prototype.getGroupBase = function () {
    return _group.default;
  };
    ShapeBase.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };
  ShapeBase.prototype.calculateBBox = function () {
    var el = this.get('el');
    var bbox = null;
    
    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = (0, _gBase.getBBoxMethod)(this.get('type'));
      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }
    if (bbox) {
      var x = bbox.x,
        y = bbox.y,
        width = bbox.width,
        height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x - halfWidth;
      var minY = y - halfWidth;
      var maxX = x + width + halfWidth;
      var maxY = y + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }
    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };
  ShapeBase.prototype.isFill = function () {
    var _a = this.attr(),
      fill = _a.fill,
      fillStyle = _a.fillStyle;
    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };
  ShapeBase.prototype.isStroke = function () {
    var _a = this.attr(),
      stroke = _a.stroke,
      strokeStyle = _a.strokeStyle;
    return (stroke || strokeStyle) && this.canStroke;
  };
  ShapeBase.prototype.draw = function (context, targetAttrs) {
    var el = this.get('el');
    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        (0, _dom.createDom)(this);
      }
      (0, _svg.setClip)(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
    ShapeBase.prototype.createPath = function (context, targetAttrs) {};
  
  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill,
      fillStyle = attrs.fillStyle,
      stroke = attrs.stroke,
      strokeStyle = attrs.strokeStyle,
      fillOpacity = attrs.fillOpacity,
      strokeOpacity = attrs.strokeOpacity,
      lineWidth = attrs.lineWidth;
    var el = this.get('el');
    if (this.canFill) {
      
      if (!targetAttrs) {
        this._setColor(context, 'fill', fill || fillStyle);
      } else if ('fill' in attrs) {
        this._setColor(context, 'fill', fill);
      } else if ('fillStyle' in attrs) {
        
        this._setColor(context, 'fill', fillStyle);
      }
      if (fillOpacity) {
        el.setAttribute(_constant.SVG_ATTR_MAP['fillOpacity'], fillOpacity);
      }
    }
    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, 'stroke', stroke || strokeStyle);
      } else if ('stroke' in attrs) {
        this._setColor(context, 'stroke', stroke);
      } else if ('strokeStyle' in attrs) {
        
        this._setColor(context, 'stroke', strokeStyle);
      }
      if (strokeOpacity) {
        el.setAttribute(_constant.SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);
      }
      if (lineWidth) {
        el.setAttribute(_constant.SVG_ATTR_MAP['lineWidth'], lineWidth);
      }
    }
  };
  ShapeBase.prototype._setColor = function (context, attr, value) {
    var el = this.get('el');
    if (!value) {
      
      el.setAttribute(_constant.SVG_ATTR_MAP[attr], 'none');
      return;
    }
    value = value.trim();
    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id = context.find('gradient', value);
      if (!id) {
        id = context.addGradient(value);
      }
      el.setAttribute(_constant.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var id = context.find('pattern', value);
      if (!id) {
        id = context.addPattern(value);
      }
      el.setAttribute(_constant.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else {
      el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
    }
  };
  ShapeBase.prototype.shadow = function (context, targetAttrs) {
    var attrs = this.attr();
    var _a = targetAttrs || attrs,
      shadowOffsetX = _a.shadowOffsetX,
      shadowOffsetY = _a.shadowOffsetY,
      shadowBlur = _a.shadowBlur,
      shadowColor = _a.shadowColor;
    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      (0, _svg.setShadow)(this, context);
    }
  };
  ShapeBase.prototype.transform = function (targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;
    if (matrix) {
      (0, _svg.setTransform)(this);
    }
  };
  ShapeBase.prototype.isInShape = function (refX, refY) {
    return this.isPointInPath(refX, refY);
  };
  ShapeBase.prototype.isPointInPath = function (refX, refY) {
    var el = this.get('el');
    var canvas = this.get('canvas');
    var bbox = canvas.get('el').getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);
    if (element && element.isEqualNode(el)) {
      return true;
    }
    return false;
  };
    ShapeBase.prototype.getHitLineWidth = function () {
    var _a = this.attrs,
      lineWidth = _a.lineWidth,
      lineAppendWidth = _a.lineAppendWidth;
    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }
    return 0;
  };
  return ShapeBase;
}(_gBase.AbstractShape);
var _default = ShapeBase;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTooltipMapping = void 0;
var util_1 = __webpack_require__(0);
function getTooltipMapping(tooltip, defaultFields) {
  if (tooltip === false) {
    return {
      fields: false
    };
  }
  var fields = util_1.get(tooltip, 'fields');
  var formatter = util_1.get(tooltip, 'formatter');
  if (formatter && !fields) {
    fields = defaultFields;
  }
  return {
    fields: fields,
    formatter: formatter
  };
}
exports.getTooltipMapping = getTooltipMapping;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTooltipMapping = getTooltipMapping;
var _util = __webpack_require__(0);
function getTooltipMapping(tooltip, defaultFields) {
  if (tooltip === false) {
    return {
      fields: false
    };
  }
  var fields = (0, _util.get)(tooltip, 'fields');
  var formatter = (0, _util.get)(tooltip, 'formatter');
  if (formatter && !fields) {
    fields = defaultFields;
  }
  return {
    fields: fields,
    formatter: formatter
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Category", {
  enumerable: true,
  get: function get() {
    return _base2.default;
  }
});
Object.defineProperty(exports, "Identity", {
  enumerable: true,
  get: function get() {
    return _index.default;
  }
});
Object.defineProperty(exports, "Linear", {
  enumerable: true,
  get: function get() {
    return _linear.default;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _log.default;
  }
});
Object.defineProperty(exports, "Pow", {
  enumerable: true,
  get: function get() {
    return _pow.default;
  }
});
Object.defineProperty(exports, "Quantile", {
  enumerable: true,
  get: function get() {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "Quantize", {
  enumerable: true,
  get: function get() {
    return _quantize.default;
  }
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _time2.default;
  }
});
Object.defineProperty(exports, "TimeCat", {
  enumerable: true,
  get: function get() {
    return _time.default;
  }
});
Object.defineProperty(exports, "getScale", {
  enumerable: true,
  get: function get() {
    return _factory.getScale;
  }
});
Object.defineProperty(exports, "getTickMethod", {
  enumerable: true,
  get: function get() {
    return _index2.getTickMethod;
  }
});
Object.defineProperty(exports, "registerScale", {
  enumerable: true,
  get: function get() {
    return _factory.registerScale;
  }
});
Object.defineProperty(exports, "registerTickMethod", {
  enumerable: true,
  get: function get() {
    return _index2.registerTickMethod;
  }
});
var _base = _interopRequireDefault(__webpack_require__(141));
var _base2 = _interopRequireDefault(__webpack_require__(426));
var _time = _interopRequireDefault(__webpack_require__(827));
var _linear = _interopRequireDefault(__webpack_require__(427));
var _log = _interopRequireDefault(__webpack_require__(830));
var _pow = _interopRequireDefault(__webpack_require__(831));
var _time2 = _interopRequireDefault(__webpack_require__(832));
var _quantize = _interopRequireDefault(__webpack_require__(428));
var _quantile = _interopRequireDefault(__webpack_require__(833));
var _factory = __webpack_require__(834);
var _index = _interopRequireDefault(__webpack_require__(835));
var _index2 = __webpack_require__(836);
(0, _factory.registerScale)('cat', _base2.default);
(0, _factory.registerScale)('category', _base2.default);
(0, _factory.registerScale)('identity', _index.default);
(0, _factory.registerScale)('linear', _linear.default);
(0, _factory.registerScale)('log', _log.default);
(0, _factory.registerScale)('pow', _pow.default);
(0, _factory.registerScale)('time', _time2.default);
(0, _factory.registerScale)('timeCat', _time.default);
(0, _factory.registerScale)('quantize', _quantize.default);
(0, _factory.registerScale)('quantile', _quantile.default);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorFallback; });
 __webpack_require__.d(__webpack_exports__, "c", function() { return setDefaultErrorFallback; });
 var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 var react_error_boundary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(620);
 var react_error_boundary__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react_error_boundary__WEBPACK_IMPORTED_MODULE_1__);


var DefaultErrorFallback = function DefaultErrorFallback(_ref) {
  var error = _ref.error;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    className: "bizcharts-error",
    role: "alert"
  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "BizCharts something went wrong:"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("pre", null, error.message));
};
function ErrorFallback(args) {
  return DefaultErrorFallback(args);
}
var setDefaultErrorFallback = function setDefaultErrorFallback(CustComponents) {
  DefaultErrorFallback = CustComponents;
};
 __webpack_exports__["b"] = (react_error_boundary__WEBPACK_IMPORTED_MODULE_1__["ErrorBoundary"]);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var toString = {}.toString;
var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};
var _default = isType;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scrollbar = exports.Slider = exports.HtmlTooltip = exports.ContinuousLegend = exports.CategoryLegend = exports.CircleGrid = exports.LineGrid = exports.CircleAxis = exports.LineAxis = exports.Annotation = exports.Crosshair = exports.Component = exports.GroupComponent = exports.HtmlComponent = exports.Scale = exports.registerScale = exports.getScale = exports.Coordinate = exports.registerCoordinate = exports.getCoordinate = exports.Color = exports.Attribute = exports.getAttribute = exports.Adjust = exports.getAdjust = exports.registerAdjust = exports.AbstractShape = exports.AbstractGroup = exports.Event = void 0;

var g_base_1 = __webpack_require__(26);
Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return g_base_1.Event;
  }
});
Object.defineProperty(exports, "AbstractGroup", {
  enumerable: true,
  get: function get() {
    return g_base_1.AbstractGroup;
  }
});
Object.defineProperty(exports, "AbstractShape", {
  enumerable: true,
  get: function get() {
    return g_base_1.AbstractShape;
  }
});

var adjust_1 = __webpack_require__(422);
Object.defineProperty(exports, "registerAdjust", {
  enumerable: true,
  get: function get() {
    return adjust_1.registerAdjust;
  }
});
Object.defineProperty(exports, "getAdjust", {
  enumerable: true,
  get: function get() {
    return adjust_1.getAdjust;
  }
});
Object.defineProperty(exports, "Adjust", {
  enumerable: true,
  get: function get() {
    return adjust_1.Adjust;
  }
});

var attr_1 = __webpack_require__(251);
Object.defineProperty(exports, "getAttribute", {
  enumerable: true,
  get: function get() {
    return attr_1.getAttribute;
  }
});
Object.defineProperty(exports, "Attribute", {
  enumerable: true,
  get: function get() {
    return attr_1.Attribute;
  }
});
var attr_2 = __webpack_require__(251);
Object.defineProperty(exports, "Color", {
  enumerable: true,
  get: function get() {
    return attr_2.Color;
  }
});

var coord_1 = __webpack_require__(848);
Object.defineProperty(exports, "getCoordinate", {
  enumerable: true,
  get: function get() {
    return coord_1.getCoordinate;
  }
});
Object.defineProperty(exports, "registerCoordinate", {
  enumerable: true,
  get: function get() {
    return coord_1.registerCoordinate;
  }
});
Object.defineProperty(exports, "Coordinate", {
  enumerable: true,
  get: function get() {
    return coord_1.Coordinate;
  }
});

var scale_1 = __webpack_require__(66);
Object.defineProperty(exports, "getScale", {
  enumerable: true,
  get: function get() {
    return scale_1.getScale;
  }
});
Object.defineProperty(exports, "registerScale", {
  enumerable: true,
  get: function get() {
    return scale_1.registerScale;
  }
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return scale_1.Scale;
  }
});

var component_1 = __webpack_require__(179);
Object.defineProperty(exports, "Annotation", {
  enumerable: true,
  get: function get() {
    return component_1.Annotation;
  }
});
Object.defineProperty(exports, "Component", {
  enumerable: true,
  get: function get() {
    return component_1.Component;
  }
});
Object.defineProperty(exports, "Crosshair", {
  enumerable: true,
  get: function get() {
    return component_1.Crosshair;
  }
});
Object.defineProperty(exports, "GroupComponent", {
  enumerable: true,
  get: function get() {
    return component_1.GroupComponent;
  }
});
Object.defineProperty(exports, "HtmlComponent", {
  enumerable: true,
  get: function get() {
    return component_1.HtmlComponent;
  }
});
Object.defineProperty(exports, "Slider", {
  enumerable: true,
  get: function get() {
    return component_1.Slider;
  }
});
Object.defineProperty(exports, "Scrollbar", {
  enumerable: true,
  get: function get() {
    return component_1.Scrollbar;
  }
});

var LineAxis = component_1.Axis.Line,
  CircleAxis = component_1.Axis.Circle;
exports.LineAxis = LineAxis;
exports.CircleAxis = CircleAxis;

var LineGrid = component_1.Grid.Line,
  CircleGrid = component_1.Grid.Circle;
exports.LineGrid = LineGrid;
exports.CircleGrid = CircleGrid;

var CategoryLegend = component_1.Legend.Category,
  ContinuousLegend = component_1.Legend.Continuous;
exports.CategoryLegend = CategoryLegend;
exports.ContinuousLegend = ContinuousLegend;

var HtmlTooltip = component_1.Tooltip.Html;
exports.HtmlTooltip = HtmlTooltip;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uniq = exports.omit = exports.padEnd = exports.isBetween = void 0;
var util_1 = __webpack_require__(0);
function isBetween(value, start, end) {
  var min = Math.min(start, end);
  var max = Math.max(start, end);
  return value >= min && value <= max;
}
exports.isBetween = isBetween;
function padEnd(source, targetLength, padValue) {
  if ((0, util_1.isString)(source)) {
    return source.padEnd(targetLength, padValue);
  } else if ((0, util_1.isArray)(source)) {
    var sourceLength = source.length;
    if (sourceLength < targetLength) {
      var diff = targetLength - sourceLength;
      for (var i = 0; i < diff; i++) {
        source.push(padValue);
      }
    }
  }
  return source;
}
exports.padEnd = padEnd;
function omit(obj, keys) {
  if ((0, _typeof2.default)(obj) === 'object') {
    keys.forEach(function (key) {
      delete obj[key];
    });
  }
  return obj;
}
exports.omit = omit;
function uniq(sourceArray, targetArray, map) {
  if (targetArray === void 0) {
    targetArray = [];
  }
  if (map === void 0) {
    map = new Map();
  }
  for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {
    var source = sourceArray_1[_i];
    if (!map.has(source)) {
      targetArray.push(source);
      map.set(source, true);
    }
  }
  return targetArray;
}
exports.uniq = uniq;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var g_base_1 = __webpack_require__(26);
var util_1 = __webpack_require__(51);
var draw_1 = __webpack_require__(144);
var g_base_2 = __webpack_require__(26);
var Shape = __webpack_require__(143);
var group_1 = __webpack_require__(260);
var ShapeBase = function (_super) {
  tslib_1.__extends(ShapeBase, _super);
  function ShapeBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    
    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  };
  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };
  ShapeBase.prototype.getGroupBase = function () {
    return group_1.default;
  };
    ShapeBase.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };
  ShapeBase.prototype.calculateBBox = function () {
    var type = this.get('type');
    var lineWidth = this.getHitLineWidth();
    
    var bboxMethod = g_base_2.getBBoxMethod(type);
    var box = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box.x - halfLineWidth;
    var minY = box.y - halfLineWidth;
    var maxX = box.x + box.width + halfLineWidth;
    var maxY = box.y + box.height + halfLineWidth;
    return {
      x: minX,
      minX: minX,
      y: minY,
      minY: minY,
      width: box.width + lineWidth,
      height: box.height + lineWidth,
      maxX: maxX,
      maxY: maxY
    };
  };
  ShapeBase.prototype.isFill = function () {
    return !!this.attrs['fill'] || this.isClipShape();
  };
  ShapeBase.prototype.isStroke = function () {
    return !!this.attrs['stroke'];
  };
  
  ShapeBase.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save();
      
      draw_1.applyAttrsToContext(context, clip);
      
      clip.createPath(context);
      context.restore();
      
      context.clip();
      clip._afterDraw();
    }
  };
  
  ShapeBase.prototype.draw = function (context, region) {
    var clip = this.cfg.clipShape;
    
    if (region) {
      if (this.cfg.refresh === false) {
        
        this.set('hasChanged', false);
        return;
      }
      
      var bbox = this.getCanvasBBox();
      if (!util_1.intersectRect(region, bbox)) {
        
        this.set('hasChanged', false);
        
        
        
        if (this.cfg.isInView) {
          this._afterDraw();
        }
        return;
      }
    }
    context.save();
    
    draw_1.applyAttrsToContext(context, this);
    this._applyClip(context, clip);
    this.drawPath(context);
    context.restore();
    this._afterDraw();
  };
  ShapeBase.prototype.getCanvasViewBox = function () {
    var canvas = this.cfg.canvas;
    if (canvas) {
      
      return canvas.getViewRange();
    }
    return null;
  };
  ShapeBase.prototype.cacheCanvasBBox = function () {
    var canvasBBox = this.getCanvasViewBox();
    
    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = util_1.intersectRect(bbox, canvasBBox);
      this.set('isInView', isInView);
      
      
      
      if (isInView) {
        this.set('cacheCanvasBBox', bbox);
      } else {
        this.set('cacheCanvasBBox', null);
      }
    }
  };
  ShapeBase.prototype._afterDraw = function () {
    this.cacheCanvasBBox();
    
    this.set('hasChanged', false);
    this.set('refresh', null);
  };
  ShapeBase.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('isInView', null);
    this.set('hasChanged', false);
  };
    ShapeBase.prototype.drawPath = function (context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
    ShapeBase.prototype.fill = function (context) {
    context.fill();
  };
    ShapeBase.prototype.stroke = function (context) {
    context.stroke();
  };
  
  ShapeBase.prototype.strokeAndFill = function (context) {
    var _a = this.attrs,
      lineWidth = _a.lineWidth,
      opacity = _a.opacity,
      strokeOpacity = _a.strokeOpacity,
      fillOpacity = _a.fillOpacity;
    if (this.isFill()) {
      if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }
        this.stroke(context);
      }
    }
    this.afterDrawPath(context);
  };
    ShapeBase.prototype.createPath = function (context) {};
    ShapeBase.prototype.afterDrawPath = function (context) {};
  ShapeBase.prototype.isInShape = function (refX, refY) {
    
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  };
  
  ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    return false;
  };
    ShapeBase.prototype.getHitLineWidth = function () {
    if (!this.isStroke()) {
      return 0;
    }
    var attrs = this.attrs;
    return attrs['lineWidth'] + attrs['lineAppendWidth'];
  };
  return ShapeBase;
}(g_base_1.AbstractShape);
exports.default = ShapeBase;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moveTo = exports.sortDom = exports.createDom = exports.createSVGElement = void 0;
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(52);
function createSVGElement(type) {
  return document.createElementNS('http://www.w3.org/2000/svg', type);
}
exports.createSVGElement = createSVGElement;
function createDom(shape) {
  var type = constant_1.SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get('id')) {
    element.id = shape.get('id');
  }
  shape.set('el', element);
  shape.set('attrs', {});
  
  if (parent) {
    var parentNode = parent.get('el');
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      
      parentNode = parent.createDom();
      parent.set('el', parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
exports.createDom = createDom;
function sortDom(element, sorter) {
  var el = element.get('el');
  var childList = util_1.toArray(el.children).sort(sorter);
  
  var fragment = document.createDocumentFragment();
  childList.forEach(function (child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
exports.sortDom = sortDom;
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
  
  function (node) {
    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';
  });
  
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  
  if (target) {
    
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      
      
      var targetNext = siblings[targetIndex + 1];
      
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}
exports.moveTo = moveTo;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _gBase = __webpack_require__(26);
var _util = __webpack_require__(53);
var _draw = __webpack_require__(148);
var Shape = _interopRequireWildcard(__webpack_require__(147));
var _group = _interopRequireDefault(__webpack_require__(273));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var ShapeBase = function (_super) {
  (0, _tslib.__extends)(ShapeBase, _super);
  function ShapeBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  };
  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };
  ShapeBase.prototype.getGroupBase = function () {
    return _group.default;
  };
    ShapeBase.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };
  ShapeBase.prototype.calculateBBox = function () {
    var type = this.get('type');
    var lineWidth = this.getHitLineWidth();
    
    var bboxMethod = (0, _gBase.getBBoxMethod)(type);
    var box = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box.x - halfLineWidth;
    var minY = box.y - halfLineWidth;
    var maxX = box.x + box.width + halfLineWidth;
    var maxY = box.y + box.height + halfLineWidth;
    return {
      x: minX,
      minX: minX,
      y: minY,
      minY: minY,
      width: box.width + lineWidth,
      height: box.height + lineWidth,
      maxX: maxX,
      maxY: maxY
    };
  };
  ShapeBase.prototype.isFill = function () {
    return !!this.attrs['fill'] || this.isClipShape();
  };
  ShapeBase.prototype.isStroke = function () {
    return !!this.attrs['stroke'];
  };
  
  ShapeBase.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save();
      
      (0, _draw.applyAttrsToContext)(context, clip);
      
      clip.createPath(context);
      context.restore();
      
      context.clip();
      clip._afterDraw();
    }
  };
  
  ShapeBase.prototype.draw = function (context, region) {
    var clip = this.cfg.clipShape;
    
    if (region) {
      if (this.cfg.refresh === false) {
        
        this.set('hasChanged', false);
        return;
      }
      
      var bbox = this.getCanvasBBox();
      if (!(0, _util.intersectRect)(region, bbox)) {
        
        this.set('hasChanged', false);
        
        
        
        if (this.cfg.isInView) {
          this._afterDraw();
        }
        return;
      }
    }
    context.save();
    
    (0, _draw.applyAttrsToContext)(context, this);
    this._applyClip(context, clip);
    this.drawPath(context);
    context.restore();
    this._afterDraw();
  };
  ShapeBase.prototype.getCanvasViewBox = function () {
    var canvas = this.cfg.canvas;
    if (canvas) {
      
      return canvas.getViewRange();
    }
    return null;
  };
  ShapeBase.prototype.cacheCanvasBBox = function () {
    var canvasBBox = this.getCanvasViewBox();
    
    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = (0, _util.intersectRect)(bbox, canvasBBox);
      this.set('isInView', isInView);
      
      
      
      if (isInView) {
        this.set('cacheCanvasBBox', bbox);
      } else {
        this.set('cacheCanvasBBox', null);
      }
    }
  };
  ShapeBase.prototype._afterDraw = function () {
    this.cacheCanvasBBox();
    
    this.set('hasChanged', false);
    this.set('refresh', null);
  };
  ShapeBase.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('isInView', null);
    this.set('hasChanged', false);
  };
    ShapeBase.prototype.drawPath = function (context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
    ShapeBase.prototype.fill = function (context) {
    context.fill();
  };
    ShapeBase.prototype.stroke = function (context) {
    context.stroke();
  };
  
  ShapeBase.prototype.strokeAndFill = function (context) {
    var _a = this.attrs,
      lineWidth = _a.lineWidth,
      opacity = _a.opacity,
      strokeOpacity = _a.strokeOpacity,
      fillOpacity = _a.fillOpacity;
    if (this.isFill()) {
      if (!(0, _util.isNil)(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!(0, _util.isNil)(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }
        this.stroke(context);
      }
    }
    this.afterDrawPath(context);
  };
    ShapeBase.prototype.createPath = function (context) {};
    ShapeBase.prototype.afterDrawPath = function (context) {};
  ShapeBase.prototype.isInShape = function (refX, refY) {
    
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  };
  
  ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    return false;
  };
    ShapeBase.prototype.getHitLineWidth = function () {
    if (!this.isStroke()) {
      return 0;
    }
    var attrs = this.attrs;
    return attrs['lineWidth'] + attrs['lineAppendWidth'];
  };
  return ShapeBase;
}(_gBase.AbstractShape);
var _default = ShapeBase;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDom = createDom;
exports.createSVGElement = createSVGElement;
exports.moveTo = moveTo;
exports.sortDom = sortDom;
var _util = __webpack_require__(0);
var _constant = __webpack_require__(54);
function createSVGElement(type) {
  return document.createElementNS('http://www.w3.org/2000/svg', type);
}
function createDom(shape) {
  var type = _constant.SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get('id')) {
    element.id = shape.get('id');
  }
  shape.set('el', element);
  shape.set('attrs', {});
  
  if (parent) {
    var parentNode = parent.get('el');
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      
      parentNode = parent.createDom();
      parent.set('el', parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get('el');
  var childList = (0, _util.toArray)(el.children).sort(sorter);
  
  var fragment = document.createDocumentFragment();
  childList.forEach(function (child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
  
  function (node) {
    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';
  });
  
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  
  if (target) {
    
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      
      
      var targetNext = siblings[targetIndex + 1];
      
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
 var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
 var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
 var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2__);



var cloneDeep = function cloneDeep(deepObject) {
  var map = [];
  var clone = function clone(obj) {
    map.push(obj);
    if (map.includes(obj)) {
      return obj;
    }
    if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(obj) !== 'object' || obj === null) {
      return obj;
    }
    var rst;
    if (_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1___default()(obj)) {
      rst = [];
      for (var i = 0, l = obj.length; i < l; i++) {
        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(obj[i]) === 'object' && obj[i] != null) {
          rst[i] = clone(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2___default()(obj, function (value, k) {
        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(value) === 'object' && value != null) {
          rst[k] = clone(value);
        } else {
          rst[k] = value;
        }
      });
    }
    return rst;
  };
  return clone(deepObject);
};
 __webpack_exports__["a"] = (cloneDeep);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "b", function() { return withChartInstance; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);



var RootChartContext = react__WEBPACK_IMPORTED_MODULE_1___default.a.createContext(null);
RootChartContext.displayName = 'RootChartContext';
function withChartInstance(Component) {
  var Com = react__WEBPACK_IMPORTED_MODULE_1___default.a.forwardRef(function (props, ref) {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(RootChartContext.Consumer, null, function (ctx) {
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        ref: ref
      }, ctx, props));
    });
  });
  Com.displayName = Component.name;
  return Com;
}
;
 __webpack_exports__["a"] = (RootChartContext);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var each_1 = __webpack_require__(55);
exports.default = each_1.default;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
 var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);
 var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1__);



var pickWithout = function pickWithout(obj, keys) {
  var ret = {};
  _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0___default()(obj, function (v, k) {
    var match = false;
    keys.forEach(function (itKey) {
      if (_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1___default()(itKey) && itKey === k) {
        match = true;
      } else if (itKey instanceof RegExp && k.match(itKey)) {
        match = true;
      }
    });
    if (!match) {
      ret[k] = v;
    }
  });
  return ret;
};
 __webpack_exports__["a"] = (pickWithout);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;

var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
exports.RANDOM = RANDOM;
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}
var degree = Math.PI / 180;

function toRadian(a) {
  return a * degree;
}

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
    i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toPoints = exports.getRegionBBox = exports.BBox = void 0;
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var BBox = function () {
  function BBox(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
  }
  BBox.fromRange = function (minX, minY, maxX, maxY) {
    return new BBox(minX, minY, maxX - minX, maxY - minY);
  };
  BBox.fromObject = function (bbox) {
    return new BBox(bbox.minX, bbox.minY, bbox.width, bbox.height);
  };
  Object.defineProperty(BBox.prototype, "minX", {
    get: function get() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "maxX", {
    get: function get() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "minY", {
    get: function get() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "maxY", {
    get: function get() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "tl", {
    get: function get() {
      return {
        x: this.x,
        y: this.y
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "tr", {
    get: function get() {
      return {
        x: this.maxX,
        y: this.y
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "bl", {
    get: function get() {
      return {
        x: this.x,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "br", {
    get: function get() {
      return {
        x: this.maxX,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "top", {
    get: function get() {
      return {
        x: this.x + this.width / 2,
        y: this.minY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "right", {
    get: function get() {
      return {
        x: this.maxX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "bottom", {
    get: function get() {
      return {
        x: this.x + this.width / 2,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "left", {
    get: function get() {
      return {
        x: this.minX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  
    BBox.prototype.isEqual = function (bbox) {
    return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
  };
    BBox.prototype.contains = function (child) {
    return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
  };
    BBox.prototype.clone = function () {
    return new BBox(this.x, this.y, this.width, this.height);
  };
    BBox.prototype.add = function () {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    (0, util_1.each)(subBBox, function (b) {
      bbox.x = Math.min(b.x, bbox.x);
      bbox.y = Math.min(b.y, bbox.y);
      bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
    BBox.prototype.merge = function () {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    (0, util_1.each)(subBBox, function (b) {
      bbox.x = Math.max(b.x, bbox.x);
      bbox.y = Math.max(b.y, bbox.y);
      bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
    BBox.prototype.cut = function (subBBox, direction) {
    var width = subBBox.width;
    var height = subBBox.height;
    switch (direction) {
      case constant_1.DIRECTION.TOP:
      case constant_1.DIRECTION.TOP_LEFT:
      case constant_1.DIRECTION.TOP_RIGHT:
        return BBox.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
      case constant_1.DIRECTION.RIGHT:
      case constant_1.DIRECTION.RIGHT_TOP:
      case constant_1.DIRECTION.RIGHT_BOTTOM:
        return BBox.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
      case constant_1.DIRECTION.BOTTOM:
      case constant_1.DIRECTION.BOTTOM_LEFT:
      case constant_1.DIRECTION.BOTTOM_RIGHT:
        return BBox.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
      case constant_1.DIRECTION.LEFT:
      case constant_1.DIRECTION.LEFT_TOP:
      case constant_1.DIRECTION.LEFT_BOTTOM:
        return BBox.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
      default:
        
        return this;
    }
  };
    BBox.prototype.shrink = function (gap) {
    var top = gap[0],
      right = gap[1],
      bottom = gap[2],
      left = gap[3];
    return new BBox(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);
  };
    BBox.prototype.expand = function (gap) {
    var top = gap[0],
      right = gap[1],
      bottom = gap[2],
      left = gap[3];
    return new BBox(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);
  };
    BBox.prototype.exceed = function (bbox) {
    return [Math.max(-this.minY + bbox.minY, 0), Math.max(this.maxX - bbox.maxX, 0), Math.max(this.maxY - bbox.maxY, 0), Math.max(-this.minX + bbox.minX, 0)];
  };
    BBox.prototype.collide = function (bbox) {
    return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
  };
    BBox.prototype.size = function () {
    return this.width * this.height;
  };
    BBox.prototype.isPointIn = function (p) {
    return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
  };
  return BBox;
}();
exports.BBox = BBox;
var getRegionBBox = function getRegionBBox(bbox, region) {
  var start = region.start,
    end = region.end;
  return new BBox(bbox.x + bbox.width * start.x, bbox.y + bbox.height * start.y, bbox.width * Math.abs(end.x - start.x), bbox.height * Math.abs(end.y - start.y));
};
exports.getRegionBBox = getRegionBBox;
function toPoints(bbox) {
  return [[bbox.minX, bbox.minY], [bbox.maxX, bbox.minY], [bbox.maxX, bbox.maxY], [bbox.minX, bbox.maxY]];
}
exports.toPoints = toPoints;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return useChartInstance; });
 var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 var _context_root__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);


function useChartInstance() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(_context_root__WEBPACK_IMPORTED_MODULE_1__[ "a"]).chart;
}
function useChartTheme() {
  
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(_context_root__WEBPACK_IMPORTED_MODULE_1__[ "a"]).theme;
}

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
 var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
 var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
 var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2__);
 var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(61);
 var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3__);




function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  }
  return x !== x && y !== y; 
}

function length(obj) {
  if (_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default()(obj)) {
    return obj.length;
  }
  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3___default()(obj)) {
    return Object.keys(obj).length;
  }
  return 0;
}
 __webpack_exports__["a"] = (function (objA, objB) {
  if (is(objA, objB)) {
    return true;
  }
  if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(objA) !== 'object' || objA === null || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(objB) !== 'object' || objB === null) {
    return false;
  }
  if (_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default()(objA) !== _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default()(objB)) {
    return false;
  }
  if (length(objA) !== length(objB)) {
    return false;
  }
  var ret = true;
  _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1___default()(objA, function (v, k) {
    if (!is(v, objB[k])) {
      ret = false;
      return ret;
    }
    return true;
  });
  return ret;
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bar = void 0;
var tslib_1 = __webpack_require__(1);
var plot_1 = __webpack_require__(24);
var percent_1 = __webpack_require__(119);
var adaptor_1 = __webpack_require__(1120);
var constants_1 = __webpack_require__(1124);
var utils_1 = __webpack_require__(524);
var Bar = function (_super) {
  tslib_1.__extends(Bar, _super);
  function Bar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'bar';
    return _this;
  }
    Bar.getDefaultOptions = function () {
    return constants_1.DEFAULT_OPTIONS;
  };
    Bar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    var xField = options.xField,
      yField = options.yField,
      isPercent = options.isPercent;
    var switchedFieldOptions = tslib_1.__assign(tslib_1.__assign({}, options), {
      xField: yField,
      yField: xField
    });
    adaptor_1.meta({
      chart: chart,
      options: switchedFieldOptions
    });
    chart.changeData(percent_1.getDataWhetherPecentage(utils_1.transformBarData(data), xField, yField, xField, isPercent));
  };
    Bar.prototype.getDefaultOptions = function () {
    return Bar.getDefaultOptions();
  };
    Bar.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  return Bar;
}(plot_1.Plot);
exports.Bar = Bar;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Column = void 0;
var tslib_1 = __webpack_require__(1);
var plot_1 = __webpack_require__(24);
var percent_1 = __webpack_require__(119);
var adaptor_1 = __webpack_require__(195);
var constants_1 = __webpack_require__(1127);
var Column = function (_super) {
  tslib_1.__extends(Column, _super);
  function Column() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'column';
    return _this;
  }
    Column.getDefaultOptions = function () {
    return constants_1.DEFAULT_OPTIONS;
  };
    Column.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
      yField = _a.yField,
      xField = _a.xField,
      isPercent = _a.isPercent;
    var _b = this,
      chart = _b.chart,
      options = _b.options;
    adaptor_1.meta({
      chart: chart,
      options: options
    });
    this.chart.changeData(percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent));
  };
    Column.prototype.getDefaultOptions = function () {
    return Column.getDefaultOptions();
  };
    Column.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  return Column;
}(plot_1.Plot);
exports.Column = Column;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isType = _interopRequireDefault(__webpack_require__(68));
var _default = function _default(str) {
  return (0, _isType.default)(str, 'String');
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isType = _interopRequireDefault(__webpack_require__(68));

var isNumber = function isNumber(value) {
  return (0, _isType.default)(value, 'Number');
};
var _default = isNumber;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distance = distance;
exports.getBBoxByArray = getBBoxByArray;
exports.getBBoxRange = getBBoxRange;
exports.isNumberEqual = isNumberEqual;
exports.piMod = piMod;
function minNum(array) {
  return Math.min.apply(null, array);
}
function maxNum(array) {
  return Math.max.apply(null, array);
}
function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual(v1, v2) {
  return Math.abs(v1 - v2) < 0.001;
}
function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: minNum([x1, x2]),
    maxX: maxNum([x1, x2]),
    minY: minNum([y1, y2]),
    maxY: maxNum([y1, y2])
  };
}
function piMod(angle) {
  return (angle + Math.PI * 2) % (Math.PI * 2);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "catmullRom2Bezier", {
  enumerable: true,
  get: function get() {
    return _catmullRom2Bezier.default;
  }
});
Object.defineProperty(exports, "fillPath", {
  enumerable: true,
  get: function get() {
    return _fillPath.default;
  }
});
Object.defineProperty(exports, "fillPathByDiff", {
  enumerable: true,
  get: function get() {
    return _fillPathByDiff.default;
  }
});
Object.defineProperty(exports, "formatPath", {
  enumerable: true,
  get: function get() {
    return _formatPath.default;
  }
});
Object.defineProperty(exports, "getArcParams", {
  enumerable: true,
  get: function get() {
    return _getArcParams.default;
  }
});
Object.defineProperty(exports, "getLineIntersect", {
  enumerable: true,
  get: function get() {
    return _getLineIntersect.default;
  }
});
Object.defineProperty(exports, "isPointInPolygon", {
  enumerable: true,
  get: function get() {
    return _pointInPolygon.default;
  }
});
Object.defineProperty(exports, "isPolygonsIntersect", {
  enumerable: true,
  get: function get() {
    return _isPolygonsIntersect.default;
  }
});
Object.defineProperty(exports, "parsePath", {
  enumerable: true,
  get: function get() {
    return _parsePath.default;
  }
});
Object.defineProperty(exports, "parsePathArray", {
  enumerable: true,
  get: function get() {
    return _parsePathArray.default;
  }
});
Object.defineProperty(exports, "parsePathString", {
  enumerable: true,
  get: function get() {
    return _parsePathString.default;
  }
});
Object.defineProperty(exports, "path2Absolute", {
  enumerable: true,
  get: function get() {
    return _path2Absolute.default;
  }
});
Object.defineProperty(exports, "path2Curve", {
  enumerable: true,
  get: function get() {
    return _path2Curve.default;
  }
});
Object.defineProperty(exports, "path2Segments", {
  enumerable: true,
  get: function get() {
    return _path2Segments.default;
  }
});
Object.defineProperty(exports, "pathIntersection", {
  enumerable: true,
  get: function get() {
    return _pathIntersection.default;
  }
});
Object.defineProperty(exports, "reactPath", {
  enumerable: true,
  get: function get() {
    return _rectPath.default;
  }
});
var _parsePath = _interopRequireDefault(__webpack_require__(414));
var _catmullRom2Bezier = _interopRequireDefault(__webpack_require__(800));
var _fillPath = _interopRequireDefault(__webpack_require__(803));
var _fillPathByDiff = _interopRequireDefault(__webpack_require__(804));
var _formatPath = _interopRequireDefault(__webpack_require__(805));
var _pathIntersection = _interopRequireDefault(__webpack_require__(806));
var _parsePathArray = _interopRequireDefault(__webpack_require__(811));
var _parsePathString = _interopRequireDefault(__webpack_require__(418));
var _path2Curve = _interopRequireDefault(__webpack_require__(416));
var _path2Absolute = _interopRequireDefault(__webpack_require__(417));
var _rectPath = _interopRequireDefault(__webpack_require__(415));
var _getArcParams = _interopRequireDefault(__webpack_require__(419));
var _path2Segments = _interopRequireDefault(__webpack_require__(812));
var _getLineIntersect = _interopRequireDefault(__webpack_require__(420));
var _isPolygonsIntersect = _interopRequireDefault(__webpack_require__(813));
var _pointInPolygon = _interopRequireDefault(__webpack_require__(421));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = __createBinding;
exports.__decorate = __decorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__read = __read;
exports.__rest = __rest;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));

var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };
  return _extendStatics(d, b);
};
function __extends(d, b) {
  _extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var _assign = function __assign() {
  exports.__assign = _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return _assign.apply(this, arguments);
};
exports.__assign = _assign;
function __rest(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m) {
    if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }
  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }
  return r;
}
;
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
;
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyMatrix2BBox = applyMatrix2BBox;
exports.applyRotate = applyRotate;
exports.applyTranslate = applyTranslate;
exports.getAngleByMatrix = getAngleByMatrix;
exports.getMatrixByAngle = getMatrixByAngle;
exports.getMatrixByTranslate = getMatrixByTranslate;
var _matrixUtil = __webpack_require__(32);
var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point, angle, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }
  if (!angle) {
    
    return null;
  }
  var m = _matrixUtil.ext.transform(matrix, [['t', -point.x, -point.y], ['r', angle], ['t', point.x, point.y]]);
  return m;
}
function getMatrixByTranslate(point, currentMatrix) {
  if (!point.x && !point.y) {
    
    return null;
  }
  return _matrixUtil.ext.transform(currentMatrix || identityMatrix, [['t', point.x, point.y]]);
}

function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];
  _matrixUtil.vec3.transformMat3(out, xVector, matrix);
  return Math.atan2(out[1], out[0]);
}

function multiplyVec2(matrix, v) {
  var out = [0, 0];
  _matrixUtil.vec2.transformMat3(out, v, matrix);
  return out;
}
function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function applyRotate(shape, rotate, x, y) {
  if (rotate) {
    var matrix = getMatrixByAngle({
      x: x,
      y: y
    }, rotate, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}
function applyTranslate(shape, x, y) {
  var translateMatrix = getMatrixByTranslate({
    x: x,
    y: y
  });
  shape.attr('matrix', translateMatrix);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var adjust_1 = __webpack_require__(422);
var attr_1 = __webpack_require__(251);
var util_1 = __webpack_require__(0);
var animate_1 = __webpack_require__(97);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(263));
var constant_1 = __webpack_require__(21);
var helper_1 = __webpack_require__(70);
var element_1 = (0, tslib_1.__importDefault)(__webpack_require__(269));
var label_1 = __webpack_require__(271);
var base_2 = __webpack_require__(27);
var group_data_1 = __webpack_require__(945);
var is_model_change_1 = __webpack_require__(449);
var parse_fields_1 = __webpack_require__(946);
var diff_1 = __webpack_require__(450);
var coordinate_1 = __webpack_require__(48);


function filterLabelsById(id, labelsMap) {
  var labels = [];
  (0, util_1.each)(labelsMap, function (label, labelId) {
    var elementId = labelId.split(' ')[0];
    if (elementId === id) {
      labels.push(label);
    }
  });
  return labels;
}
var Geometry = function (_super) {
  (0, tslib_1.__extends)(Geometry, _super);
    function Geometry(cfg) {
    var _this = _super.call(this, cfg) || this;
        _this.type = 'base';
    
        _this.attributes = {};
        _this.elements = [];
        _this.elementsMap = {};
        _this.animateOption = true;
        _this.attributeOption = {};
        _this.lastElementsMap = {};
        _this.generatePoints = false;
        _this.beforeMappingData = null;
    _this.adjusts = {};
    _this.idFields = [];
    _this.hasSorted = false;
    _this.isCoordinateChanged = false;
    var container = cfg.container,
      labelsContainer = cfg.labelsContainer,
      coordinate = cfg.coordinate,
      data = cfg.data,
      _a = cfg.sortable,
      sortable = _a === void 0 ? false : _a,
      _b = cfg.visible,
      visible = _b === void 0 ? true : _b,
      theme = cfg.theme,
      _c = cfg.scales,
      scales = _c === void 0 ? {} : _c,
      _d = cfg.scaleDefs,
      scaleDefs = _d === void 0 ? {} : _d,
      
      intervalPadding = cfg.intervalPadding,
      dodgePadding = cfg.dodgePadding,
      maxColumnWidth = cfg.maxColumnWidth,
      minColumnWidth = cfg.minColumnWidth,
      columnWidthRatio = cfg.columnWidthRatio,
      roseWidthRatio = cfg.roseWidthRatio,
      multiplePieWidthRatio = cfg.multiplePieWidthRatio,
      zIndexReversed = cfg.zIndexReversed;
    _this.container = container;
    _this.labelsContainer = labelsContainer;
    _this.coordinate = coordinate;
    _this.data = data;
    _this.sortable = sortable;
    _this.visible = visible;
    _this.userTheme = theme;
    _this.scales = scales;
    _this.scaleDefs = scaleDefs;
    
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.roseWidthRatio = roseWidthRatio;
    _this.multiplePieWidthRatio = multiplePieWidthRatio;
    _this.zIndexReversed = zIndexReversed;
    return _this;
  }
    Geometry.prototype.position = function (cfg) {
    var positionCfg = cfg;
    if (!(0, util_1.isPlainObject)(cfg)) {
      
      positionCfg = {
        fields: (0, parse_fields_1.parseFields)(cfg)
      };
    }
    var fields = (0, util_1.get)(positionCfg, 'fields');
    if (fields.length === 1) {
      
      fields.unshift('1');
      (0, util_1.set)(positionCfg, 'fields', fields);
    }
    (0, util_1.set)(this.attributeOption, 'position', positionCfg);
    return this;
  };
  Geometry.prototype.color = function (field, cfg) {
    this.createAttrOption('color', field, cfg);
    return this;
  };
  Geometry.prototype.shape = function (field, cfg) {
    this.createAttrOption('shape', field, cfg);
    return this;
  };
  Geometry.prototype.size = function (field, cfg) {
    this.createAttrOption('size', field, cfg);
    return this;
  };
    Geometry.prototype.adjust = function (adjustCfg) {
    var adjusts = adjustCfg;
    if ((0, util_1.isString)(adjustCfg) || (0, util_1.isPlainObject)(adjustCfg)) {
      adjusts = [adjustCfg];
    }
    (0, util_1.each)(adjusts, function (adjust, index) {
      if (!(0, util_1.isObject)(adjust)) {
        adjusts[index] = {
          type: adjust
        };
      }
    });
    this.adjustOption = adjusts;
    return this;
  };
  Geometry.prototype.style = function (field, styleFunc) {
    if ((0, util_1.isString)(field)) {
      var fields = (0, parse_fields_1.parseFields)(field);
      this.styleOption = {
        fields: fields,
        callback: styleFunc
      };
    } else {
      var _a = field,
        fields = _a.fields,
        callback = _a.callback,
        cfg = _a.cfg;
      if (fields || callback || cfg) {
        this.styleOption = field;
      } else {
        this.styleOption = {
          cfg: field
        };
      }
    }
    return this;
  };
  Geometry.prototype.tooltip = function (field, cfg) {
    if ((0, util_1.isString)(field)) {
      var fields = (0, parse_fields_1.parseFields)(field);
      this.tooltipOption = {
        fields: fields,
        callback: cfg
      };
    } else {
      this.tooltipOption = field;
    }
    return this;
  };
    Geometry.prototype.animate = function (cfg) {
    this.animateOption = cfg;
    return this;
  };
  Geometry.prototype.label = function (field, secondParam, thirdParam) {
    if ((0, util_1.isString)(field)) {
      var labelOption = {};
      var fields = (0, parse_fields_1.parseFields)(field);
      labelOption.fields = fields;
      if ((0, util_1.isFunction)(secondParam)) {
        labelOption.callback = secondParam;
      } else if ((0, util_1.isPlainObject)(secondParam)) {
        labelOption.cfg = secondParam;
      }
      if (thirdParam) {
        labelOption.cfg = thirdParam;
      }
      this.labelOption = labelOption;
    } else {
      this.labelOption = field;
    }
    return this;
  };
    Geometry.prototype.state = function (cfg) {
    this.stateOption = cfg;
    return this;
  };
    Geometry.prototype.customInfo = function (cfg) {
    this.customOption = cfg;
    return this;
  };
    Geometry.prototype.init = function (cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.setCfg(cfg);
    this.initAttributes(); 
    
    this.processData(this.data);
    
    this.adjustScale();
  };
    Geometry.prototype.update = function (cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var data = cfg.data,
      isDataChanged = cfg.isDataChanged,
      isCoordinateChanged = cfg.isCoordinateChanged;
    var _a = this,
      attributeOption = _a.attributeOption,
      lastAttributeOption = _a.lastAttributeOption;
    if (!(0, util_1.isEqual)(attributeOption, lastAttributeOption)) {
      
      this.init(cfg);
    } else if (data && (isDataChanged || !(0, util_1.isEqual)(data, this.data))) {
      
      this.setCfg(cfg);
      this.initAttributes(); 
      this.processData(data); 
    } else {
      
      this.setCfg(cfg);
    }
    
    this.adjustScale();
    this.isCoordinateChanged = isCoordinateChanged;
  };
    Geometry.prototype.paint = function (isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    if (this.animateOption) {
      this.animateOption = (0, util_1.deepMix)({}, (0, animate_1.getDefaultAnimateCfg)(this.type, this.coordinate), this.animateOption);
    }
    this.defaultSize = undefined;
    this.elementsMap = {};
    this.elements = [];
    var offscreenGroup = this.getOffscreenGroup();
    offscreenGroup.clear();
    var beforeMappingData = this.beforeMappingData;
    var dataArray = this.beforeMapping(beforeMappingData);
    this.dataArray = new Array(dataArray.length);
    for (var i = 0; i < dataArray.length; i++) {
      var data = dataArray[i];
      this.dataArray[i] = this.mapping(data);
    }
    this.updateElements(this.dataArray, isUpdate);
    this.lastElementsMap = this.elementsMap;
    if (this.canDoGroupAnimation(isUpdate)) {
      
      var container = this.container;
      var type = this.type;
      var coordinate = this.coordinate;
      var animateCfg = (0, util_1.get)(this.animateOption, 'appear');
      var yScale = this.getYScale();
      var yMinPoint = coordinate.convert({
        x: 0,
        y: yScale.scale(this.getYMinValue())
      });
      (0, animate_1.doGroupAppearAnimate)(container, animateCfg, type, coordinate, yMinPoint);
    }
    
    if (this.labelOption) {
      this.renderLabels((0, util_1.flatten)(this.dataArray), isUpdate);
    }
    
    this.lastAttributeOption = (0, tslib_1.__assign)({}, this.attributeOption);
    if (this.visible === false) {
      
      this.changeVisible(false);
    }
  };
    Geometry.prototype.clear = function () {
    var _a = this,
      container = _a.container,
      geometryLabel = _a.geometryLabel,
      offscreenGroup = _a.offscreenGroup;
    if (container) {
      container.clear();
    }
    if (geometryLabel) {
      geometryLabel.clear();
    }
    if (offscreenGroup) {
      offscreenGroup.clear();
    }
    
    this.scaleDefs = undefined;
    this.attributes = {};
    this.scales = {};
    this.elementsMap = {};
    this.lastElementsMap = {};
    this.elements = [];
    this.adjusts = {};
    this.dataArray = null;
    this.beforeMappingData = null;
    this.lastAttributeOption = undefined;
    this.defaultSize = undefined;
    this.idFields = [];
    this.groupScales = undefined;
    this.hasSorted = false;
    this.isCoordinateChanged = false;
  };
    Geometry.prototype.destroy = function () {
    this.clear();
    var container = this.container;
    container.remove(true);
    if (this.offscreenGroup) {
      this.offscreenGroup.remove(true);
      this.offscreenGroup = null;
    }
    if (this.geometryLabel) {
      this.geometryLabel.destroy();
      this.geometryLabel = null;
    }
    this.theme = undefined;
    this.shapeFactory = undefined;
    _super.prototype.destroy.call(this);
  };
    Geometry.prototype.getGroupScales = function () {
    return this.groupScales;
  };
    Geometry.prototype.getAttribute = function (name) {
    return this.attributes[name];
  };
    Geometry.prototype.getXScale = function () {
    return this.getAttribute('position').scales[0];
  };
    Geometry.prototype.getYScale = function () {
    return this.getAttribute('position').scales[1];
  };
    Geometry.prototype.getGroupAttributes = function () {
    var rst = [];
    (0, util_1.each)(this.attributes, function (attr) {
      if (constant_1.GROUP_ATTRS.includes(attr.type)) {
        rst.push(attr);
      }
    });
    return rst;
  };
    Geometry.prototype.getDefaultValue = function (attrName) {
    var value;
    var attr = this.getAttribute(attrName);
    if (attr && (0, util_1.isEmpty)(attr.scales)) {
      
      value = attr.values[0];
    }
    return value;
  };
    Geometry.prototype.getAttributeValues = function (attr, obj) {
    var params = [];
    var scales = attr.scales;
    for (var index = 0, length_1 = scales.length; index < length_1; index++) {
      var scale = scales[index];
      var field = scale.field;
      if (scale.isIdentity) {
        params.push(scale.values);
      } else {
        params.push(obj[field]);
      }
    }
    return attr.mapping.apply(attr, params);
  };
    Geometry.prototype.getAdjust = function (adjustType) {
    return this.adjusts[adjustType];
  };
    Geometry.prototype.getCoordinate = function () {
    return this.coordinate;
  };
  Geometry.prototype.getData = function () {
    return this.data;
  };
    Geometry.prototype.getShapeMarker = function (shapeName, cfg) {
    var shapeFactory = this.getShapeFactory();
    return shapeFactory.getMarker(shapeName, cfg);
  };
    Geometry.prototype.getElementsBy = function (condition) {
    return this.elements.filter(function (element) {
      return condition(element);
    });
  };
    Geometry.prototype.getElements = function () {
    return this.elements;
  };
    Geometry.prototype.getElementId = function (data) {
    data = (0, util_1.isArray)(data) ? data[0] : data;
    var originData = data[constant_1.FIELD_ORIGIN];
    
    if (this.idFields.length) {
      var elementId = originData[this.idFields[0]];
      for (var index = 1; index < this.idFields.length; index++) {
        elementId += '-' + originData[this.idFields[index]];
      }
      return elementId;
    }
    var type = this.type;
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var xField = xScale.field || 'x';
    var yField = yScale.field || 'y';
    var yVal = originData[yField];
    var xVal;
    if (xScale.type === 'identity') {
      xVal = xScale.values[0];
    } else {
      xVal = originData[xField];
    }
    var id;
    if (type === 'interval' || type === 'schema') {
      id = "" + xVal;
    } else if (type === 'line' || type === 'area' || type === 'path') {
      id = type;
    } else {
      id = xVal + "-" + yVal;
    }
    var groupScales = this.groupScales;
    if ((0, util_1.isEmpty)(groupScales)) {
      groupScales = (0, util_1.get)(this.getAttribute('color'), 'scales', []);
    }
    for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
      var groupScale = groupScales[index];
      var field = groupScale.field;
      id = id + "-" + originData[field];
    }
    // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性
    var dodgeAdjust = this.getAdjust('dodge');
    if (dodgeAdjust) {
      var dodgeBy = dodgeAdjust.dodgeBy;
      if (dodgeBy) {
        id = id + "-" + originData[dodgeBy];
      }
    }
    if (this.getAdjust('jitter')) {
      id = id + "-" + data.x + "-" + data.y;
    }
    return id;
  };
  /**
   * 获取所有需要创建 scale 的字段名称。
   */
  Geometry.prototype.getScaleFields = function () {
    var fields = [];
    var tmpMap = new Map();
    var _a = this,
      attributeOption = _a.attributeOption,
      labelOption = _a.labelOption,
      tooltipOption = _a.tooltipOption;
    // 获取图形属性上的 fields
    for (var attributeType in attributeOption) {
      if (attributeOption.hasOwnProperty(attributeType)) {
        var eachOpt = attributeOption[attributeType];
        if (eachOpt.fields) {
          (0, helper_1.uniq)(eachOpt.fields, fields, tmpMap);
        } else if (eachOpt.values) {
          // 考虑 size(10), shape('circle') 等场景
          (0, helper_1.uniq)(eachOpt.values, fields, tmpMap);
        }
      }
    }
    // 获取 label 上的字段
    if (labelOption && labelOption.fields) {
      (0, helper_1.uniq)(labelOption.fields, fields, tmpMap);
    }
    // 获取 tooltip 上的字段
    if ((0, util_1.isObject)(tooltipOption) && tooltipOption.fields) {
      (0, helper_1.uniq)(tooltipOption.fields, fields, tmpMap);
    }
    return fields;
  };
  /**
   * 显示或者隐藏 geometry。
   * @param visible
   */
  Geometry.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible);
    var elements = this.elements;
    for (var index = 0, length_3 = elements.length; index < length_3; index++) {
      var element = elements[index];
      element.changeVisible(visible);
    }
    if (visible) {
      if (this.container) {
        this.container.show();
      }
      if (this.labelsContainer) {
        this.labelsContainer.show();
      }
    } else {
      if (this.container) {
        this.container.hide();
      }
      if (this.labelsContainer) {
        this.labelsContainer.hide();
      }
    }
  };
  /**
   * 获得所有的字段
   */
  Geometry.prototype.getFields = function () {
    var uniqMap = new Map();
    var fields = [];
    Object.values(this.attributeOption).forEach(function (cfg) {
      var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
      fs.forEach(function (f) {
        if (!uniqMap.has(f)) {
          fields.push(f);
        }
        uniqMap.set(f, true);
      });
    }, []);
    return fields;
  };
  /**
   * 获取当前配置中的所有分组 & 分类的字段。
   * @return fields string[]
   */
  Geometry.prototype.getGroupFields = function () {
    var groupFields = [];
    var tmpMap = new Map(); // 用于去重过滤
    for (var index = 0, length_4 = constant_1.GROUP_ATTRS.length; index < length_4; index++) {
      var attributeName = constant_1.GROUP_ATTRS[index];
      var cfg = this.attributeOption[attributeName];
      if (cfg && cfg.fields) {
        (0, helper_1.uniq)(cfg.fields, groupFields, tmpMap);
      }
    }
    return groupFields;
  };
  /**
   * 获得图形的 x y 字段。
   */
  Geometry.prototype.getXYFields = function () {
    var _a = this.attributeOption.position.fields,
      x = _a[0],
      y = _a[1];
    return [x, y];
  };
  /**
   * x 字段
   * @returns
   */
  Geometry.prototype.getXField = function () {
    return (0, util_1.get)(this.getXYFields(), [0]);
  };
  /**
   * y 字段
   * @returns
   */
  Geometry.prototype.getYField = function () {
    return (0, util_1.get)(this.getXYFields(), [1]);
  };
  /**
   * 获取该 Geometry 下所有生成的 shapes。
   * @returns shapes
   */
  Geometry.prototype.getShapes = function () {
    return this.elements.map(function (element) {
      return element.shape;
    });
  };
  /**
   * 获取虚拟 Group。
   * @returns
   */
  Geometry.prototype.getOffscreenGroup = function () {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  // 对数据进行排序
  Geometry.prototype.sort = function (mappingArray) {
    if (!this.hasSorted) {
      // 未发生过排序
      var xScale_1 = this.getXScale();
      var xField_1 = xScale_1.field;
      for (var index = 0; index < mappingArray.length; index++) {
        var itemArr = mappingArray[index];
        itemArr.sort(function (obj1, obj2) {
          return xScale_1.translate(obj1[constant_1.FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[constant_1.FIELD_ORIGIN][xField_1]);
        });
      }
    }
    this.hasSorted = true;
  };
  /**
   * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。
   */
  Geometry.prototype.adjustScale = function () {
    var yScale = this.getYScale();
    // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围
    if (yScale && this.getAdjust('stack')) {
      this.updateStackRange(yScale, this.beforeMappingData);
    }
  };
  /**
   * 获取当前 Geometry 对应的 Shape 工厂实例。
   */
  Geometry.prototype.getShapeFactory = function () {
    var shapeType = this.shapeType;
    if (!(0, base_2.getShapeFactory)(shapeType)) {
      return;
    }
    if (!this.shapeFactory) {
      this.shapeFactory = (0, util_1.clone)((0, base_2.getShapeFactory)(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改
    }
    // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中
    this.shapeFactory.coordinate = this.coordinate;
    // theme 原因同上
    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
    return this.shapeFactory;
  };
  /**
   * 获取每个 Shape 对应的关键点数据。
   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录
   * @returns
   */
  Geometry.prototype.createShapePointsCfg = function (obj) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var x = this.normalizeValues(obj[xScale.field], xScale);
    var y; // 存在没有 y 的情况
    if (yScale) {
      y = this.normalizeValues(obj[yScale.field], yScale);
    } else {
      y = obj.y ? obj.y : 0.1;
    }
    return {
      x: x,
      y: y,
      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined
    };
  };
  /**
   * 创建 Element 实例。
   * @param mappingDatum Element 对应的绘制数据
   * @param [isUpdate] 是否处于更新阶段
   * @returns element 返回创建的 Element 实例
   */
  Geometry.prototype.createElement = function (mappingDatum, index, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var container = this.container;
    var shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息
    var shapeFactory = this.getShapeFactory();
    var element = new element_1.default({
      shapeFactory: shapeFactory,
      container: container,
      offscreenGroup: this.getOffscreenGroup(),
      elementIndex: index
    });
    element.animate = this.animateOption;
    element.geometry = this;
    element.draw(shapeCfg, isUpdate); // 绘制
    return element;
  };
  /**
   * 获取每条数据对应的图形绘制数据。
   * @param mappingDatum 映射后的数据
   * @returns draw cfg
   */
  Geometry.prototype.getDrawCfg = function (mappingDatum) {
    var originData = mappingDatum[constant_1.FIELD_ORIGIN]; // 原始数据
    var cfg = {
      mappingData: mappingDatum,
      data: originData,
      x: mappingDatum.x,
      y: mappingDatum.y,
      color: mappingDatum.color,
      size: mappingDatum.size,
      isInCircle: this.coordinate.isPolar,
      customInfo: this.customOption
    };
    var shapeName = mappingDatum.shape;
    if (!shapeName && this.getShapeFactory()) {
      shapeName = this.getShapeFactory().defaultShapeType;
    }
    cfg.shape = shapeName;
    // 获取默认样式
    var theme = this.theme.geometries[this.shapeType];
    cfg.defaultStyle = (0, util_1.get)(theme, [shapeName, 'default'], {}).style;
    if (!cfg.defaultStyle && this.getShapeFactory()) {
      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);
    }
    var styleOption = this.styleOption;
    if (styleOption) {
      cfg.style = this.getStyleCfg(styleOption, originData);
    }
    if (this.generatePoints) {
      cfg.points = mappingDatum.points;
      cfg.nextPoints = mappingDatum.nextPoints;
    }
    return cfg;
  };
  Geometry.prototype.updateElements = function (mappingDataArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyDatum = new Map();
    var keys = [];
    // 用来保持 diff 元素之后 added, updated 的相对顺序
    var keyIndex = new Map();
    var index = 0;
    // 获得更新数据所有的 keys
    // 将更新的数据用 key 索引
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      for (var j = 0; j < mappingData.length; j++) {
        var mappingDatum = mappingData[j];
        var key = this.getElementId(mappingDatum);
        var finalKey = keyDatum.has(key) ? key + "-" + i + "-" + j : key;
        keys.push(finalKey);
        keyDatum.set(finalKey, mappingDatum);
        keyIndex.set(finalKey, index);
        index++;
      }
    }
    this.elements = new Array(index);
    var _a = (0, diff_1.diff)(this.lastElementsMap, keys),
      added = _a.added,
      updated = _a.updated,
      removed = _a.removed;
    // 新建 element
    for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
      var key = added_1[_i];
      var mappingDatum = keyDatum.get(key);
      var i = keyIndex.get(key);
      var element = this.createElement(mappingDatum, i, isUpdate);
      this.elements[i] = element;
      this.elementsMap[key] = element;
      if (element.shape) {
        element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
      }
    }
    // 更新 element
    for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
      var key = updated_1[_b];
      var element = this.lastElementsMap[key];
      var mappingDatum = keyDatum.get(key);
      var currentShapeCfg = this.getDrawCfg(mappingDatum);
      var preShapeCfg = element.getModel();
      var i = keyIndex.get(key);
      if (this.isCoordinateChanged || (0, is_model_change_1.isModelChange)(currentShapeCfg, preShapeCfg)) {
        element.animate = this.animateOption;
        // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射
        element.update(currentShapeCfg); // 更新对应的 element
      }

      this.elements[i] = element;
      this.elementsMap[key] = element;
      if (element.shape) {
        element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
      }
    }
    // 销毁被删除的 elements
    for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
      var key = removed_1[_c];
      var element = this.lastElementsMap[key];
      // 更新动画配置，用户有可能在更新之前有对动画进行配置操作
      element.animate = this.animateOption;
      element.destroy();
    }
  };
  /**
   * 获取渲染的 label 类型。
   */
  Geometry.prototype.getLabelType = function () {
    var _a = this,
      labelOption = _a.labelOption,
      coordinate = _a.coordinate,
      type = _a.type;
    var coordinateType = coordinate.type,
      isTransposed = coordinate.isTransposed;
    var labelType = (0, util_1.get)(labelOption, ['cfg', 'type']);
    if (!labelType) {
      // 用户未定义，则进行默认的逻辑
      if (coordinateType === 'polar') {
        // 极坐标下使用通用的极坐标文本，转置则使用饼图
        labelType = isTransposed ? 'pie' : 'polar';
      } else if (coordinateType === 'theta') {
        // theta 坐标系下使用饼图文本
        labelType = 'pie';
      } else if (type === 'interval' || type === 'polygon') {
        labelType = 'interval';
      } else {
        labelType = 'base';
      }
    }
    return labelType;
  };
  /**
   * 获取 Y 轴上的最小值。
   */
  Geometry.prototype.getYMinValue = function () {
    var yScale = this.getYScale();
    var min = yScale.min,
      max = yScale.max;
    var value;
    if (min >= 0) {
      value = min;
    } else if (max <= 0) {
      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0
      value = max;
    } else {
      value = 0;
    }
    return value;
  };
  // 创建图形属性相关的配置项
  Geometry.prototype.createAttrOption = function (attrName, field, cfg) {
    if ((0, util_1.isNil)(field) || (0, util_1.isObject)(field)) {
      if ((0, util_1.isObject)(field) && (0, util_1.isEqual)(Object.keys(field), ['values'])) {
        // shape({ values: [ 'funnel' ] })
        (0, util_1.set)(this.attributeOption, attrName, {
          fields: field.values
        });
      } else {
        (0, util_1.set)(this.attributeOption, attrName, field);
      }
    } else {
      var attrCfg = {};
      if ((0, util_1.isNumber)(field)) {
        // size(3)
        attrCfg.values = [field];
      } else {
        attrCfg.fields = (0, parse_fields_1.parseFields)(field);
      }
      if (cfg) {
        if ((0, util_1.isFunction)(cfg)) {
          attrCfg.callback = cfg;
        } else {
          attrCfg.values = cfg;
        }
      }
      (0, util_1.set)(this.attributeOption, attrName, attrCfg);
    }
  };
  Geometry.prototype.initAttributes = function () {
    var _this = this;
    var _a = this,
      attributes = _a.attributes,
      attributeOption = _a.attributeOption,
      theme = _a.theme,
      shapeType = _a.shapeType;
    this.groupScales = [];
    var tmpMap = {};
    var _loop_1 = function _loop_1(attrType) {
      if (attributeOption.hasOwnProperty(attrType)) {
        var option = attributeOption[attrType];
        if (!option) {
          return {
            value: void 0
          };
        }
        var attrCfg = (0, tslib_1.__assign)({}, option);
        var callback = attrCfg.callback,
          values = attrCfg.values,
          _b = attrCfg.fields,
          fields = _b === void 0 ? [] : _b;
        // 获取每一个字段对应的 scale
        var scales = fields.map(function (field) {
          var scale = _this.scales[field];
          if (scale.isCategory && !tmpMap[field] && constant_1.GROUP_ATTRS.includes(attrType)) {
            _this.groupScales.push(scale);
            tmpMap[field] = true;
          }
          return scale;
        });
        attrCfg.scales = scales;
        if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {
          // 用户在图形通道上声明了常量字段 color('red'), size(5)
          attrCfg.values = scales[0].values;
        } else if (!callback && !values) {
          // 用户没有指定任何规则，则使用默认的映射规则
          if (attrType === 'size') {
            attrCfg.values = theme.sizes;
          } else if (attrType === 'shape') {
            attrCfg.values = theme.shapes[shapeType] || [];
          } else if (attrType === 'color') {
            if (scales.length) {
              // 根据数值个数使用对应的色板
              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;
            } else {
              attrCfg.values = theme.colors10;
            }
          }
        }
        var AttributeCtor = (0, attr_1.getAttribute)(attrType);
        attributes[attrType] = new AttributeCtor(attrCfg);
      }
    };
    // 遍历每一个 attrOption，各自创建 Attribute 实例
    for (var attrType in attributeOption) {
      var state_1 = _loop_1(attrType);
      if ((0, _typeof2.default)(state_1) === "object") return state_1.value;
    }
  };
  
  Geometry.prototype.processData = function (data) {
    this.hasSorted = false;
    var scales = this.getAttribute('position').scales;
    var categoryScales = scales.filter(function (scale) {
      return scale.isCategory;
    });
    var groupedArray = this.groupData(data); 
    var beforeAdjust = [];
    for (var i = 0, len = groupedArray.length; i < len; i++) {
      var subData = groupedArray[i];
      var arr = [];
      for (var j = 0, subLen = subData.length; j < subLen; j++) {
        var originData = subData[j];
        var item = {};
        
        for (var k in originData) {
          item[k] = originData[k];
        }
        item[constant_1.FIELD_ORIGIN] = originData;
        
        for (var _i = 0, categoryScales_1 = categoryScales; _i < categoryScales_1.length; _i++) {
          var scale = categoryScales_1[_i];
          var field = scale.field;
          item[field] = scale.translate(item[field]);
        }
        arr.push(item);
      }
      beforeAdjust.push(arr);
    }
    var dataArray = this.adjustData(beforeAdjust); 
    this.beforeMappingData = dataArray;
    return dataArray;
  };
  
  Geometry.prototype.adjustData = function (dataArray) {
    var adjustOption = this.adjustOption;
    var _a = this,
      intervalPadding = _a.intervalPadding,
      dodgePadding = _a.dodgePadding,
      theme = _a.theme;
    
    var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;
    var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;
    var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;
    var result = dataArray;
    if (adjustOption) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field;
      var yField = yScale ? yScale.field : null;
      var xDimensionLength = (0, coordinate_1.getXDimensionLength)(this.coordinate);
      var groupNum = xScale.values.length;
      
      var sizeAttr = this.getAttribute('size');
      var defaultSize = void 0;
      if (sizeAttr) {
        defaultSize = sizeAttr.values[0];
      }
      for (var i = 0, len = adjustOption.length; i < len; i++) {
        var adjust = adjustOption[i];
        var adjustCfg = (0, tslib_1.__assign)({
          xField: xField,
          yField: yField,
          intervalPadding: intervalPadding,
          dodgePadding: dodgePadding,
          xDimensionLength: xDimensionLength,
          groupNum: groupNum,
          defaultSize: defaultSize,
          maxColumnWidth: maxColumnWidth,
          minColumnWidth: minColumnWidth,
          columnWidthRatio: columnWidthRatio
        }, adjust);
        var type = adjust.type;
        if (type === 'dodge') {
          var adjustNames = [];
          if (xScale.isCategory || xScale.type === 'identity') {
            adjustNames.push('x');
          } else if (!yScale) {
            adjustNames.push('y');
          } else {
            throw new Error('dodge is not support linear attribute, please use category attribute!');
          }
          adjustCfg.adjustNames = adjustNames;
          
          
          adjustCfg.dodgeRatio = columnWidthRatio;
        } else if (type === 'stack') {
          var coordinate = this.coordinate;
          if (!yScale) {
            
            adjustCfg.height = coordinate.getHeight();
            var size = this.getDefaultValue('size') || 3;
            adjustCfg.size = size;
          }
          
          if (!coordinate.isTransposed && (0, util_1.isNil)(adjustCfg.reverseOrder)) {
            adjustCfg.reverseOrder = true;
          }
        }
        var adjustCtor = (0, adjust_1.getAdjust)(type);
        var adjustInstance = new adjustCtor(adjustCfg);
        result = adjustInstance.process(result);
        this.adjusts[type] = adjustInstance;
      }
    }
    return result;
  };
  
  Geometry.prototype.groupData = function (data) {
    var groupScales = this.getGroupScales();
    var scaleDefs = this.scaleDefs;
    var appendConditions = {};
    var groupFields = [];
    for (var index = 0; index < groupScales.length; index++) {
      var scale = groupScales[index];
      var field = scale.field;
      groupFields.push(field);
      if ((0, util_1.get)(scaleDefs, [field, 'values'])) {
        
        appendConditions[field] = scaleDefs[field].values;
      }
    }
    return (0, group_data_1.group)(data, groupFields, appendConditions);
  };
  
  Geometry.prototype.updateStackRange = function (scale, dataArray) {
    var mergeArray = (0, util_1.flatten)(dataArray);
    var field = scale.field;
    var min = scale.min;
    var max = scale.max;
    for (var index = 0; index < mergeArray.length; index++) {
      var obj = mergeArray[index];
      var tmpMin = Math.min.apply(null, obj[field]);
      var tmpMax = Math.max.apply(null, obj[field]);
      if (tmpMin < min) {
        min = tmpMin;
      }
      if (tmpMax > max) {
        max = tmpMax;
      }
    }
    var scaleDefs = this.scaleDefs;
    var cfg = {};
    if (min < scale.min && !(0, util_1.get)(scaleDefs, [field, 'min'])) {
      
      cfg.min = min;
    }
    if (max > scale.max && !(0, util_1.get)(scaleDefs, [field, 'max'])) {
      
      cfg.max = max;
    }
    scale.change(cfg);
  };
  
  Geometry.prototype.beforeMapping = function (beforeMappingData) {
    
    
    var source = beforeMappingData;
    if (this.sortable) {
      this.sort(source);
    }
    if (this.generatePoints) {
      
      for (var index = 0, length_5 = source.length; index < length_5; index++) {
        var currentData = source[index];
        this.generateShapePoints(currentData);
        var nextData = source[index + 1];
        if (nextData) {
          this.generateShapePoints(nextData);
          currentData[0].nextPoints = nextData[0].points;
        }
      }
    }
    return source;
  };
  
  Geometry.prototype.generateShapePoints = function (data) {
    var shapeFactory = this.getShapeFactory();
    var shapeAttr = this.getAttribute('shape');
    for (var index = 0; index < data.length; index++) {
      var obj = data[index];
      var cfg = this.createShapePointsCfg(obj);
      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
      var points = shapeFactory.getShapePoints(shape, cfg);
      obj.points = points;
    }
  };
  
  Geometry.prototype.normalizeValues = function (values, scale) {
    var rst = [];
    if ((0, util_1.isArray)(values)) {
      for (var index = 0; index < values.length; index++) {
        var value = values[index];
        rst.push(scale.scale(value));
      }
    } else {
      rst = scale.scale(values);
    }
    return rst;
  };
  
  Geometry.prototype.mapping = function (data) {
    var attributes = this.attributes;
    var mappingData = [];
    for (var index = 0; index < data.length; index++) {
      var record = data[index];
      var newRecord = {
        _origin: record[constant_1.FIELD_ORIGIN],
        points: record.points,
        nextPoints: record.nextPoints
      };
      for (var k in attributes) {
        if (attributes.hasOwnProperty(k)) {
          var attr = attributes[k];
          var names = attr.names;
          var values = this.getAttributeValues(attr, record);
          if (names.length > 1) {
            
            for (var j = 0; j < values.length; j += 1) {
              var val = values[j];
              var name_1 = names[j];
              newRecord[name_1] = (0, util_1.isArray)(val) && val.length === 1 ? val[0] : val; 
            }
          } else {
            
            
            newRecord[names[0]] = values.length === 1 ? values[0] : values;
          }
        }
      }
      this.convertPoint(newRecord); 
      mappingData.push(newRecord);
    }
    return mappingData;
  };
  
  Geometry.prototype.convertPoint = function (mappingRecord) {
    var x = mappingRecord.x,
      y = mappingRecord.y;
    var rstX;
    var rstY;
    var obj;
    var coordinate = this.coordinate;
    if ((0, util_1.isArray)(x) && (0, util_1.isArray)(y)) {
      rstX = [];
      rstY = [];
      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
        obj = coordinate.convert({
          x: x[i],
          y: y[j]
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if ((0, util_1.isArray)(y)) {
      rstY = [];
      for (var index = 0; index < y.length; index++) {
        var yVal = y[index];
        obj = coordinate.convert({
          x: x,
          y: yVal
        });
        if (rstX && rstX !== obj.x) {
          if (!(0, util_1.isArray)(rstX)) {
            rstX = [rstX];
          }
          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }
        rstY.push(obj.y);
      }
    } else if ((0, util_1.isArray)(x)) {
      rstX = [];
      for (var index = 0; index < x.length; index++) {
        var xVal = x[index];
        obj = coordinate.convert({
          x: xVal,
          y: y
        });
        if (rstY && rstY !== obj.y) {
          if (!(0, util_1.isArray)(rstY)) {
            rstY = [rstY];
          }
          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }
        rstX.push(obj.x);
      }
    } else {
      var point = coordinate.convert({
        x: x,
        y: y
      });
      rstX = point.x;
      rstY = point.y;
    }
    mappingRecord.x = rstX;
    mappingRecord.y = rstY;
  };
  
  Geometry.prototype.getStyleCfg = function (styleOption, originData) {
    var _a = styleOption.fields,
      fields = _a === void 0 ? [] : _a,
      callback = styleOption.callback,
      cfg = styleOption.cfg;
    if (cfg) {
      
      return cfg;
    }
    var params = fields.map(function (field) {
      return originData[field];
    });
    return callback.apply(void 0, params);
  };
  Geometry.prototype.setCfg = function (cfg) {
    var _this = this;
    var coordinate = cfg.coordinate,
      data = cfg.data,
      theme = cfg.theme,
      scaleDefs = cfg.scaleDefs;
    if (coordinate) {
      this.coordinate = coordinate;
    }
    if (data) {
      this.data = data;
    }
    if (scaleDefs) {
      this.scaleDefs = scaleDefs;
      this.idFields = [];
      (0, util_1.each)(scaleDefs, function (scaleDef, field) {
        if (scaleDef && scaleDef.key) {
          _this.idFields.push(field);
        }
      });
    }
    if (theme) {
      this.theme = this.userTheme ? (0, util_1.deepMix)({}, theme, this.userTheme) : theme; 
    }
  };

  Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var geometryLabel = this.geometryLabel;
    if (!geometryLabel) {
      
      var labelType = this.getLabelType();
      var GeometryLabelsCtor = (0, label_1.getGeometryLabel)(labelType);
      geometryLabel = new GeometryLabelsCtor(this);
      this.geometryLabel = geometryLabel;
    }
    geometryLabel.render(mappingArray, isUpdate);
    
    var labelsMap = geometryLabel.labelsRenderer.shapesMap;
    (0, util_1.each)(this.elementsMap, function (element, id) {
      var labels = filterLabelsById(id, labelsMap); 
      if (labels.length) {
        element.labelShape = labels;
        for (var i = 0; i < labels.length; i++) {
          var label = labels[i];
          var labelChildren = label.getChildren();
          for (var j = 0; j < labelChildren.length; j++) {
            var child = labelChildren[j];
            child.cfg.name = ['element', 'label'];
            child.cfg.element = element;
          }
        }
      }
    });
  };
    Geometry.prototype.canDoGroupAnimation = function (isUpdate) {
    return !isUpdate && this.animateOption && ((0, util_1.get)(this.animateOption, 'appear') === undefined || (0, util_1.get)(this.animateOption, 'appear') && (0, util_1.get)(this.animateOption, ['appear', 'animation']) === undefined);
  };
  return Geometry;
}(base_1.default);
exports.default = Geometry;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerTheme = exports.getTheme = void 0;
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(446);
var defaultTheme = (0, util_2.createTheme)({});

var Themes = {
  default: defaultTheme
};
function getTheme(theme) {
  return (0, util_1.get)(Themes, (0, util_1.lowerCase)(theme), Themes.default);
}
exports.getTheme = getTheme;
function registerTheme(theme, value) {
  Themes[(0, util_1.lowerCase)(theme)] = (0, util_2.createTheme)(value);
}
exports.registerTheme = registerTheme;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var map = {};
exports.default = function (prefix) {
  prefix = prefix || 'g';
  if (!map[prefix]) {
    map[prefix] = 1;
  } else {
    map[prefix] += 1;
  }
  return prefix + map[prefix];
};

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return REACT_PIVATE_PROPS; });
var REACT_PIVATE_PROPS = ['children', 'hooks', 'ref'];
 var _unused_webpack_default_export = ({});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isNil = function isNil(value) {
    return value === null || value === undefined;
};
var _default = isNil;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "addEventListener", {
  enumerable: true,
  get: function get() {
    return _addEventListener.default;
  }
});
Object.defineProperty(exports, "createDom", {
  enumerable: true,
  get: function get() {
    return _createDom.default;
  }
});
Object.defineProperty(exports, "getHeight", {
  enumerable: true,
  get: function get() {
    return _getHeight.default;
  }
});
Object.defineProperty(exports, "getOuterHeight", {
  enumerable: true,
  get: function get() {
    return _getOuterHeight.default;
  }
});
Object.defineProperty(exports, "getOuterWidth", {
  enumerable: true,
  get: function get() {
    return _getOuterWidth.default;
  }
});
Object.defineProperty(exports, "getRatio", {
  enumerable: true,
  get: function get() {
    return _getRatio.default;
  }
});
Object.defineProperty(exports, "getStyle", {
  enumerable: true,
  get: function get() {
    return _getStyle.default;
  }
});
Object.defineProperty(exports, "getWidth", {
  enumerable: true,
  get: function get() {
    return _getWidth.default;
  }
});
Object.defineProperty(exports, "modifyCSS", {
  enumerable: true,
  get: function get() {
    return _modifyCss.default;
  }
});
var _addEventListener = _interopRequireDefault(__webpack_require__(736));
var _createDom = _interopRequireDefault(__webpack_require__(737));
var _getHeight = _interopRequireDefault(__webpack_require__(387));
var _getOuterHeight = _interopRequireDefault(__webpack_require__(738));
var _getOuterWidth = _interopRequireDefault(__webpack_require__(739));
var _getRatio = _interopRequireDefault(__webpack_require__(740));
var _getStyle = _interopRequireDefault(__webpack_require__(139));
var _getWidth = _interopRequireDefault(__webpack_require__(388));
var _modifyCss = _interopRequireDefault(__webpack_require__(741));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doGroupAppearAnimate = exports.doAnimate = exports.getDefaultAnimateCfg = exports.DEFAULT_ANIMATE_CFG = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var animation_1 = __webpack_require__(436);

exports.DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: 'easeQuadOut'
  },
  update: {
    duration: 400,
    easing: 'easeQuadInOut'
  },
  enter: {
    duration: 400,
    easing: 'easeQuadInOut'
  },
  leave: {
    duration: 350,
    easing: 'easeQuadIn'
  } 
};

var GEOMETRY_ANIMATE_CFG = {
  interval: function interval(coordinate) {
    return {
      enter: {
        animation: coordinate.isRect ? coordinate.isTransposed ? 'scale-in-x' : 'scale-in-y' : 'fade-in'
      },
      update: {
        animation: coordinate.isPolar && coordinate.isTransposed ? 'sector-path-update' : null
      },
      leave: {
        animation: 'fade-out'
      }
    };
  },
  line: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  path: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  point: {
    appear: {
      animation: 'zoom-in'
    },
    enter: {
      animation: 'zoom-in'
    },
    leave: {
      animation: 'zoom-out'
    }
  },
  area: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  polygon: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  schema: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  edge: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  label: {
    appear: {
      animation: 'fade-in',
      delay: 450
    },
    enter: {
      animation: 'fade-in'
    },
    update: {
      animation: 'position-update'
    },
    leave: {
      animation: 'fade-out'
    }
  }
};

var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function line() {
    return {
      animation: 'wave-in'
    };
  },
  area: function area() {
    return {
      animation: 'wave-in'
    };
  },
  path: function path() {
    return {
      animation: 'fade-in'
    };
  },
  interval: function interval(coordinate) {
    var animation;
    if (coordinate.isRect) {
      animation = coordinate.isTransposed ? 'grow-in-x' : 'grow-in-y';
    } else {
      animation = 'grow-in-xy';
      if (coordinate.isPolar && coordinate.isTransposed) {
        
        animation = 'wave-in';
      }
    }
    return {
      animation: animation
    };
  },
  schema: function schema(coordinate) {
    var animation;
    if (coordinate.isRect) {
      animation = coordinate.isTransposed ? 'grow-in-x' : 'grow-in-y';
    } else {
      animation = 'grow-in-xy';
    }
    return {
      animation: animation
    };
  },
  polygon: function polygon() {
    return {
      animation: 'fade-in',
      duration: 500
    };
  },
  edge: function edge() {
    return {
      animation: 'fade-in'
    };
  }
};

function parseAnimateConfig(animateCfg, data) {
  return {
    delay: (0, util_1.isFunction)(animateCfg.delay) ? animateCfg.delay(data) : animateCfg.delay,
    easing: (0, util_1.isFunction)(animateCfg.easing) ? animateCfg.easing(data) : animateCfg.easing,
    duration: (0, util_1.isFunction)(animateCfg.duration) ? animateCfg.duration(data) : animateCfg.duration,
    callback: animateCfg.callback,
    repeat: animateCfg.repeat
  };
}
function getDefaultAnimateCfg(elementName, coordinate, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
  if (animateCfg) {
    if ((0, util_1.isFunction)(animateCfg)) {
      animateCfg = animateCfg(coordinate);
    }
    animateCfg = (0, util_1.deepMix)({}, exports.DEFAULT_ANIMATE_CFG, animateCfg);
    if (animateType) {
      return animateCfg[animateType];
    }
  }
  return animateCfg;
}
exports.getDefaultAnimateCfg = getDefaultAnimateCfg;
function doAnimate(shape, animateCfg, cfg) {
  var data = (0, util_1.get)(shape.get('origin'), 'data', constant_1.FIELD_ORIGIN);
  var animation = animateCfg.animation; 
  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data);
  if (animation) {
    
    var animateFunction = (0, animation_1.getAnimation)(animation);
    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}
exports.doAnimate = doAnimate;
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate);
    var animation = (0, animation_1.getAnimation)((0, util_1.get)(defaultCfg, 'animation', ''));
    if (animation) {
      var cfg = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, exports.DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
      container.stopAnimate(); // 先结束当前 container 动画
      animation(container, cfg, {
        coordinate: coordinate,
        minYPoint: minYPoint,
        toAttrs: null
      });
    }
  }
}
exports.doGroupAppearAnimate = doGroupAppearAnimate;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerComponentController = exports.Event = exports.registerGeometry = exports.View = exports.Chart = void 0;
var chart_1 = __webpack_require__(935);
Object.defineProperty(exports, "Chart", {
  enumerable: true,
  get: function get() {
    return __importDefault(chart_1).default;
  }
});
var view_1 = __webpack_require__(444);
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function get() {
    return __importDefault(view_1).default;
  }
});
Object.defineProperty(exports, "registerGeometry", {
  enumerable: true,
  get: function get() {
    return view_1.registerGeometry;
  }
});
var event_1 = __webpack_require__(268);
Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return __importDefault(event_1).default;
  }
});
var controller_1 = __webpack_require__(447);
Object.defineProperty(exports, "registerComponentController", {
  enumerable: true,
  get: function get() {
    return controller_1.registerComponentController;
  }
});

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AXIS_META_CONFIG_KEYS = void 0;
/**
 * 需要从轴配置中提取出来作为 meta 的属性 key 列表
 */
var AXIS_META_CONFIG_KEYS = ['type', 'alias', 'tickCount', 'tickInterval', 'min', 'max', 'nice', 'minLimit', 'maxLimit',

'range', 'tickMethod',

'base',

'exponent',

'mask',

'sync'];
exports.AXIS_META_CONFIG_KEYS = AXIS_META_CONFIG_KEYS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var animate_1 = __webpack_require__(97);
var graphics_1 = __webpack_require__(46);
var labels_1 = (0, tslib_1.__importDefault)(__webpack_require__(947));
function avg(arr) {
  var sum = 0;
  (0, util_1.each)(arr, function (value) {
    sum += value;
  });
  return sum / arr.length;
}
var GeometryLabel = function () {
  function GeometryLabel(geometry) {
    this.geometry = geometry;
  }
  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {
    var _this = this;
    var items = [];
    var labelCfgs = this.getLabelCfgs(mapppingArray);
    
    (0, util_1.each)(mapppingArray, function (mappingData, index) {
      var labelCfg = labelCfgs[index];
      if (!labelCfg || (0, util_1.isNil)(mappingData.x) || (0, util_1.isNil)(mappingData.y)) {
        items.push(null);
        return;
      }
      var labelContent = !(0, util_1.isArray)(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
      labelCfg.content = labelContent;
      var total = labelContent.length;
      (0, util_1.each)(labelContent, function (content, subIndex) {
        if ((0, util_1.isNil)(content) || content === '') {
          items.push(null);
          return;
        }
        var item = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
        if (!item.textAlign) {
          item.textAlign = _this.getLabelAlign(item, subIndex, total);
        }
        if (item.offset <= 0) {
          item.labelLine = null;
        }
        items.push(item);
      });
    });
    return items;
  };
  GeometryLabel.prototype.render = function (mapppingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var labelItems = this.getLabelItems(mapppingArray);
    var labelsRenderer = this.getLabelsRenderer();
    var shapes = this.getGeometryShapes();
    // 渲染文本
    labelsRenderer.render(labelItems, shapes, isUpdate);
  };
  GeometryLabel.prototype.clear = function () {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.clear();
    }
  };
  GeometryLabel.prototype.destroy = function () {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.destroy();
    }
    this.labelsRenderer = null;
  };
  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取
  GeometryLabel.prototype.getCoordinate = function () {
    return this.geometry.coordinate;
  };
  /**
   * 获取 label 的默认配置
   */
  GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {
    var geometry = this.geometry;
    var type = geometry.type,
      theme = geometry.theme;
    if (type === 'polygon' || type === 'interval' && position === 'middle' || offset < 0 && !['line', 'point', 'path'].includes(type)) {
      
      return (0, util_1.get)(theme, 'innerLabels', {});
    }
    return (0, util_1.get)(theme, 'labels', {});
  };
    GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {
    var geometry = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var type = geometry.type,
      theme = geometry.theme;
    var themedLabelCfg;
    if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {
      
      themedLabelCfg = (0, util_1.deepMix)({}, defaultLabelCfg, theme.innerLabels, labelCfg);
    } else {
      themedLabelCfg = (0, util_1.deepMix)({}, defaultLabelCfg, theme.labels, labelCfg);
    }
    return themedLabelCfg;
  };
    GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};
    GeometryLabel.prototype.getLabelOffset = function (offset) {
    var coordinate = this.getCoordinate();
    var vector = this.getOffsetVector(offset);
    return coordinate.isTransposed ? vector[0] : vector[1];
  };
    GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {
    var offset = labelCfg.offset;
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var dim = transposed ? 'x' : 'y';
    var factor = transposed ? 1 : -1; 
    var offsetPoint = {
      x: 0,
      y: 0
    };
    if (index > 0 || total === 1) {
      
      offsetPoint[dim] = offset * factor;
    } else {
      offsetPoint[dim] = offset * factor * -1;
    }
    return offsetPoint;
  };
    GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
    var coordinate = this.getCoordinate();
    var total = labelCfg.content.length;
    function getDimValue(value, idx, isAvg) {
      if (isAvg === void 0) {
        isAvg = false;
      }
      var v = value;
      if ((0, util_1.isArray)(v)) {
        if (labelCfg.content.length === 1) {
          if (isAvg) {
            v = avg(v);
          } else {
            
            if (v.length <= 2) {
              v = v[value.length - 1];
            } else {
              v = avg(v);
            }
          }
        } else {
          v = v[idx];
        }
      }
      return v;
    }
    var label = {
      content: labelCfg.content[index],
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      color: '#fff'
    };
    var shape = (0, util_1.isArray)(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    var isFunnel = shape === 'funnel' || shape === 'pyramid';
    
    if (this.geometry.type === 'polygon') {
      var centroid = (0, graphics_1.getPolygonCentroid)(mappingData.x, mappingData.y);
      label.x = centroid[0];
      label.y = centroid[1];
    } else if (this.geometry.type === 'interval' && !isFunnel) {
      
      label.x = getDimValue(mappingData.x, index, true);
      label.y = getDimValue(mappingData.y, index);
    } else {
      label.x = getDimValue(mappingData.x, index);
      label.y = getDimValue(mappingData.y, index);
    }
    
    if (isFunnel) {
      var nextPoints = (0, util_1.get)(mappingData, 'nextPoints');
      var points = (0, util_1.get)(mappingData, 'points');
      if (nextPoints) {
        
        var point1 = coordinate.convert(points[1]);
        var point2 = coordinate.convert(nextPoints[1]);
        label.x = (point1.x + point2.x) / 2;
        label.y = (point1.y + point2.y) / 2;
      } else if (shape === 'pyramid') {
        var point1 = coordinate.convert(points[1]);
        var point2 = coordinate.convert(points[2]);
        label.x = (point1.x + point2.x) / 2;
        label.y = (point1.y + point2.y) / 2;
      }
    }
    if (labelCfg.position) {
      
      this.setLabelPosition(label, mappingData, index, labelCfg.position);
    }
    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
    label.start = {
      x: label.x,
      y: label.y
    };
    label.x += offsetPoint.x;
    label.y += offsetPoint.y;
    label.color = mappingData.color;
    return label;
  };
    GeometryLabel.prototype.getLabelAlign = function (item, index, total) {
    var align = 'center';
    var coordinate = this.getCoordinate();
    if (coordinate.isTransposed) {
      var offset = item.offset;
      if (offset < 0) {
        align = 'right';
      } else if (offset === 0) {
        align = 'center';
      } else {
        align = 'left';
      }
      if (total > 1 && index === 0) {
        if (align === 'right') {
          align = 'left';
        } else if (align === 'left') {
          align = 'right';
        }
      }
    }
    return align;
  };
    GeometryLabel.prototype.getLabelId = function (mappingData) {
    var geometry = this.geometry;
    var type = geometry.type;
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    var origin = mappingData[constant_1.FIELD_ORIGIN]; 
    var labelId = geometry.getElementId(mappingData);
    if (type === 'line' || type === 'area') {
      
      labelId += " " + origin[xScale.field];
    } else if (type === 'path') {
      
      labelId += " " + origin[xScale.field] + "-" + origin[yScale.field];
    }
    return labelId;
  };
  
  GeometryLabel.prototype.getLabelsRenderer = function () {
    var _a = this.geometry,
      labelsContainer = _a.labelsContainer,
      labelOption = _a.labelOption,
      canvasRegion = _a.canvasRegion,
      animateOption = _a.animateOption;
    var coordinate = this.geometry.coordinate;
    var labelsRenderer = this.labelsRenderer;
    if (!labelsRenderer) {
      labelsRenderer = new labels_1.default({
        container: labelsContainer,
        layout: (0, util_1.get)(labelOption, ['cfg', 'layout'], {
          type: this.defaultLayout
        })
      });
      this.labelsRenderer = labelsRenderer;
    }
    labelsRenderer.region = canvasRegion;
    
    labelsRenderer.animate = animateOption ? (0, animate_1.getDefaultAnimateCfg)('label', coordinate) : false;
    return labelsRenderer;
  };
  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {
    var _this = this;
    var geometry = this.geometry;
    var labelOption = geometry.labelOption,
      scales = geometry.scales,
      coordinate = geometry.coordinate;
    var _a = labelOption,
      fields = _a.fields,
      callback = _a.callback,
      cfg = _a.cfg;
    var labelScales = fields.map(function (field) {
      return scales[field];
    });
    var labelCfgs = [];
    (0, util_1.each)(mapppingArray, function (mappingData, index) {
      var origin = mappingData[constant_1.FIELD_ORIGIN]; 
      var originText = _this.getLabelText(origin, labelScales);
      var callbackCfg;
      if (callback) {
        
        var originValues = fields.map(function (field) {
          return origin[field];
        });
        callbackCfg = callback.apply(void 0, originValues);
        if ((0, util_1.isNil)(callbackCfg)) {
          labelCfgs.push(null);
          return;
        }
      }
      var labelCfg = (0, tslib_1.__assign)((0, tslib_1.__assign)({
        id: _this.getLabelId(mappingData),
        elementId: _this.geometry.getElementId(mappingData),
        data: origin,
        
        mappingData: mappingData,
        
        coordinate: coordinate
      }, cfg), callbackCfg);
      if ((0, util_1.isFunction)(labelCfg.position)) {
        labelCfg.position = labelCfg.position(origin, mappingData, index);
      }
      var offset = _this.getLabelOffset(labelCfg.offset || 0);
      
      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
      
      labelCfg = (0, util_1.deepMix)({}, defaultLabelCfg, labelCfg);
      
      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
      var content = labelCfg.content;
      if ((0, util_1.isFunction)(content)) {
        labelCfg.content = content(origin, mappingData, index);
      } else if ((0, util_1.isUndefined)(content)) {
        
        labelCfg.content = originText[0];
      }
      labelCfgs.push(labelCfg);
    });
    return labelCfgs;
  };
  GeometryLabel.prototype.getLabelText = function (origin, scales) {
    var labelTexts = [];
    (0, util_1.each)(scales, function (scale) {
      var value = origin[scale.field];
      if ((0, util_1.isArray)(value)) {
        value = value.map(function (subVal) {
          return scale.getText(subVal);
        });
      } else {
        value = scale.getText(value);
      }
      if ((0, util_1.isNil)(value) || value === '') {
        labelTexts.push(null);
      } else {
        labelTexts.push(value);
      }
    });
    return labelTexts;
  };
  GeometryLabel.prototype.getOffsetVector = function (offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var coordinate = this.getCoordinate();
    var actualOffset = 0;
    if ((0, util_1.isNumber)(offset)) {
      actualOffset = offset;
    }
    // 如果 x,y 翻转，则偏移 x，否则偏移 y
    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);
  };
  GeometryLabel.prototype.getGeometryShapes = function () {
    var geometry = this.geometry;
    var shapes = {};
    (0, util_1.each)(geometry.elementsMap, function (element, id) {
      shapes[id] = element.shape;
    });
    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取
    (0, util_1.each)(geometry.getOffscreenGroup().getChildren(), function (child) {
      var id = geometry.getElementId(child.get('origin').mappingData);
      shapes[id] = child;
    });
    return shapes;
  };
  return GeometryLabel;
}();
exports.default = GeometryLabel;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConstraint = exports.getShapeAttrs = void 0;
var util_1 = __webpack_require__(0);
var get_path_points_1 = __webpack_require__(115);
var get_style_1 = __webpack_require__(33);
var path_1 = __webpack_require__(112);
function getPath(points, isInCircle, smooth, registeredShape, constraint) {
  var path = [];
  if (points.length) {
    var topLinePoints_1 = []; 
    var bottomLinePoints_1 = []; 
    for (var i = 0, len = points.length; i < len; i++) {
      var point = points[i];
      topLinePoints_1.push(point[1]);
      bottomLinePoints_1.push(point[0]);
    }
    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    (0, util_1.each)([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];
      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        
        subPath = index === 0 ? [['M', p1.x - 0.5, p1.y], ['L', p1.x + 0.5, p1.y]] : [['L', p1.x + 0.5, p1.y], ['L', p1.x - 0.5, p1.y]];
      } else {
        if (isInCircle) {
          parsedPoints.push({
            x: p1.x,
            y: p1.y
          });
        }
        if (smooth) {
          subPath = (0, path_1.getSplinePath)(parsedPoints, false, constraint);
        } else {
          subPath = (0, path_1.getLinePath)(parsedPoints, false);
        }
        if (index > 0) {
          subPath[0][0] = 'L';
        }
      }
      path = path.concat(subPath);
    });
    path.push(['Z']);
  }
  return path;
}
function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = (0, get_style_1.getStyle)(cfg, isStroke, !isStroke, 'lineWidth');
  var connectNulls = cfg.connectNulls,
    isInCircle = cfg.isInCircle,
    points = cfg.points,
    showSinglePoint = cfg.showSinglePoint;
  var pathPoints = (0, get_path_points_1.getPathPoints)(points, connectNulls, showSinglePoint); 
  var path = [];
  for (var i = 0, len = pathPoints.length; i < len; i++) {
    var eachPoints = pathPoints[i];
    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }
  attrs.path = path;
  return attrs;
}
exports.getShapeAttrs = getShapeAttrs;
function getConstraint(coordinate) {
  var start = coordinate.start,
    end = coordinate.end;
  return [[start.x, end.y], [end.x, start.y]];
}
exports.getConstraint = getConstraint;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return _util.each;
  }
});
exports.isAllowCapture = isAllowCapture;
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _util.isArray;
  }
});
exports.isBrowser = void 0;
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return _util.isFunction;
  }
});
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return _util.isNil;
  }
});
Object.defineProperty(exports, "isObject", {
  enumerable: true,
  get: function get() {
    return _util.isObject;
  }
});
exports.isParent = isParent;
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return _util.isString;
  }
});
Object.defineProperty(exports, "mix", {
  enumerable: true,
  get: function get() {
    return _util.mix;
  }
});
exports.removeFromArray = removeFromArray;
Object.defineProperty(exports, "upperFirst", {
  enumerable: true,
  get: function get() {
    return _util.upperFirst;
  }
});
var _util = __webpack_require__(0);
function removeFromArray(arr, obj) {
  var index = arr.indexOf(obj);
  if (index !== -1) {
    arr.splice(index, 1);
  }
}
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
exports.isBrowser = isBrowser;

function isParent(container, shape) {
  
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent = false;
  while (parent) {
    if (parent === container) {
      isParent = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent;
}
function isAllowCapture(element) {
  
  return element.cfg.visible && element.cfg.capture;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = __webpack_require__(0);

var toScaleString = function toScaleString(scale, value) {
  if ((0, _util.isString)(value)) {
    return value;
  }
  return scale.invert(scale.scale(value));
};
var Attribute = function () {
  function Attribute(cfg) {
    this.names = [];
    this.scales = [];
    this.linear = false;
    this.values = [];
    this.callback = function () {
      return [];
    };
    
    this._parseCfg(cfg);
  }
    Attribute.prototype.mapping = function () {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var values = params.map(function (param, idx) {
      return _this._toOriginParam(param, _this.scales[idx]);
    });
    return this.callback.apply(this, values);
  };
    Attribute.prototype.getLinearValue = function (percent) {
    
    var steps = this.values.length - 1;
    var step = Math.floor(steps * percent);
    var leftPercent = steps * percent - step;
    
    var start = this.values[step];
    var end = step === steps ? start : this.values[step + 1];
    
    return start + (end - start) * leftPercent;
  };
    Attribute.prototype.getNames = function () {
    var scales = this.scales;
    var names = this.names;
    var length = Math.min(scales.length, names.length);
    var rst = [];
    for (var i = 0; i < length; i += 1) {
      rst.push(names[i]);
    }
    return rst;
  };
    Attribute.prototype.getFields = function () {
    return this.scales.map(function (scale) {
      return scale.field;
    });
  };
    Attribute.prototype.getScale = function (name) {
    return this.scales[this.names.indexOf(name)];
  };
    Attribute.prototype.defaultCallback = function () {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    
    if (params.length === 0) {
      return this.values;
    }
    return params.map(function (param, idx) {
      var scale = _this.scales[idx];
      return scale.type === 'identity' ? scale.values[0] : _this._getAttributeValue(scale, param);
    });
  };
  
  Attribute.prototype._parseCfg = function (cfg) {
    var _this = this;
    var _a = cfg.type,
      type = _a === void 0 ? 'base' : _a,
      _b = cfg.names,
      names = _b === void 0 ? [] : _b,
      _c = cfg.scales,
      scales = _c === void 0 ? [] : _c,
      _d = cfg.values,
      values = _d === void 0 ? [] : _d,
      callback = cfg.callback;
    this.type = type;
    this.scales = scales;
    this.values = values;
    this.names = names;
    
    this.callback = function () {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
            if (callback) {
        
        var ret = callback.apply(void 0, params);
        if (!(0, _util.isNil)(ret)) {
          return [ret];
        }
      }
      
      return _this.defaultCallback.apply(_this, params);
    };
  };
  
  Attribute.prototype._getAttributeValue = function (scale, value) {
    
    if (scale.isCategory && !this.linear) {
      
      var idx = scale.translate(value);
      return this.values[idx % this.values.length];
    }
    
    var percent = scale.scale(value);
    return this.getLinearValue(percent);
  };
    Attribute.prototype._toOriginParam = function (param, scale) {
    
    
    return !scale.isLinear ? (0, _util.isArray)(param) ? param.map(function (p) {
      return toScaleString(scale, p);
    }) : toScaleString(scale, param) : param;
  };
  return Attribute;
}();
var _default = Attribute;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Controller = void 0;
var util_1 = __webpack_require__(0);
var Controller = function () {
  function Controller(view) {
        this.visible = true;
        this.components = [];
    this.view = view;
  }
    Controller.prototype.clear = function (includeOption) {
    
    (0, util_1.each)(this.components, function (co) {
      co.component.destroy();
    });
    
    this.components = [];
  };
    Controller.prototype.destroy = function () {
    this.clear();
  };
    Controller.prototype.getComponents = function () {
    return this.components;
  };
    Controller.prototype.changeVisible = function (visible) {
    if (this.visible === visible) {
      return;
    }
    this.components.forEach(function (co) {
      if (visible) {
        co.component.show();
      } else {
        co.component.hide();
      }
    });
    this.visible = visible;
  };
  return Controller;
}();
exports.Controller = Controller;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Facet = void 0;
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var axis_1 = __webpack_require__(265);
var Facet = function () {
  function Facet(view, cfg) {
        this.destroyed = false;
        this.facets = [];
    this.view = view;
    this.cfg = (0, util_1.deepMix)({}, this.getDefaultCfg(), cfg);
  }
    Facet.prototype.init = function () {
    
    if (!this.container) {
      this.container = this.createContainer();
    }
    
    var data = this.view.getData();
    this.facets = this.generateFacets(data);
  };
    Facet.prototype.render = function () {
    this.renderViews();
  };
    Facet.prototype.update = function () {
    
  };
    Facet.prototype.clear = function () {
    this.clearFacetViews();
  };
    Facet.prototype.destroy = function () {
    this.clear();
    if (this.container) {
      this.container.remove(true);
      this.container = undefined;
    }
    this.destroyed = true;
    this.view = undefined;
    this.facets = [];
  };
    Facet.prototype.facetToView = function (facet) {
    var region = facet.region,
      data = facet.data,
      _a = facet.padding,
      padding = _a === void 0 ? this.cfg.padding : _a;
    var view = this.view.createView({
      region: region,
      padding: padding
    });
    
    view.data(data || []);
    facet.view = view;
    
    this.beforeEachView(view, facet);
    var eachView = this.cfg.eachView;
    if (eachView) {
      eachView(view, facet);
    }
    
    this.afterEachView(view, facet);
    return view;
  };
  
  Facet.prototype.createContainer = function () {
    var foregroundGroup = this.view.getLayer(constant_1.LAYER.FORE);
    return foregroundGroup.addGroup();
  };
    Facet.prototype.renderViews = function () {
    this.createFacetViews();
  };
    Facet.prototype.createFacetViews = function () {
    var _this = this;
    
    return this.facets.map(function (facet) {
      return _this.facetToView(facet);
    });
  };
    Facet.prototype.clearFacetViews = function () {
    var _this = this;
    
    (0, util_1.each)(this.facets, function (facet) {
      if (facet.view) {
        _this.view.removeView(facet.view);
        facet.view = undefined;
      }
    });
  };
    Facet.prototype.parseSpacing = function () {
        var _a = this.view.viewBBox,
      width = _a.width,
      height = _a.height;
    var spacing = this.cfg.spacing;
    return spacing.map(function (s, idx) {
      if ((0, util_1.isNumber)(s)) return s / (idx === 0 ? width : height);else return parseFloat(s) / 100;
    });
  };
  
    Facet.prototype.getFieldValues = function (data, field) {
    var rst = [];
    var cache = {};
    
    (0, util_1.each)(data, function (d) {
      var value = d[field];
      if (!(0, util_1.isNil)(value) && !cache[value]) {
        rst.push(value);
        cache[value] = true;
      }
    });
    return rst;
  };
    Facet.prototype.getRegion = function (rows, cols, xIndex, yIndex) {
    var _a = this.parseSpacing(),
      xSpacing = _a[0],
      ySpacing = _a[1];
    
    
        var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
    var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
    
    var start = {
      x: (xRatio + xSpacing) * xIndex,
      y: (yRatio + ySpacing) * yIndex
    };
    var end = {
      x: start.x + xRatio,
      y: start.y + yRatio
    };
    return {
      start: start,
      end: end
    };
  };
  Facet.prototype.getDefaultCfg = function () {
    return {
      eachView: undefined,
      showTitle: true,
      spacing: [0, 0],
      padding: 10,
      fields: []
    };
  };
    Facet.prototype.getDefaultTitleCfg = function () {
    
    var fontFamily = this.view.getTheme().fontFamily;
    return {
      style: {
        fontSize: 14,
        fill: '#666',
        fontFamily: fontFamily
      }
    };
  };
    Facet.prototype.processAxis = function (view, facet) {
    var options = view.getOptions();
    var coordinateOption = options.coordinate;
    var geometries = view.geometries;
    var coordinateType = (0, util_1.get)(coordinateOption, 'type', 'rect');
    if (coordinateType === 'rect' && geometries.length) {
      if ((0, util_1.isNil)(options.axes)) {
        
        options.axes = {};
      }
      var axes = options.axes;
      var _a = geometries[0].getXYFields(),
        x = _a[0],
        y = _a[1];
      var xOption = (0, axis_1.getAxisOption)(axes, x);
      var yOption = (0, axis_1.getAxisOption)(axes, y);
      if (xOption !== false) {
        options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
      }
      if (yOption !== false) {
        options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
      }
    }
  };
    Facet.prototype.getFacetDataFilter = function (conditions) {
    return function (datum) {
      
      return (0, util_1.every)(conditions, function (condition) {
        var field = condition.field,
          value = condition.value;
        if (!(0, util_1.isNil)(value) && field) {
          return datum[field] === value;
        }
        return true;
      });
    };
  };
  return Facet;
}();
exports.Facet = Facet;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createThemeByStyleSheet = void 0;
var tslib_1 = __webpack_require__(1);
var component_1 = __webpack_require__(179);
var matrix_util_1 = __webpack_require__(32);
var util_1 = __webpack_require__(0);
var graphics_1 = __webpack_require__(46);
function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: 'center',
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: 'middle',
        fontFamily: styleSheet.fontFamily
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: {
        type: 'equidistance',
        cfg: {
          minGap: 6
        }
      },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: 'line',
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}

function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: 'circle',
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: 'start',
        textBaseline: 'middle'
      }
    },
    itemStates: {
      active: {
        nameStyle: {
          opacity: 0.8
        }
      },
      unchecked: {
        nameStyle: {
          fill: '#D8D8D8'
        },
        markerStyle: {
          fill: '#D8D8D8',
          stroke: '#D8D8D8'
        }
      },
      inactive: {
        nameStyle: {
          fill: '#D8D8D8'
        },
        markerStyle: {
          opacity: 0.2
        }
      }
    },
    flipPage: true,
    pageNavigator: {
      marker: {
        style: {
          size: styleSheet.legendPageNavigatorMarkerSize,
          inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
          inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
          fill: styleSheet.legendPageNavigatorMarkerFillColor,
          opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
        }
      },
      text: {
        style: {
          fill: styleSheet.legendPageNavigatorTextFillColor,
          fontSize: styleSheet.legendPageNavigatorTextFontSize
        }
      }
    },
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding 
  };
}
function createThemeByStyleSheet(styleSheet) {
  var _a;
  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: 'round',
        lineJoin: 'round'
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    subColor: styleSheet.subColor,
    semanticRed: styleSheet.paletteSemanticRed,
    semanticGreen: styleSheet.paletteSemanticGreen,
    padding: 'auto',
    fontFamily: styleSheet.fontFamily,
    
        columnWidthRatio: 1 / 2,
        maxColumnWidth: null,
        minColumnWidth: null,
        roseWidthRatio: 0.9999999,
        multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    sequenceColors: styleSheet.paletteSequence,
    shapes: {
      point: ['hollow-circle', 'hollow-square', 'hollow-bowtie', 'hollow-diamond', 'hollow-hexagon', 'hollow-triangle', 'hollow-triangle-down', 'circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down', 'cross', 'tick', 'plus', 'hyphen', 'line'],
      line: ['line', 'dash', 'dot', 'smooth'],
      area: ['area', 'smooth', 'line', 'smooth-line'],
      interval: ['rect', 'hollow-rect', 'line', 'tick']
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function style(element) {
              var coordinate = element.geometry.coordinate;
              if (coordinate.isPolar && coordinate.isTransposed) {
                var _a = (0, graphics_1.getAngle)(element.getModel(), coordinate),
                  startAngle = _a.startAngle,
                  endAngle = _a.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r = 7.5;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                return {
                  matrix: matrix_util_1.ext.transform(null, [['t', x, y]])
                };
              }
              return shapeStyles.interval.selected;
            }
          }
        },
        'hollow-rect': {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.default), {
              lineCap: null,
              lineDash: [1, 1]
            })
          },
          active: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.active), {
              lineCap: null,
              lineDash: [1, 1]
            })
          },
          inactive: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.inactive), {
              lineCap: null,
              lineDash: [1, 1]
            })
          },
          selected: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.selected), {
              lineCap: null,
              lineDash: [1, 1]
            })
          }
        },
        dash: {
          default: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.default), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          },
          active: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.active), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          },
          inactive: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.inactive), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          },
          selected: {
            style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeStyles.line.selected), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        'triangle-down': {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        'hollow-circle': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-square': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-bowtie': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-diamond': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-hexagon': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-triangle': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-triangle-down': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        'smooth-line': {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      violin: {
        violin: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hollow: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        'hollow-smooth': {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: {
          position: 'top',
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        bottom: {
          position: 'bottom',
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        left: {
          position: 'left',
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        right: {
          position: 'right',
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        circle: {
          title: null,
          grid: (0, util_1.deepMix)({}, axisStyles.grid, {
            line: {
              type: 'line'
            }
          })
        },
        radius: {
          title: null,
          grid: (0, util_1.deepMix)({}, axisStyles.grid, {
            line: {
              type: 'circle'
            }
          })
        }
      },
      legend: {
        common: legendStyles,
        right: {
          layout: 'vertical',
          padding: styleSheet.legendVerticalPadding
        },
        left: {
          layout: 'vertical',
          padding: styleSheet.legendVerticalPadding
        },
        top: {
          layout: 'horizontal',
          padding: styleSheet.legendHorizontalPadding
        },
        bottom: {
          layout: 'horizontal',
          padding: styleSheet.legendHorizontalPadding
        },
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: 'color',
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: 'rail',
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: 'middle',
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: 'auto',
        marker: {
          symbol: 'circle',
          stroke: '#fff',
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: 'rgba(0,0,0,0.09)',
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: 'rgba(0, 0, 0, 0.25)',
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        
        domStyles: (_a = {}, _a["" + component_1.TOOLTIP_CSS_CONST.CONTAINER_CLASS] = {
          position: 'absolute',
          visibility: 'hidden',
          zIndex: 8,
          transition: 'left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s',
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: styleSheet.tooltipContainerBorderRadius + "px",
          color: styleSheet.tooltipTextFillColor,
          fontSize: styleSheet.tooltipTextFontSize + "px",
          fontFamily: styleSheet.fontFamily,
          lineHeight: styleSheet.tooltipTextLineHeight + "px",
          padding: '0 12px 0 12px'
        }, _a["" + component_1.TOOLTIP_CSS_CONST.TITLE_CLASS] = {
          marginBottom: '12px',
          marginTop: '12px'
        }, _a["" + component_1.TOOLTIP_CSS_CONST.LIST_CLASS] = {
          margin: 0,
          listStyleType: 'none',
          padding: 0
        }, _a["" + component_1.TOOLTIP_CSS_CONST.LIST_ITEM_CLASS] = {
          listStyleType: 'none',
          padding: 0,
          marginBottom: '12px',
          marginTop: '12px',
          marginLeft: 0,
          marginRight: 0
        }, _a["" + component_1.TOOLTIP_CSS_CONST.MARKER_CLASS] = {
          width: '8px',
          height: '8px',
          borderRadius: '50%',
          display: 'inline-block',
          marginRight: '8px'
        }, _a["" + component_1.TOOLTIP_CSS_CONST.VALUE_CLASS] = {
          display: 'inline-block',
          float: 'right',
          marginLeft: '30px'
        }, _a)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: 'start',
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: 'start',
              fontFamily: styleSheet.fontFamily,
              textBaseline: 'bottom'
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: 'middle',
            textAlign: 'start',
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: 'start',
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: 'upward',
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: 'center',
              textBaseline: 'bottom',
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8],
          backgroundStyle: {
            fill: styleSheet.cSliderBackgroundFillColor,
            opacity: styleSheet.cSliderBackgroundFillOpacity
          },
          foregroundStyle: {
            fill: styleSheet.cSliderForegroundFillColor,
            opacity: styleSheet.cSliderForegroundFillOpacity
          },
          handlerStyle: {
            width: styleSheet.cSliderHandlerWidth,
            height: styleSheet.cSliderHandlerHeight,
            fill: styleSheet.cSliderHandlerFillColor,
            opacity: styleSheet.cSliderHandlerFillOpacity,
            stroke: styleSheet.cSliderHandlerBorderColor,
            lineWidth: styleSheet.cSliderHandlerBorder,
            radius: styleSheet.cSliderHandlerBorderRadius,
            // 高亮的颜色
            highLightFill: styleSheet.cSliderHandlerHighlightFillColor
          },
          textStyle: {
            fill: styleSheet.cSliderTextFillColor,
            opacity: styleSheet.cSliderTextFillOpacity,
            fontSize: styleSheet.cSliderTextFontSize,
            lineHeight: styleSheet.cSliderTextLineHeight,
            fontWeight: styleSheet.cSliderTextFontWeight,
            stroke: styleSheet.cSliderTextBorderColor,
            lineWidth: styleSheet.cSliderTextBorder
          }
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        },
        default: {
          style: {
            trackColor: styleSheet.scrollbarTrackFillColor,
            thumbColor: styleSheet.scrollbarThumbFillColor
          }
        },
        hover: {
          style: {
            thumbColor: styleSheet.scrollbarThumbHighlightFillColor
          }
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}
exports.createThemeByStyleSheet = createThemeByStyleSheet;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _isObject = _interopRequireDefault(__webpack_require__(169));
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if ((0, _isArray.default)(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if ((0, _isObject.default)(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var _default = each;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isNil = _interopRequireDefault(__webpack_require__(95));
var _default = function _default(value) {
  if ((0, _isNil.default)(value)) return '';
  return value.toString();
};
exports.default = _default;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nogamma;
exports.gamma = gamma;
exports.hue = hue;
var _constant = _interopRequireDefault(__webpack_require__(402));
function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, _constant.default)(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : (0, _constant.default)(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0, _constant.default)(isNaN(a) ? b : a);
}

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ = _interopRequireWildcard(__webpack_require__(0));
var _constant = __webpack_require__(250);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var Adjust = /** @class */function () {
  function Adjust(cfg) {
    var xField = cfg.xField,
      yField = cfg.yField,
      _a = cfg.adjustNames,
      adjustNames = _a === void 0 ? ['x', 'y'] : _a,
      dimValuesMap = cfg.dimValuesMap;
    this.adjustNames = adjustNames;
    this.xField = xField;
    this.yField = yField;
    this.dimValuesMap = dimValuesMap;
  }
    Adjust.prototype.isAdjust = function (dim) {
    return this.adjustNames.indexOf(dim) >= 0;
  };
  Adjust.prototype.getAdjustRange = function (dim, dimValue, values) {
    var yField = this.yField;
    var index = values.indexOf(dimValue);
    var length = values.length;
    var pre;
    var next;
    
    if (!yField && this.isAdjust('y')) {
      pre = 0;
      next = 1;
    } else if (length > 1) {
      
      pre = values[index === 0 ? 0 : index - 1];
      
      next = values[index === length - 1 ? length - 1 : index + 1];
      if (index !== 0) {
        pre += (dimValue - pre) / 2;
      } else {
        pre -= (next - dimValue) / 2;
      }
      if (index !== length - 1) {
        next -= (next - dimValue) / 2;
      } else {
        next += (dimValue - values[length - 2]) / 2;
      }
    } else {
      pre = dimValue === 0 ? 0 : dimValue - 0.5;
      next = dimValue === 0 ? 1 : dimValue + 0.5;
    }
    return {
      pre: pre,
      next: next
    };
  };
  Adjust.prototype.adjustData = function (groupedDataArray, mergedData) {
    var _this = this;
    
    var dimValuesMap = this.getDimValues(mergedData);
    
    _.each(groupedDataArray, function (dataArray, index) {
      
      
      _.each(dimValuesMap, function (values, dim) {
        
        _this.adjustDim(dim, values, dataArray, index);
      });
    });
  };
    Adjust.prototype.groupData = function (data, dim) {
    
    _.each(data, function (record) {
      if (record[dim] === undefined) {
        record[dim] = _constant.DEFAULT_Y;
      }
    });
    
    return _.groupBy(data, dim);
  };
    Adjust.prototype.adjustDim = function (dim, values, data, index) {};
    Adjust.prototype.getDimValues = function (mergedData) {
    var _a = this,
      xField = _a.xField,
      yField = _a.yField;
    var dimValuesMap = _.assign({}, this.dimValuesMap);
    
    var dims = [];
    if (xField && this.isAdjust('x')) {
      dims.push(xField);
    }
    if (yField && this.isAdjust('y')) {
      dims.push(yField);
    }
    dims.forEach(function (dim) {
      if (dimValuesMap && dimValuesMap[dim]) {
        return;
      }
      
      dimValuesMap[dim] = _.valuesOfKey(mergedData, dim).sort(function (v1, v2) {
        return v1 - v2;
      });
    });
    
    if (!yField && this.isAdjust('y')) {
      var dim = 'y';
      dimValuesMap[dim] = [_constant.DEFAULT_Y, 1]; 
    }

    return dimValuesMap;
  };
  return Adjust;
}();
var _default = Adjust;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMaxScale = exports.getDefaultCategoryScaleRange = exports.getName = exports.syncScale = exports.createScaleByField = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var dependents_1 = __webpack_require__(69);
var coordinate_1 = __webpack_require__(48);
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
function getDefaultType(value) {
  var type = 'linear';
  if (dateRegex.test(value)) {
    type = 'timeCat';
  } else if ((0, util_1.isString)(value)) {
    type = 'cat';
  }
  return type;
}
function createScaleByField(field, data, scaleDef) {
  var validData = data || [];
  if ((0, util_1.isNumber)(field) || (0, util_1.isNil)((0, util_1.firstValue)(validData, field)) && (0, util_1.isEmpty)(scaleDef)) {
    var Identity = (0, dependents_1.getScale)('identity');
    return new Identity({
      field: field.toString(),
      values: [field]
    });
  }
  var values = (0, util_1.valuesOfKey)(validData, field);
  
  var type = (0, util_1.get)(scaleDef, 'type', getDefaultType(values[0]));
  var ScaleCtor = (0, dependents_1.getScale)(type);
  return new ScaleCtor((0, tslib_1.__assign)({
    field: field,
    values: values
  }, scaleDef));
}
exports.createScaleByField = createScaleByField;
function syncScale(scale, newScale) {
  if (scale.type !== 'identity' && newScale.type !== 'identity') {
    var obj = {};
    for (var k in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k)) {
        obj[k] = newScale[k];
      }
    }
    scale.change(obj);
  }
}
exports.syncScale = syncScale;
function getName(scale) {
  return scale.alias || scale.field;
}
exports.getName = getName;
function getDefaultCategoryScaleRange(scale, coordinate, theme) {
  var values = scale.values;
  var count = values.length;
  var range;
  if (count === 1) {
    range = [0.5, 1]; 
  } else {
    var widthRatio = 1;
    var offset = 0;
    if ((0, coordinate_1.isFullCircle)(coordinate)) {
      if (!coordinate.isTransposed) {
        range = [0, 1 - 1 / count];
      } else {
        widthRatio = (0, util_1.get)(theme, 'widthRatio.multiplePie', 1 / 1.3);
        offset = 1 / count * widthRatio;
        range = [offset / 2, 1 - offset / 2];
      }
    } else {
      offset = 1 / count / 2; 
      range = [offset, 1 - offset]; 
    }
  }

  return range;
}
exports.getDefaultCategoryScaleRange = getDefaultCategoryScaleRange;
function getMaxScale(scale) {
  
  var values = scale.values.filter(function (item) {
    return !(0, util_1.isNil)(item) && !isNaN(item);
  });
  return Math.max.apply(Math, (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], values, false), [(0, util_1.isNil)(scale.max) ? -Infinity : scale.max], false));
}
exports.getMaxScale = getMaxScale;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertPolarPath = exports.convertNormalPath = exports.getSplinePath = exports.getLinePath = exports.catmullRom2bezier = exports.smoothBezier = void 0;
var matrix_util_1 = __webpack_require__(32);
var util_1 = __webpack_require__(0);
var coordinate_1 = __webpack_require__(48);
function _points2path(points, isInCircle) {
  var path = [];
  if (points.length) {
    path.push(['M', points[0].x, points[0].y]);
    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path.push(['L', item.x, item.y]);
    }
    if (isInCircle) {
      path.push(['Z']);
    }
  }
  return path;
}
function _convertArr(arr, coord) {
  var tmp = [arr[0]];
  for (var i = 1, len = arr.length; i < len; i = i + 2) {
    var point = coord.convert({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point.x, point.y);
  }
  return tmp;
}
function _convertArcPath(path, coord) {
  var isTransposed = coord.isTransposed;
  var r = path[1];
  var x = path[6];
  var y = path[7];
  var point = coord.convert({
    x: x,
    y: y
  });
  var direction = isTransposed ? 0 : 1;
  return ['A', r, r, 0, 0, direction, point.x, point.y];
}
function _convertPolarPath(pre, cur, coord) {
  var isTransposed = coord.isTransposed,
    startAngle = coord.startAngle,
    endAngle = coord.endAngle;
  var prePoint = pre[0].toLowerCase() === 'a' ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? 'y' : 'x';
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; 
  var flag = angleRange > Math.PI ? 1 : 0; 
  var convertPoint = coord.convert(curPoint);
  var r = (0, coordinate_1.getDistanceToCenter)(coord, convertPoint);
  if (r >= 0.5) {
    
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord.convert(middlePoint);
      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
    }
  }
  return rst;
}

function _filterFullCirleLine(path) {
  (0, util_1.each)(path, function (subPath, index) {
    var cur = subPath;
    if (cur[0].toLowerCase() === 'a') {
      var pre = path[index - 1];
      var next = path[index + 1];
      if (next && next[0].toLowerCase() === 'a') {
        if (pre && pre[0].toLowerCase() === 'l') {
          pre[0] = 'M';
        }
      } else if (pre && pre[0].toLowerCase() === 'a') {
        if (next && next[0].toLowerCase() === 'l') {
          next[0] = 'M';
        }
      }
    }
  });
}
var smoothBezier = function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min;
  var max;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min = constraint[0], max = constraint[1];
    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      min = matrix_util_1.vec2.min([0, 0], min, point);
      max = matrix_util_1.vec2.max([0, 0], max, point);
    }
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point;
    } else if (i === len - 1 && !isLoop) {
      cp1 = point;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      prevPoint = points[isLoop ? i ? i - 1 : len - 1 : i - 1];
      nextPoint = points[isLoop ? (i + 1) % len : i + 1];
      var v = [0, 0];
      v = matrix_util_1.vec2.sub(v, nextPoint, prevPoint);
      v = matrix_util_1.vec2.scale(v, v, smooth);
      var d0 = matrix_util_1.vec2.distance(point, prevPoint);
      var d1 = matrix_util_1.vec2.distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = matrix_util_1.vec2.scale([0, 0], v, -d0);
      var v2 = matrix_util_1.vec2.scale([0, 0], v, d1);
      cp1 = matrix_util_1.vec2.add([0, 0], point, v1);
      nextCp0 = matrix_util_1.vec2.add([0, 0], point, v2);
      
      nextCp0 = matrix_util_1.vec2.min([0, 0], nextCp0, matrix_util_1.vec2.max([0, 0], nextPoint, point));
      nextCp0 = matrix_util_1.vec2.max([0, 0], nextCp0, matrix_util_1.vec2.min([0, 0], nextPoint, point));
      
      v1 = matrix_util_1.vec2.sub([0, 0], nextCp0, point);
      v1 = matrix_util_1.vec2.scale([0, 0], v1, -d0 / d1);
      cp1 = matrix_util_1.vec2.add([0, 0], point, v1);
      
      cp1 = matrix_util_1.vec2.min([0, 0], cp1, matrix_util_1.vec2.max([0, 0], prevPoint, point));
      cp1 = matrix_util_1.vec2.max([0, 0], cp1, matrix_util_1.vec2.min([0, 0], prevPoint, point));
      
      v2 = matrix_util_1.vec2.sub([0, 0], point, cp1);
      v2 = matrix_util_1.vec2.scale([0, 0], v2, d1 / d0);
      nextCp0 = matrix_util_1.vec2.add([0, 0], point, v2);
      if (hasConstraint) {
        cp1 = matrix_util_1.vec2.max([0, 0], cp1, min);
        cp1 = matrix_util_1.vec2.min([0, 0], cp1, max);
        nextCp0 = matrix_util_1.vec2.max([0, 0], nextCp0, min);
        nextCp0 = matrix_util_1.vec2.min([0, 0], nextCp0, max);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
exports.smoothBezier = smoothBezier;
function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = (0, exports.smoothBezier)(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
exports.catmullRom2bezier = catmullRom2bezier;
function getLinePath(points, isInCircle) {
  return _points2path(points, isInCircle);
}
exports.getLinePath = getLinePath;
function getSplinePath(points, isInCircle, constaint) {
  var data = [];
  var first = points[0];
  var prePoint = null;
  if (points.length <= 2) {
    
    return getLinePath(points, isInCircle);
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];
    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
      data.push(point.x);
      data.push(point.y);
      prePoint = point;
    }
  }
  var constraint = constaint || [
  
  [0, 0], [1, 1]];
  var splinePath = catmullRom2bezier(data, isInCircle, constraint);
  splinePath.unshift(['M', first.x, first.y]);
  return splinePath;
}
exports.getSplinePath = getSplinePath;
function convertNormalPath(coord, path) {
  var tmp = [];
  (0, util_1.each)(path, function (subPath) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case 'm':
      case 'l':
      case 'c':
        tmp.push(_convertArr(subPath, coord));
        break;
      case 'a':
        tmp.push(_convertArcPath(subPath, coord));
        break;
      case 'z':
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}
exports.convertNormalPath = convertNormalPath;
function convertPolarPath(coord, path) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals;
  (0, util_1.each)(path, function (subPath, index) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case 'm':
      case 'c':
      case 'q':
        tmp.push(_convertArr(subPath, coord));
        break;
      case 'l':
        pre = path[index - 1];
        cur = subPath;
        transposed = coord.isTransposed;
        
        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
        if (equals) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
        } else {
          
          tmp.push(_convertArr(subPath, coord));
        }
        break;
      case 'a':
        tmp.push(_convertArcPath(subPath, coord));
        break;
      case 'z':
      default:
        tmp.push(subPath);
        break;
    }
  });
  _filterFullCirleLine(tmp); 
  return tmp;
}
exports.convertPolarPath = convertPolarPath;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkShapeOverlap = exports.getOverlapArea = exports.getlLabelBackgroundInfo = exports.findLabelTextShape = void 0;
var util_1 = __webpack_require__(0);
var transform_1 = __webpack_require__(114);
function findLabelTextShape(label) {
  return label.find(function (el) {
    return el.get('type') === 'text';
  });
}
exports.findLabelTextShape = findLabelTextShape;
function getlLabelBackgroundInfo(labelGroup, labelItem, padding) {
  if (padding === void 0) {
    padding = [0, 0, 0, 0];
  }
  var content = labelGroup.getChildren()[0];
  if (content) {
    var labelShape = content.clone();
    
    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
      (0, transform_1.rotate)(labelShape, -labelItem.rotate);
    }
    
    var _a = labelShape.getCanvasBBox(),
      x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height;
    labelShape.destroy();
    var boxPadding = padding;
    if ((0, util_1.isNil)(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if ((0, util_1.isNumber)(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }
    return {
      x: x - boxPadding[3],
      y: y - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
    };
  }
}
exports.getlLabelBackgroundInfo = getlLabelBackgroundInfo;
function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
exports.getOverlapArea = getOverlapArea;
function checkShapeOverlap(cur, dones) {
  var box = cur.getBBox();
  return (0, util_1.some)(dones, function (done) {
    var target = done.getBBox();
    return getOverlapArea(box, target, 2) > 0;
  });
}
exports.checkShapeOverlap = checkShapeOverlap;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoom = exports.getIdentityMatrix = exports.rotate = exports.getRotateMatrix = exports.translate = exports.transform = void 0;
var matrix_util_1 = __webpack_require__(32);
var transform = matrix_util_1.ext.transform;
exports.transform = transform;
function translate(element, x, y) {
  var matrix = transform(element.getMatrix(), [['t', x, y]]);
  element.setMatrix(matrix);
}
exports.translate = translate;
function getRotateMatrix(element, rotateRadian) {
  var _a = element.attr(),
    x = _a.x,
    y = _a.y;
  var matrix = transform(element.getMatrix(), [['t', -x, -y], ['r', rotateRadian], ['t', x, y]]);
  return matrix;
}
exports.getRotateMatrix = getRotateMatrix;
function rotate(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}
exports.rotate = rotate;
function getIdentityMatrix() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}
exports.getIdentityMatrix = getIdentityMatrix;
function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x = (bbox.minX + bbox.maxX) / 2;
  var y = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x, y, 1]);
  var matrix = transform(element.getMatrix(), [['t', -x, -y], ['s', ratio, ratio], ['t', x, y]]);
  element.setMatrix(matrix);
}
exports.zoom = zoom;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSmoothViolinPath = exports.getViolinPath = exports.getPathPoints = void 0;
var util_1 = __webpack_require__(0);
var path_1 = __webpack_require__(112);
function isValueEmpty(value) {
  if (value) {
    return false;
  }
  return value === null || value === undefined || isNaN(value);
}
function isYNil(point) {
  if ((0, util_1.isArray)(point)) {
    
    return isValueEmpty(point[1].y);
  }
  var value = point.y;
  return (0, util_1.isArray)(value) ? isValueEmpty(value[0]) : isValueEmpty(value);
}
function getPathPoints(points, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }
  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }
  if (!points.length || points.length === 1 && !showSinglePoint) {
    
    return [];
  }
  if (connectNulls) {
    
    var filtered = [];
    for (var i = 0, len = points.length; i < len; i++) {
      var point = points[i];
      if (!isYNil(point)) {
        filtered.push(point);
      }
    }
    return [filtered];
  }
  var result = [];
  var tmp = [];
  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];
    if (isYNil(point)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          
          result.push(tmp);
        }
        tmp = [];
      }
    } else {
      tmp.push(point);
    }
  }
  if (tmp.length) {
    result.push(tmp);
  }
  return result;
}
exports.getPathPoints = getPathPoints;
function getViolinPath(points) {
  var path = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    if (point) {
      var action = i === 0 ? 'M' : 'L';
      path.push([action, point.x, point.y]);
    }
  }
  var first = points[0];
  if (first) {
    path.push(['L', first.x, first.y]);
    path.push(['z']);
  }
  return path;
}
exports.getViolinPath = getViolinPath;
function getSmoothViolinPath(points) {
  var half = points.length / 2;
  var leftPoints = [];
  var rightPoints = [];
  for (var i = 0; i < points.length; i++) {
    if (i < half) {
      leftPoints.push(points[i]);
    } else {
      rightPoints.push(points[i]);
    }
  }
  var leftPath = (0, path_1.getSplinePath)(leftPoints, false);
  var rightPath = (0, path_1.getSplinePath)(rightPoints, false);
  if (rightPoints.length) {
    leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);
  }
  rightPath.shift();
  var path = leftPath.concat(rightPath);
  if (leftPoints.length) {
    path.push(['L', leftPoints[0].x, leftPoints[0].y]);
  }
  path.push(['z']);
  return path;
}
exports.getSmoothViolinPath = getSmoothViolinPath;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAnglePoint = exports.getFactTitleConfig = void 0;
var constant_1 = __webpack_require__(21);
function getFactTitleConfig(direction) {
  if ([constant_1.DIRECTION.TOP, constant_1.DIRECTION.BOTTOM].includes(direction)) {
    return {
      offsetX: 0,
      offsetY: direction === constant_1.DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: 'center',
        textBaseline: direction === constant_1.DIRECTION.TOP ? 'bottom' : 'top'
      }
    };
  }
  if ([constant_1.DIRECTION.LEFT, constant_1.DIRECTION.RIGHT].includes(direction)) {
    return {
      offsetX: direction === constant_1.DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction === constant_1.DIRECTION.LEFT ? 'right' : 'left',
        textBaseline: 'middle',
        rotate: Math.PI / 2 
      }
    };
  }

  return {};
}
exports.getFactTitleConfig = getFactTitleConfig;
function getAnglePoint(center, r, angle) {
  return {
    x: center.x + r * Math.cos(angle),
    y: center.y + r * Math.sin(angle)
  };
}
exports.getAnglePoint = getAnglePoint;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var toString = {}.toString;
var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};
exports.default = isType;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTinyData = void 0;
var util_1 = __webpack_require__(0);
function getTinyData(data) {
  return util_1.map(data || [], function (y, x) {
    return {
      x: "" + x,
      y: y
    };
  });
}
exports.getTinyData = getTinyData;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataWhetherPecentage = exports.getDeepPercent = exports.percent = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var number_1 = __webpack_require__(291);
function percent(data, measure, groupField, as) {
  
  var sumMap = util_1.reduce(data, function (map, datum) {
    var groupValue = datum[groupField];
    var sum = map.has(groupValue) ? map.get(groupValue) : 0;
    var v = datum[measure];
    sum = number_1.isRealNumber(v) ? sum + v : sum;
    map.set(groupValue, sum);
    return map;
  }, new Map());
  
  return util_1.map(data, function (datum) {
    var _a;
    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = number_1.isRealNumber(v) ? v / sumMap.get(groupValue) : 0;
    return tslib_1.__assign(tslib_1.__assign({}, datum), (_a = {}, _a[as] = percentage, _a));
  });
}
exports.percent = percent;
function getDeepPercent(data, measure, fields, percent) {
  var sumMap = util_1.reduce(data, function (map, datum) {
    
    var groupValue = util_1.reduce(fields, function (value, field) {
      return "" + value + datum[field];
    }, '');
    var sum = map.has(groupValue) ? map.get(groupValue) : 0;
    var v = datum[measure];
    sum = number_1.isRealNumber(v) ? sum + v : sum;
    map.set(groupValue, sum);
    return map;
  }, new Map());
  // 2. 循环数组，计算占比
  return util_1.map(data, function (datum) {
    var _a;
    var v = datum[measure];
    // 获取分组得到的枚举key值
    var groupValue = util_1.reduce(fields, function (value, field) {
      return "" + value + datum[field];
    }, '');
    var percentage = number_1.isRealNumber(v) ? v / sumMap.get(groupValue) : 0;
    return tslib_1.__assign(tslib_1.__assign({}, datum), (_a = {}, _a[percent] = percentage, _a));
  });
}
exports.getDeepPercent = getDeepPercent;
/**
 * 获取数据，如果是百分比，进行数据转换 (适用于面积图、柱状图、条形图)
 * @param isPercent 是否百分比
 */
function getDataWhetherPecentage(data, yField, groupField, asField, isPercent) {
  return !isPercent ? data : percent(data, yField, groupField, asField);
}
exports.getDataWhetherPecentage = getDataWhetherPecentage;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _a;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.PLOYGON_Y = exports.PLOYGON_X = exports.FUNNEL_TOTAL_PERCENT = exports.FUNNEL_CONVERSATION = exports.FUNNEL_MAPPING_VALUE = exports.FUNNEL_PERCENT = void 0;

exports.FUNNEL_PERCENT = '$$percentage$$';

exports.FUNNEL_MAPPING_VALUE = '$$mappingValue$$';

exports.FUNNEL_CONVERSATION = '$$conversion$$';


exports.FUNNEL_TOTAL_PERCENT = '$$totalPercentage$$';

exports.PLOYGON_X = '$$x$$';
exports.PLOYGON_Y = '$$y$$';
exports.DEFAULT_OPTIONS = {
  appendPadding: [0, 80],
  minSize: 0,
  maxSize: 1,
  meta: (_a = {}, _a[exports.FUNNEL_MAPPING_VALUE] = {
    min: 0,
    max: 1,
    nice: false
  }, _a),
  label: {
    style: {
      fill: '#fff',
      fontSize: 12
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    shared: false
  },
  conversionTag: {
    offsetX: 10,
    offsetY: 0,
    style: {
      fontSize: 12,
      fill: 'rgba(0,0,0,0.45)'
    }
  }
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAdjustAppendPadding = getAdjustAppendPadding;
exports.normalPadding = normalPadding;
exports.resolveAllPadding = resolveAllPadding;
var _util = __webpack_require__(0);
function normalPadding(padding) {
  if ((0, _util.isNumber)(padding)) {
    return [padding, padding, padding, padding];
  }
  if ((0, _util.isArray)(padding)) {
    var length_1 = padding.length;
    if (length_1 === 1) {
      return [padding[0], padding[0], padding[0], padding[0]];
    }
    if (length_1 === 2) {
      return [padding[0], padding[1], padding[0], padding[1]];
    }
    if (length_1 === 3) {
      return [padding[0], padding[1], padding[2], padding[1]];
    }
    if (length_1 === 4) {
      return padding;
    }
  }
  return [0, 0, 0, 0];
}
function getAdjustAppendPadding(padding, position, append) {
  if (position === void 0) {
    position = 'bottom';
  }
  if (append === void 0) {
    append = 25;
  }
  var currentAppendPadding = normalPadding(padding);
  var PADDING = [position.startsWith('top') ? append : 0, position.startsWith('right') ? append : 0, position.startsWith('bottom') ? append : 0, position.startsWith('left') ? append : 0];
  return [currentAppendPadding[0] + PADDING[0], currentAppendPadding[1] + PADDING[1], currentAppendPadding[2] + PADDING[2], currentAppendPadding[3] + PADDING[3]];
}
function resolveAllPadding(paddings) {
  
  var normalPaddings = paddings.map(function (item) {
    return normalPadding(item);
  });
  var finalPadding = [0, 0, 0, 0];
  if (normalPaddings.length > 0) {
    finalPadding = finalPadding.map(function (item, index) {
      
      normalPaddings.forEach(function (d, i) {
        item += normalPaddings[i][index];
      });
      return item;
    });
  }
  return finalPadding;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pattern = pattern;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var _util = __webpack_require__(0);
var _pattern = __webpack_require__(545);
var _utils = __webpack_require__(7);
function pattern(key) {
  var _this = this;
  return function (params) {
    var _a;
    var options = params.options,
      chart = params.chart;
    var patternOption = options.pattern;
    
    if (!patternOption) {
      return params;
    }
        var style = function style(datum) {
      var _a, _b, _c;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var defaultColor = chart.getTheme().defaultColor;
      var color = defaultColor;
      var colorAttribute = (_b = (_a = chart.geometries) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getAttribute('color');
      if (colorAttribute) {
        var colorField = colorAttribute.getFields()[0];
        var seriesValue = (0, _util.get)(datum, colorField);
        color = _g.Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
      }
      var pattern = patternOption;
      
      if (typeof patternOption === 'function') {
        pattern = patternOption.call(_this, datum, color);
      }
      
      if (pattern instanceof CanvasPattern === false) {
        
        pattern = (0, _pattern.getCanvasPattern)((0, _utils.deepAssign)({}, {
          cfg: {
            backgroundColor: color
          }
        }, pattern));
      }
      var styleOption = options[key];
      return (0, _tslib.__assign)((0, _tslib.__assign)({}, typeof styleOption === 'function' ? styleOption.call.apply(styleOption, (0, _tslib.__spreadArrays)([_this, datum], args)) : styleOption || {}), {
        fill: pattern || color
      });
    };
    return (0, _utils.deepAssign)({}, params, {
      options: (_a = {}, _a[key] = style, _a)
    });
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataWhetherPecentage = getDataWhetherPecentage;
exports.getDeepPercent = getDeepPercent;
exports.percent = percent;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _number = __webpack_require__(302);
function percent(data, measure, groupField, as) {
  
  var sumMap = (0, _util.reduce)(data, function (map, datum) {
    var groupValue = datum[groupField];
    var sum = map.has(groupValue) ? map.get(groupValue) : 0;
    var v = datum[measure];
    sum = (0, _number.isRealNumber)(v) ? sum + v : sum;
    map.set(groupValue, sum);
    return map;
  }, new Map());
  
  return (0, _util.map)(data, function (datum) {
    var _a;
    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = (0, _number.isRealNumber)(v) ? v / sumMap.get(groupValue) : 0;
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, datum), (_a = {}, _a[as] = percentage, _a));
  });
}
function getDeepPercent(data, measure, fields, percent) {
  var sumMap = (0, _util.reduce)(data, function (map, datum) {
    
    var groupValue = (0, _util.reduce)(fields, function (value, field) {
      return "" + value + datum[field];
    }, '');
    var sum = map.has(groupValue) ? map.get(groupValue) : 0;
    var v = datum[measure];
    sum = (0, _number.isRealNumber)(v) ? sum + v : sum;
    map.set(groupValue, sum);
    return map;
  }, new Map());
  // 2. 循环数组，计算占比
  return (0, _util.map)(data, function (datum) {
    var _a;
    var v = datum[measure];
    // 获取分组得到的枚举key值
    var groupValue = (0, _util.reduce)(fields, function (value, field) {
      return "" + value + datum[field];
    }, '');
    var percentage = (0, _number.isRealNumber)(v) ? v / sumMap.get(groupValue) : 0;
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, datum), (_a = {}, _a[percent] = percentage, _a));
  });
}
/**
 * 获取数据，如果是百分比，进行数据转换 (适用于面积图、柱状图、条形图)
 * @param isPercent 是否百分比
 */
function getDataWhetherPecentage(data, yField, groupField, asField, isPercent) {
  return !isPercent ? data : percent(data, yField, groupField, asField);
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTinyData = getTinyData;
var _util = __webpack_require__(0);
function getTinyData(data) {
  return (0, _util.map)(data || [], function (y, x) {
    return {
      x: "" + x,
      y: y
    };
  });
}

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLOYGON_Y = exports.PLOYGON_X = exports.FUNNEL_TOTAL_PERCENT = exports.FUNNEL_PERCENT = exports.FUNNEL_MAPPING_VALUE = exports.FUNNEL_CONVERSATION = exports.DEFAULT_OPTIONS = void 0;
var _a;

var FUNNEL_PERCENT = '$$percentage$$';

exports.FUNNEL_PERCENT = FUNNEL_PERCENT;
var FUNNEL_MAPPING_VALUE = '$$mappingValue$$';

exports.FUNNEL_MAPPING_VALUE = FUNNEL_MAPPING_VALUE;
var FUNNEL_CONVERSATION = '$$conversion$$';


exports.FUNNEL_CONVERSATION = FUNNEL_CONVERSATION;
var FUNNEL_TOTAL_PERCENT = '$$totalPercentage$$';

exports.FUNNEL_TOTAL_PERCENT = FUNNEL_TOTAL_PERCENT;
var PLOYGON_X = '$$x$$';
exports.PLOYGON_X = PLOYGON_X;
var PLOYGON_Y = '$$y$$';
exports.PLOYGON_Y = PLOYGON_Y;
var DEFAULT_OPTIONS = {
  appendPadding: [0, 80],
  minSize: 0,
  maxSize: 1,
  meta: (_a = {}, _a[FUNNEL_MAPPING_VALUE] = {
    min: 0,
    max: 1,
    nice: false
  }, _a),
  label: {
    style: {
      fill: '#fff',
      fontSize: 12
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    shared: false
  },
  conversionTag: {
    offsetX: 10,
    offsetY: 0,
    style: {
      fontSize: 12,
      fill: 'rgba(0,0,0,0.45)'
    }
  }
};
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var WILDCARD = '*';
var EventEmitter = function () {
  function EventEmitter() {
    this._events = {};
  }
    EventEmitter.prototype.on = function (evt, callback, once) {
    if (!this._events[evt]) {
      this._events[evt] = [];
    }
    this._events[evt].push({
      callback: callback,
      once: !!once
    });
    return this;
  };
    EventEmitter.prototype.once = function (evt, callback) {
    return this.on(evt, callback, true);
  };
    EventEmitter.prototype.emit = function (evt) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var events = this._events[evt] || [];
    var wildcardEvents = this._events[WILDCARD] || [];
    
    var doEmit = function doEmit(es) {
      var length = es.length;
      for (var i = 0; i < length; i++) {
        if (!es[i]) {
          continue;
        }
        var _a = es[i],
          callback = _a.callback,
          once = _a.once;
        if (once) {
          es.splice(i, 1);
          if (es.length === 0) {
            delete _this._events[evt];
          }
          length--;
          i--;
        }
        callback.apply(_this, args);
      }
    };
    doEmit(events);
    doEmit(wildcardEvents);
  };
    EventEmitter.prototype.off = function (evt, callback) {
    if (!evt) {
      
      this._events = {};
    } else {
      if (!callback) {
        
        delete this._events[evt];
      } else {
        
        var events = this._events[evt] || [];
        var length_1 = events.length;
        for (var i = 0; i < length_1; i++) {
          if (events[i].callback === callback) {
            events.splice(i, 1);
            length_1--;
            i--;
          }
        }
        if (events.length === 0) {
          delete this._events[evt];
        }
      }
    }
    return this;
  };
    EventEmitter.prototype.getEvents = function () {
    return this._events;
  };
  return EventEmitter;
}();
var _default = EventEmitter;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var TooltipAction = function (_super) {
  (0, tslib_1.__extends)(TooltipAction, _super);
  function TooltipAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
    TooltipAction.prototype.show = function () {
    var context = this.context;
    var ev = context.event;
    var view = context.view;
    var isTooltipLocked = view.isTooltipLocked();
    if (isTooltipLocked) {
      
      return;
    }
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    
    var showDelay = (0, util_1.get)(context.view.getOptions(), 'tooltip.showDelay', 16);
    if (timeStamp - lastTimeStamp > showDelay) {
      var preLoc = this.location;
      var curLoc = {
        x: ev.x,
        y: ev.y
      };
      if (!preLoc || !(0, util_1.isEqual)(preLoc, curLoc)) {
        this.showTooltip(view, curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
    TooltipAction.prototype.hide = function () {
    var view = this.context.view;
    var tooltip = view.getController('tooltip');
    var _a = this.context.event,
      clientX = _a.clientX,
      clientY = _a.clientY;
    
    if (tooltip.isCursorEntered({
      x: clientX,
      y: clientY
    })) {
      return;
    }
    
    if (view.isTooltipLocked()) {
      return;
    }
    this.hideTooltip(view);
    this.location = null;
  };
  TooltipAction.prototype.showTooltip = function (view, point) {
    
    view.showTooltip(point);
  };
  TooltipAction.prototype.hideTooltip = function (view) {
    view.hideTooltip();
  };
  return TooltipAction;
}(base_1.default);
exports.default = TooltipAction;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return AreaGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(325);
 var _antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_5__);
 var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
 var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(278);
 var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_8__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Area', _antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_5___default.a);
var AreaGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(AreaGeom, _BaseGemo);
  var _super = _createSuper(AreaGeom);
  function AreaGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, AreaGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'area';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(AreaGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_6__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return LineGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(329);
 var _antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_5__);
 var _antv_g2_lib_geometry_shape_line_step__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(281);
 var _antv_g2_lib_geometry_shape_line_step__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_line_step__WEBPACK_IMPORTED_MODULE_6__);
 var _Base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerGeometry"])('Line', _antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_5___default.a);
var LineGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(LineGeom, _BaseGemo);
  var _super = _createSuper(LineGeom);
  function LineGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, LineGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'line';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(LineGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_7__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return PointGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(330);
 var _antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_5__);
 var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
 var _antv_g2_lib_geometry_shape_point_hollow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(470);
 var _antv_g2_lib_geometry_shape_point_hollow__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_point_hollow__WEBPACK_IMPORTED_MODULE_8__);
 var _antv_g2_lib_geometry_shape_point_image__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(471);
 var _antv_g2_lib_geometry_shape_point_image__WEBPACK_IMPORTED_MODULE_9___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_point_image__WEBPACK_IMPORTED_MODULE_9__);
 var _antv_g2_lib_geometry_shape_point_solid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(472);
 var _antv_g2_lib_geometry_shape_point_solid__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_point_solid__WEBPACK_IMPORTED_MODULE_10__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Point', _antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_5___default.a);
var PointGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(PointGeom, _BaseGemo);
  var _super = _createSuper(PointGeom);
  function PointGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PointGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'point';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(PointGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_6__[ "a"]);


 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLocale = exports.registerLocale = void 0;
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
var global_1 = __webpack_require__(187);
var LocaleMap = {};
function registerLocale(locale, localeObj) {
  LocaleMap[locale] = localeObj;
}
exports.registerLocale = registerLocale;
function getLocale(locale) {
  return {
    get: function get(key, obj) {
      return utils_1.template(util_1.get(LocaleMap[locale], key) || util_1.get(LocaleMap[global_1.GLOBAL.locale], key) || util_1.get(LocaleMap['en-US'], key) || key, obj);
    }
  };
}
exports.getLocale = getLocale;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return withContainer; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);
 var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);
 var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

function withContainer(Component) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ChartContainer';
  var Cls = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(function (props, ref) {
    var container = Object(react__WEBPACK_IMPORTED_MODULE_2__["useRef"])();
    var _useState = Object(react__WEBPACK_IMPORTED_MODULE_2__["useState"])(false),
      _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState, 2),
      inited = _useState2[0],
      setInited = _useState2[1];
    var _a = props,
      _a$className = _a.className,
      className = _a$className === void 0 ? "bizcharts" : _a$className,
      containerStyle = _a.containerStyle,
      options = __rest(_a, ["className", "containerStyle"]);
    Object(react__WEBPACK_IMPORTED_MODULE_2__["useEffect"])(function () {
      setInited(true);
    }, []);
    
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
      ref: container,
      className: className,
      
      style: object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        position: 'relative',
        height: props.height || '100%',
        width: props.width || '100%'
      }, containerStyle)
    }, inited ? react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
      ref: ref,
      container: container.current
    }, options)) : react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_2___default.a.Fragment, null));
  });
  Cls.displayName = name || Component.name;
  return Cls;
}
;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var arrayWithHoles = __webpack_require__(1033);
var iterableToArrayLimit = __webpack_require__(1034);
var unsupportedIterableToArray = __webpack_require__(481);
var nonIterableRest = __webpack_require__(1035);
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Area = void 0;
var tslib_1 = __webpack_require__(1);
var plot_1 = __webpack_require__(24);
var percent_1 = __webpack_require__(119);
var adaptor_1 = __webpack_require__(1125);
var constants_1 = __webpack_require__(1126);
var Area = function (_super) {
  tslib_1.__extends(Area, _super);
  function Area() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'area';
    return _this;
  }
    Area.getDefaultOptions = function () {
    return constants_1.DEFAULT_OPTIONS;
  };
    Area.prototype.getDefaultOptions = function () {
    return Area.getDefaultOptions();
  };
    Area.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
      isPercent = _a.isPercent,
      xField = _a.xField,
      yField = _a.yField;
    var _b = this,
      chart = _b.chart,
      options = _b.options;
    adaptor_1.meta({
      chart: chart,
      options: options
    });
    this.chart.changeData(percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent));
  };
    Area.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  return Area;
}(plot_1.Plot);
exports.Area = Area;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Heatmap = void 0;
var tslib_1 = __webpack_require__(1);
var plot_1 = __webpack_require__(24);
var adaptor_1 = __webpack_require__(1132);
var constant_1 = __webpack_require__(1133);

__webpack_require__(1134);
__webpack_require__(1135);
var Heatmap = function (_super) {
  tslib_1.__extends(Heatmap, _super);
  function Heatmap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'heatmap';
    return _this;
  }
    Heatmap.getDefaultOptions = function () {
    return constant_1.DEFAULT_OPTIONS;
  };
    Heatmap.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
    Heatmap.prototype.getDefaultOptions = function () {
    return Heatmap.getDefaultOptions();
  };
  return Heatmap;
}(plot_1.Plot);
exports.Heatmap = Heatmap;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rose = void 0;
var tslib_1 = __webpack_require__(1);
var plot_1 = __webpack_require__(24);
var adaptor_1 = __webpack_require__(1139);
var constant_1 = __webpack_require__(1140);
var Rose = function (_super) {
  tslib_1.__extends(Rose, _super);
  function Rose() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'rose';
    return _this;
  }
    Rose.getDefaultOptions = function () {
    return constant_1.DEFAULT_OPTIONS;
  };
    Rose.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
    Rose.prototype.getDefaultOptions = function () {
    return Rose.getDefaultOptions();
  };
    Rose.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  return Rose;
}(plot_1.Plot);
exports.Rose = Rose;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return pickEventName; });
 var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
 var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0__);


var BASE_EVENT_NAMES = ['mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'contextmenu', 'click'];
var EVENT_ACTION_NAMES = ['mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'contextmenu', 'click', 'show', 'hide', 'change'];
var RegExpEvent = new RegExp("^on(.*)(?=(".concat(EVENT_ACTION_NAMES.map(function (k) {
  return k.replace(/^\S/, function (s) {
    return s.toUpperCase();
  });
}).join('|'), "))"));
var pickEventName = function pickEventName(props) {
  var names = [];
  _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0___default()(props, function (v, k) {
    var event = k.match(/^on(.*)/);
    if (event) {
      var res = k.match(RegExpEvent);
      if (res) {
        var target = res[1].replace(/([A-Z])/g, "-$1").toLowerCase();
        if (target) {
          names.push([k, "".concat(target.replace('-', ''), ":").concat(res[2].toLowerCase())]);
        } else {
          names.push([k, res[2].toLowerCase()]);
        }
      } else {
        names.push([k, event[1].toLowerCase()]);
      }
    }
  });
  return names;
};
var DRAG_EVENT_NAMES = ['dragstart', 'drag', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop'];
var MOBILE_EVENT_NAMES = ['touchstart', 'touchmove', 'touchend'];
var LIFE_CIRCLE_NAMES = ['beforerender', 'afterrender', 'beforepaint', 'afterpaint', 'beforechangedata', 'afterchangedata', 'beforeclear', 'afterclear', 'beforedestroy'];
var LEGEND_EVENT_TARGETS = ['legend', 'legend-title', 'legend-item', 'legend-item-name', 'legend-item-Maker', 'legend-item-value'];
var GEOM_NAME = ['line', 'area', 'point', 'interval', 'polygon', 'edge', 'schema'];
var LEGEND_EVENT = ['legend:valuechanged'];
var AXIS_EVENT_TARGET = ['axis-label', 'axis-line', 'axis-tick', 'axis-title'];
var ANNOTATION_EVENT_TARGET = ['annotation', 'annotation-line', 'annotation-line-text', 'annotation-image', 'annotation-region', 'annotation-text'];
var TOOLTIP_EVENT = ['tooltip:show', 'tooltip:hide', 'tooltip:change'];

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isObjectLike = _interopRequireDefault(__webpack_require__(239));
var _isType = _interopRequireDefault(__webpack_require__(68));
var isPlainObject = function isPlainObject(value) {
    if (!(0, _isObjectLike.default)(value) || !(0, _isType.default)(value, 'Object')) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var _default = isPlainObject;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getStyle;
function getStyle(dom, name, defaultValue) {
  var v;
  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name]; 
  } catch (e) {
    
  } finally {
    v = v === undefined ? defaultValue : v;
  }
  return v;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = __webpack_require__(0);
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor = function isGradientColor(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

var createTmp = function createTmp() {
  var i = document.createElement('i');
  i.title = 'Web Colour Picker';
  i.style.display = 'none';
  document.body.appendChild(i);
  return i;
};

var getValue = function getValue(start, end, percent, index) {
  return start[index] + (end[index] - start[index]) * percent;
};

function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}

var rgb2arr = function rgb2arr(str) {
  return [parseInt(str.substr(1, 2), 16), parseInt(str.substr(3, 2), 16), parseInt(str.substr(5, 2), 16)];
};

var toHex = function toHex(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
};

var calColor = function calColor(points, percent) {
  var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
  var steps = points.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left = steps * fixedPercent - step;
  var start = points[step];
  var end = step === steps ? start : points[step + 1];
  return arr2rgb([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);
};


var iEl;
var toRGB = function toRGB(color) {
  
  if (color[0] === '#' && color.length === 7) {
    return color;
  }
  if (!iEl) {
    
    iEl = createTmp();
  }
  iEl.style.color = color;
  var rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function (s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
};
var gradient = function gradient(colors) {
  var colorArray = (0, _util.isString)(colors) ? colors.split('-') : colors;
  var points = (0, _util.map)(colorArray, function (color) {
    return rgb2arr(color.indexOf('#') === -1 ? toRGB(color) : color);
  });
  
  return function (percent) {
    return calColor(points, percent);
  };
};
var toCSSGradient = function toCSSGradient(gradientColor) {
  if (isGradientColor(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === 'l') {
      
      var arr = regexLG.exec(gradientColor);
      var angle = +arr[1] + 90; 
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle + "deg, ";
    } else if (gradientColor[0] === 'r') {
      
      cssColor_1 = 'radial-gradient(';
      var arr = regexRG.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop);
    (0, _util.each)(colorStops_1, function (item, index) {
      var itemArr = item.split(':');
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
      if (index !== colorStops_1.length - 1) {
        cssColor_1 += ', ';
      }
    });
    cssColor_1 += ')';
    return cssColor_1;
  }
  return gradientColor;
};
var _default = {
  rgb2arr: rgb2arr,
  gradient: gradient,
  toRGB: (0, _util.memoize)(toRGB),
  toCSSGradient: toCSSGradient
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = __webpack_require__(0);
var _register = __webpack_require__(425);
var Scale = function () {
  function Scale(cfg) {
        this.type = 'base';
        this.isCategory = false;
        this.isLinear = false;
        this.isContinuous = false;
        this.isIdentity = false;
    this.values = [];
    this.range = [0, 1];
    this.ticks = [];
    this.__cfg__ = cfg;
    this.initCfg();
    this.init();
  }
  
  Scale.prototype.translate = function (v) {
    return v;
  };
    Scale.prototype.change = function (cfg) {
    
    (0, _util.assign)(this.__cfg__, cfg);
    this.init();
  };
  Scale.prototype.clone = function () {
    return this.constructor(this.__cfg__);
  };
    Scale.prototype.getTicks = function () {
    var _this = this;
    return (0, _util.map)(this.ticks, function (tick, idx) {
      if ((0, _util.isObject)(tick)) {
        
        return tick;
      }
      return {
        text: _this.getText(tick, idx),
        tickValue: tick,
        value: _this.scale(tick)
      };
    });
  };
    Scale.prototype.getText = function (value, key) {
    var formatter = this.formatter;
    var res = formatter ? formatter(value, key) : value;
    if ((0, _util.isNil)(res) || !(0, _util.isFunction)(res.toString)) {
      return '';
    }
    return res.toString();
  };
  // 获取配置项中的值，当前 scale 上的值可能会被修改
  Scale.prototype.getConfig = function (key) {
    return this.__cfg__[key];
  };
  // scale初始化
  Scale.prototype.init = function () {
    (0, _util.assign)(this, this.__cfg__);
    this.setDomain();
    if ((0, _util.isEmpty)(this.getConfig('ticks'))) {
      this.ticks = this.calculateTicks();
    }
  };
  
  Scale.prototype.initCfg = function () {};
  Scale.prototype.setDomain = function () {};
  Scale.prototype.calculateTicks = function () {
    var tickMethod = this.tickMethod;
    var ticks = [];
    if ((0, _util.isString)(tickMethod)) {
      var method = (0, _register.getTickMethod)(tickMethod);
      if (!method) {
        throw new Error('There is no method to to calculate ticks!');
      }
      ticks = method(this);
    } else if ((0, _util.isFunction)(tickMethod)) {
      ticks = tickMethod(this);
    }
    return ticks;
  };
  
  Scale.prototype.rangeMin = function () {
    return this.range[0];
  };
  
  Scale.prototype.rangeMax = function () {
    return this.range[1];
  };
    Scale.prototype.calcPercent = function (value, min, max) {
    if ((0, _util.isNumber)(value)) {
      return (value - min) / (max - min);
    }
    return NaN;
  };
    Scale.prototype.calcValue = function (percent, min, max) {
    return min + percent * (max - min);
  };
  return Scale;
}();
var _default = Scale;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ellipsisLabel = ellipsisLabel;
exports.getLabelLength = getLabelLength;
exports.getMaxLabelWidth = getMaxLabelWidth;
exports.testLabel = testLabel;
var _util = __webpack_require__(0);
var _text = __webpack_require__(856);
var ELLIPSIS_CODE = "\u2026";
var ELLIPSIS_CODE_LENGTH = 2; 
var OPTIMIZE_THRESHOLD = 400;
function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function (label) {
    var text = label.attr('text');
    return (0, _util.isNil)(text) ? '' : "" + text;
  });
  var maxLen = 0;
  var maxIdx = 0;
  for (var i = 0; i < texts.length; i += 1) {
    var len = 0;
    for (var j = 0; j <= texts[i].length; j += 1) {
      var code = texts[i].charCodeAt(j);
      if (code >= 19968 && code <= 40869) {
        len += 2;
      } else {
        len += 1;
      }
    }
    if (len > maxLen) {
      maxLen = len;
      maxIdx = i;
    }
  }
  return labels[maxIdx].getBBox().width;
}
/** 获取最长的 label */
function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }
  var max = 0;
  (0, _util.each)(labels, function (label) {
    var bbox = label.getBBox();
    var width = bbox.width;
    if (max < width) {
      max = width;
    }
  });
  return max;
}
/** 获取label长度 */
function getLabelLength(isVertical, label) {
  var bbox = label.getCanvasBBox();
  return isVertical ? bbox.width : bbox.height;
}
/* label长度是否超过约束值 */
function testLabel(label, limitLength) {
  return label.getBBox().width < limitLength;
}
/** 处理 text shape 的自动省略 */
function ellipsisLabel(isVertical, label, limitLength, position) {
  var _a;
  if (position === void 0) {
    position = 'tail';
  }
  var text = (_a = label.attr('text')) !== null && _a !== void 0 ? _a : ''; // 避免出现null、undefined
  if (position === 'tail') {
    
    
    var font = (0, _util.pick)(label.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);
    var ellipsisText = (0, _util.getEllipsisText)(text, limitLength, font, '…');
    if (text !== ellipsisText) {
      label.attr('text', ellipsisText);
      label.set('tip', text);
      return true;
    }
    label.set('tip', null);
    return false;
  }
  var labelLength = getLabelLength(isVertical, label);
  var codeLength = (0, _text.strLen)(text);
  var ellipsisFlag = false;
  if (limitLength < labelLength) {
    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH; 
    var newText = void 0;
    if (reserveLength >= 0) {
      newText = (0, _text.ellipsisString)(text, reserveLength, position);
    } else {
      newText = ELLIPSIS_CODE;
    }
    if (newText) {
      label.attr('text', newText);
      ellipsisFlag = true;
    }
  }
  if (ellipsisFlag) {
    label.set('tip', text);
  } else {
    label.set('tip', null);
  }
  return ellipsisFlag;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Text = exports.Rect = exports.Polyline = exports.Polygon = exports.Path = exports.Marker = exports.Line = exports.Image = exports.Ellipse = exports.Circle = exports.Base = void 0;
var base_1 = __webpack_require__(71);
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return base_1.default;
  }
});
var circle_1 = __webpack_require__(900);
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return circle_1.default;
  }
});
var ellipse_1 = __webpack_require__(901);
Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return ellipse_1.default;
  }
});
var image_1 = __webpack_require__(902);
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return image_1.default;
  }
});
var line_1 = __webpack_require__(903);
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return line_1.default;
  }
});
var marker_1 = __webpack_require__(904);
Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return marker_1.default;
  }
});
var path_1 = __webpack_require__(905);
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return path_1.default;
  }
});
var polygon_1 = __webpack_require__(907);
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return polygon_1.default;
  }
});
var polyline_1 = __webpack_require__(908);
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return polyline_1.default;
  }
});
var rect_1 = __webpack_require__(909);
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return rect_1.default;
  }
});
var text_1 = __webpack_require__(912);
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return text_1.default;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeView = exports.getMergedRegion = exports.getRefreshRegion = exports.refreshElement = exports.drawPath = exports.clearChanged = exports.checkChildrenRefresh = exports.checkRefresh = exports.drawChildren = exports.applyAttrsToContext = void 0;
var util_1 = __webpack_require__(0);
var parse_1 = __webpack_require__(437);
var arc_params_1 = __webpack_require__(438);
var util_2 = __webpack_require__(51);
var ArrowUtil = __webpack_require__(182);
var SHAPE_ATTRS_MAP = {
  fill: 'fillStyle',
  stroke: 'strokeStyle',
  opacity: 'globalAlpha'
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === 'matrix' && v) {
      
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === 'lineDash' && context.setLineDash) {
      
      util_1.isArray(v) && context.setLineDash(v);
    } else {
      if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {
        
        
        v = parse_1.parseStyle(context, element, v);
      } else if (name_1 === 'globalAlpha') {
        
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
exports.applyAttrsToContext = applyAttrsToContext;
function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
exports.drawChildren = drawChildren;

function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get('refreshElements');
  
  util_1.each(refreshElements, function (el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    
    checkChildrenRefresh(children, region);
  }
}
exports.checkRefresh = checkRefresh;

function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      
      if (child.cfg.hasChanged) {
        
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
exports.checkChildrenRefresh = checkChildrenRefresh;


function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
exports.clearChanged = clearChanged;

function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    
    
    
    
    
    
    
    child.cfg.refresh = true;
    
    if (child.isGroup()) {
      setChildrenRefresh(child.get('children'), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && util_2.intersectRect(bbox, region);
  return isAllow;
}

function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path,
    startArrow = attrs.startArrow,
    endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0]; 
  var startMovePoint = [0, 0]; 
  var distance = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {
      
      var lastPath = path[i + 1];
      if (lastPath[0] === 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance.dx,
      dy = distance.dy;
    
    switch (command) {
      case 'M':
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case 'L':
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case 'Q':
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case 'C':
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case 'A':
        {
          var arcParams = void 0;
          
          if (arcParamsCache) {
            arcParams = arcParamsCache[i];
            if (!arcParams) {
              arcParams = arc_params_1.default(currentPoint, params);
              arcParamsCache[i] = arcParams;
            }
          } else {
            arcParams = arc_params_1.default(currentPoint, params);
          }
          var cx = arcParams.cx,
            cy = arcParams.cy,
            rx = arcParams.rx,
            ry = arcParams.ry,
            startAngle = arcParams.startAngle,
            endAngle = arcParams.endAngle,
            xRotation = arcParams.xRotation,
            sweepFlag = arcParams.sweepFlag;
          
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          break;
        }
      case 'Z':
        context.closePath();
        break;
      default:
        break;
    }
    
    if (command === 'Z') {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}
exports.drawPath = drawPath;

function refreshElement(element, changeType) {
  var canvas = element.get('canvas');
  
  if (canvas) {
    if (changeType === 'remove') {
      
      
      
      element._cacheCanvasBBox = element.get('cacheCanvasBBox');
    }
    
    if (!element.get('hasChanged')) {
      
      element.set('hasChanged', true);
      
      
      
      
      
      
      if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get('autoDraw')) {
          canvas.draw();
        }
      }
    }
  }
}
exports.refreshElement = refreshElement;
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get('cacheCanvasBBox');
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    
    if (validCache && validBBox) {
      region = util_2.mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    
    region = element['_cacheCanvasBBox'];
  }
  return region;
}
exports.getRefreshRegion = getRefreshRegion;
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  util_1.each(elements, function (el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: util_1.min(minXArr),
    minY: util_1.min(minYArr),
    maxX: util_1.max(maxXArr),
    maxY: util_1.max(maxYArr)
  };
}
exports.getMergedRegion = getMergedRegion;
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  
  if (!util_2.intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}
exports.mergeView = mergeView;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setClip = exports.setTransform = exports.setShadow = void 0;
var dom_1 = __webpack_require__(72);
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute('filter');
  } else {
    var id = context.find('filter', cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute('filter', "url(#" + id + ")");
  }
}
exports.setShadow = setShadow;
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform = [];
    for (var i = 0; i < 9; i += 3) {
      transform.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform = transform.join(',');
    if (transform.indexOf('NaN') === -1) {
      el.setAttribute('transform', "matrix(" + transform + ")");
    } else {
      console.warn('invalid matrix:', matrix);
    }
  }
}
exports.setTransform = setTransform;
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get('el');
  if (!clip) {
    el.removeAttribute('clip-path');
  } else if (clip && !el.hasAttribute('clip-path')) {
    dom_1.createDom(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute('clip-path', "url(#" + id + ")");
  }
}
exports.setClip = setClip;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerSymbols = void 0;
exports.MarkerSymbols = {
  hexagon: function hexagon(x, y, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [['M', x, y - r], ['L', x + diffX, y - r / 2], ['L', x + diffX, y + r / 2], ['L', x, y + r], ['L', x - diffX, y + r / 2], ['L', x - diffX, y - r / 2], ['Z']];
  },
  bowtie: function bowtie(x, y, r) {
    var diffY = r - 1.5;
    return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];
  },
  cross: function cross(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y + r], ['M', x + r, y - r], ['L', x - r, y + r]];
  },
  tick: function tick(x, y, r) {
    return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];
  },
  plus: function plus(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y], ['M', x, y - r], ['L', x, y + r]];
  },
  hyphen: function hyphen(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  line: function line(x, y, r) {
    return [['M', x, y - r], ['L', x, y + r]];
  }
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return _ellipse.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _image.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return _marker.default;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _path.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return _polyline.default;
  }
});
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return _rect.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return _text.default;
  }
});
var _base = _interopRequireDefault(__webpack_require__(73));
var _circle = _interopRequireDefault(__webpack_require__(952));
var _ellipse = _interopRequireDefault(__webpack_require__(953));
var _image = _interopRequireDefault(__webpack_require__(954));
var _line = _interopRequireDefault(__webpack_require__(955));
var _marker = _interopRequireDefault(__webpack_require__(956));
var _path = _interopRequireDefault(__webpack_require__(957));
var _polygon = _interopRequireDefault(__webpack_require__(959));
var _polyline = _interopRequireDefault(__webpack_require__(960));
var _rect = _interopRequireDefault(__webpack_require__(961));
var _text = _interopRequireDefault(__webpack_require__(964));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyAttrsToContext = applyAttrsToContext;
exports.checkChildrenRefresh = checkChildrenRefresh;
exports.checkRefresh = checkRefresh;
exports.clearChanged = clearChanged;
exports.drawChildren = drawChildren;
exports.drawPath = drawPath;
exports.getMergedRegion = getMergedRegion;
exports.getRefreshRegion = getRefreshRegion;
exports.mergeView = mergeView;
exports.refreshElement = refreshElement;
var _util = __webpack_require__(0);
var _parse = __webpack_require__(453);
var _arcParams = _interopRequireDefault(__webpack_require__(454));
var _util2 = __webpack_require__(53);
var ArrowUtil = _interopRequireWildcard(__webpack_require__(188));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var SHAPE_ATTRS_MAP = {
  fill: 'fillStyle',
  stroke: 'strokeStyle',
  opacity: 'globalAlpha'
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === 'matrix' && v) {
      
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === 'lineDash' && context.setLineDash) {
      
      (0, _util.isArray)(v) && context.setLineDash(v);
    } else {
      if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {
        
        
        v = (0, _parse.parseStyle)(context, element, v);
      } else if (name_1 === 'globalAlpha') {
        
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}

function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get('refreshElements');
  
  (0, _util.each)(refreshElements, function (el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    
    checkChildrenRefresh(children, region);
  }
}

function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      
      if (child.cfg.hasChanged) {
        
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}


function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}

function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    
    
    
    
    
    
    
    child.cfg.refresh = true;
    
    if (child.isGroup()) {
      setChildrenRefresh(child.get('children'), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && (0, _util2.intersectRect)(bbox, region);
  return isAllow;
}

function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path,
    startArrow = attrs.startArrow,
    endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0]; 
  var startMovePoint = [0, 0]; 
  var distance = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {
      
      var lastPath = path[i + 1];
      if (lastPath[0] === 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance.dx,
      dy = distance.dy;
    
    switch (command) {
      case 'M':
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case 'L':
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case 'Q':
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case 'C':
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case 'A':
        {
          var arcParams = void 0;
          
          if (arcParamsCache) {
            arcParams = arcParamsCache[i];
            if (!arcParams) {
              arcParams = (0, _arcParams.default)(currentPoint, params);
              arcParamsCache[i] = arcParams;
            }
          } else {
            arcParams = (0, _arcParams.default)(currentPoint, params);
          }
          var cx = arcParams.cx,
            cy = arcParams.cy,
            rx = arcParams.rx,
            ry = arcParams.ry,
            startAngle = arcParams.startAngle,
            endAngle = arcParams.endAngle,
            xRotation = arcParams.xRotation,
            sweepFlag = arcParams.sweepFlag;
          
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          break;
        }
      case 'Z':
        context.closePath();
        break;
      default:
        break;
    }
    
    if (command === 'Z') {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}

function refreshElement(element, changeType) {
  var canvas = element.get('canvas');
  
  if (canvas) {
    if (changeType === 'remove') {
      
      
      
      element._cacheCanvasBBox = element.get('cacheCanvasBBox');
    }
    
    if (!element.get('hasChanged')) {
      
      element.set('hasChanged', true);
      
      
      
      
      
      
      if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get('autoDraw')) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get('cacheCanvasBBox');
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    
    if (validCache && validBBox) {
      region = (0, _util2.mergeRegion)(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    
    region = element['_cacheCanvasBBox'];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  (0, _util.each)(elements, function (el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: (0, _util.min)(minXArr),
    minY: (0, _util.min)(minYArr),
    maxX: (0, _util.max)(maxXArr),
    maxY: (0, _util.max)(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  
  if (!(0, _util2.intersectRect)(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setClip = setClip;
exports.setShadow = setShadow;
exports.setTransform = setTransform;
var _dom = __webpack_require__(74);
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute('filter');
  } else {
    var id = context.find('filter', cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute('filter', "url(#" + id + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform = [];
    for (var i = 0; i < 9; i += 3) {
      transform.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform = transform.join(',');
    if (transform.indexOf('NaN') === -1) {
      el.setAttribute('transform', "matrix(" + transform + ")");
    } else {
      console.warn('invalid matrix:', matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get('el');
  if (!clip) {
    el.removeAttribute('clip-path');
  } else if (clip && !el.hasAttribute('clip-path')) {
    (0, _dom.createDom)(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute('clip-path', "url(#" + id + ")");
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRectWithCornerRadius = exports.getFunnelPath = exports.getIntervalRectPath = exports.getBackgroundRectPath = exports.parseRadius = exports.getRectPath = exports.getRectPoints = void 0;
var util_1 = __webpack_require__(0);
var graphics_1 = __webpack_require__(46);
function getRectPoints(pointInfo) {
  var x = pointInfo.x,
    y = pointInfo.y,
    y0 = pointInfo.y0,
    size = pointInfo.size;
  
  
  
  
  
  var yMin;
  var yMax;
  if ((0, util_1.isArray)(y)) {
    yMin = y[0], yMax = y[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMin;
  var xMax;
  if ((0, util_1.isArray)(x)) {
    xMin = x[0], xMax = x[1];
  } else {
    xMin = x - size / 2;
    xMax = x + size / 2;
  }
  var points = [{
    x: xMin,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }];
  
  
  
  
  points.push({
    x: xMax,
    y: yMax
  }, {
    x: xMax,
    y: yMin
  });
  return points;
}
exports.getRectPoints = getRectPoints;
function getRectPath(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path = [];
  var firstPoint = points[0];
  path.push(['M', firstPoint.x, firstPoint.y]);
  for (var i = 1, len = points.length; i < len; i++) {
    path.push(['L', points[i].x, points[i].y]);
  }
  
  if (isClosed) {
    path.push(['L', firstPoint.x, firstPoint.y]); 
    path.push(['z']);
  }
  return path;
}
exports.getRectPath = getRectPath;
function parseRadius(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if ((0, util_1.isArray)(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  
  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }
  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }
  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
exports.parseRadius = parseRadius;
function getBackgroundRectPath(cfg, points, coordinate) {
  var path = [];
  if (coordinate.isRect) {
    var p0 = coordinate.isTransposed ? {
      x: coordinate.start.x,
      y: points[0].y
    } : {
      x: points[0].x,
      y: coordinate.start.y
    };
    var p1 = coordinate.isTransposed ? {
      x: coordinate.end.x,
      y: points[2].y
    } : {
      x: points[3].x,
      y: coordinate.end.y
    };
    
    var radius = (0, util_1.get)(cfg, ['background', 'style', 'radius']);
    if (radius) {
      var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
      var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();
      var _a = parseRadius(radius, Math.min(width, height)),
        r1 = _a[0],
        r2 = _a[1],
        r3 = _a[2],
        r4 = _a[3];
      path.push(['M', p0.x, p1.y + r1]);
      r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p0.x + r1, p1.y]);
      path.push(['L', p1.x - r2, p1.y]);
      r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p1.x, p1.y + r2]);
      path.push(['L', p1.x, p0.y - r3]);
      r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p1.x - r3, p0.y]);
      path.push(['L', p0.x + r4, p0.y]);
      r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    } else {
      path.push(['M', p0.x, p0.y]);
      path.push(['L', p1.x, p0.y]);
      path.push(['L', p1.x, p1.y]);
      path.push(['L', p0.x, p1.y]);
      path.push(['L', p0.x, p0.y]);
    }
    path.push(['z']);
  }
  if (coordinate.isPolar) {
    var center = coordinate.getCenter();
    var _b = (0, graphics_1.getAngle)(cfg, coordinate),
      startAngle = _b.startAngle,
      endAngle = _b.endAngle;
    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {
      
      path = (0, graphics_1.getSectorPath)(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);
    } else {
      var pow = function pow(v) {
        return Math.pow(v, 2);
      };
      var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));
      var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));
      
      path = (0, graphics_1.getSectorPath)(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);
    }
  }
  return path;
}
exports.getBackgroundRectPath = getBackgroundRectPath;
function getIntervalRectPath(points, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === 'rect';
  var path = [];
  var r = (points[2].x - points[1].x) / 2;
  var ry = coor.isTransposed ? r * height / width : r * width / height;
  if (lineCap === 'round') {
    if (isRect) {
      path.push(['M', points[0].x, points[0].y + ry]);
      path.push(['L', points[1].x, points[1].y - ry]);
      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
      path.push(['L', points[3].x, points[3].y + ry]);
      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
    } else {
      path.push(['M', points[0].x, points[0].y]);
      path.push(['L', points[1].x, points[1].y]);
      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);
      path.push(['L', points[3].x, points[3].y]);
      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);
    }
    path.push(['z']);
  } else {
    path = getRectPath(points);
  }
  return path;
}
exports.getIntervalRectPath = getIntervalRectPath;
function getFunnelPath(points, nextPoints, isPyramid) {
  var path = [];
  if (!(0, util_1.isNil)(nextPoints)) {
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);
  } else if (isPyramid) {
    
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ['Z']);
  } else {
    
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);
  }
  return path;
}
exports.getFunnelPath = getFunnelPath;
function getRectWithCornerRadius(points, coordinate, radius) {
  var _a, _b, _c, _d;
  
  var p0 = points[0],
    p1 = points[1],
    p2 = points[2],
    p3 = points[3];
  var _e = [0, 0, 0, 0],
    r1 = _e[0],
    r2 = _e[1],
    r3 = _e[2],
    r4 = _e[3];
    if (p0.y < p1.y ) {
    p1 = points[0], p0 = points[1], p3 = points[2], p2 = points[3];
    _a = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r4 = _a[0], r3 = _a[1], r2 = _a[2], r1 = _a[3];
  } else {
    _b = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _b[0], r2 = _b[1], r3 = _b[2], r4 = _b[3];
  }
    if (coordinate.isTransposed) {
    p0 = points[0], p3 = points[1], p2 = points[2], p1 = points[3];
    if (points[0].x > points[1].x ) {
      p3 = points[0], p0 = points[1], p1 = points[2], p2 = points[3];
      _c = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _c[0], r4 = _c[1], r3 = _c[2], r2 = _c[3];
    } else {
      _d = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r2 = _d[0], r3 = _d[1], r4 = _d[2], r1 = _d[3];
    }
  }
  var path = [];
  path.push(['M', p1.x, p1.y + r1]);
  r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
  path.push(['L', p2.x - r2, p2.y]);
  r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
  path.push(['L', p3.x, p3.y - r3]);
  r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
  path.push(['L', p0.x + r4, p0.y]);
  r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
  path.push(['L', p1.x, p1.y + r1]);
  path.push(['z']);
  return path;
}
exports.getRectWithCornerRadius = getRectWithCornerRadius;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var util_2 = __webpack_require__(31);
var util_3 = __webpack_require__(31);
var ListState = function (_super) {
  (0, tslib_1.__extends)(ListState, _super);
  function ListState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = '';
    _this.ignoreItemStates = [];
    return _this;
  }
  /** 获取触发的列表组件 */
  ListState.prototype.getTriggerListInfo = function () {
    var delegateObject = (0, util_3.getDelegationObject)(this.context);
    var info = null;
    if ((0, util_3.isList)(delegateObject)) {
      info = {
        item: delegateObject.item,
        list: delegateObject.component
      };
    }
    return info;
  };
  // 获取所有允许执行 Action 的组件
  ListState.prototype.getAllowComponents = function () {
    var _this = this;
    var view = this.context.view;
    var components = (0, util_2.getComponents)(view);
    var rst = [];
    (0, util_1.each)(components, function (component) {
      if (component.isList() && _this.allowSetStateByElement(component)) {
        rst.push(component);
      }
    });
    return rst;
  };
  /** 是否存在指定的状态 */
  ListState.prototype.hasState = function (list, item) {
    return list.hasState(item, this.stateName);
  };
  /** 清理组件的状态 */
  ListState.prototype.clearAllComponentsState = function () {
    var _this = this;
    var components = this.getAllowComponents();
    (0, util_1.each)(components, function (component) {
      component.clearItemsState(_this.stateName);
    });
  };
  // 不是所有的 component 都能进行 active，目前仅支持分类 scale 对应的组件
  ListState.prototype.allowSetStateByElement = function (component) {
    var field = component.get('field');
    if (!field) {
      return false;
    }
    if (this.cfg && this.cfg.componentNames) {
      var name_1 = component.get('name');
      
      if (this.cfg.componentNames.indexOf(name_1) === -1) {
        return false;
      }
    }
    var view = this.context.view;
    var scale = (0, util_3.getScaleByField)(view, field);
    return scale && scale.isCategory;
  };
  
  ListState.prototype.allowSetStateByItem = function (item, list) {
    var ignoreStates = this.ignoreItemStates;
    if (ignoreStates.length) {
      var filterStates = ignoreStates.filter(function (state) {
        return list.hasState(item, state);
      });
      return filterStates.length === 0;
    }
    return true; 
  };
  
  ListState.prototype.setStateByElement = function (component, element, enable) {
    var field = component.get('field');
    var view = this.context.view;
    var scale = (0, util_3.getScaleByField)(view, field);
    var value = (0, util_3.getElementValue)(element, field);
    var text = scale.getText(value);
    this.setItemsState(component, text, enable);
  };
  
  ListState.prototype.setStateEnable = function (enable) {
    var _this = this;
    var element = (0, util_3.getCurrentElement)(this.context);
    if (element) {
      
      var components = this.getAllowComponents();
      (0, util_1.each)(components, function (component) {
        _this.setStateByElement(component, element, enable);
      });
    } else {
      
      var delegateObject = (0, util_3.getDelegationObject)(this.context);
      if ((0, util_3.isList)(delegateObject)) {
        var item = delegateObject.item,
          component = delegateObject.component;
        if (this.allowSetStateByElement(component) && this.allowSetStateByItem(item, component)) {
          this.setItemState(component, item, enable);
        }
      }
    }
  };
  
  ListState.prototype.setItemsState = function (list, name, enable) {
    var _this = this;
    var items = list.getItems();
    (0, util_1.each)(items, function (item) {
      if (item.name === name) {
        _this.setItemState(list, item, enable);
      }
    });
  };
  
  ListState.prototype.setItemState = function (list, item, enable) {
    list.setItemState(item, this.stateName, enable);
  };
    ListState.prototype.setState = function () {
    this.setStateEnable(true);
  };
    ListState.prototype.reset = function () {
    this.setStateEnable(false);
  };
    ListState.prototype.toggle = function () {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list = triggerInfo.list,
        item = triggerInfo.item;
      var enable = this.hasState(list, item);
      this.setItemState(list, item, !enable);
    }
  };
    ListState.prototype.clear = function () {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      triggerInfo.list.clearItemsState(this.stateName);
    } else {
      this.clearAllComponentsState();
    }
  };
  return ListState;
}(base_1.default);
exports.default = ListState;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeObservers = void 0;
var resizeObservers = [];
exports.resizeObservers = resizeObservers;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pattern = void 0;
var tslib_1 = __webpack_require__(1);
var g2_1 = __webpack_require__(14);
var util_1 = __webpack_require__(0);
var pattern_1 = __webpack_require__(1070);
var utils_1 = __webpack_require__(15);
function pattern(key) {
  var _this = this;
  return function (params) {
    var _a;
    var options = params.options,
      chart = params.chart;
    var patternOption = options.pattern;
    
    if (!patternOption) {
      return params;
    }
        var style = function style(datum) {
      var _a, _b, _c;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var defaultColor = chart.getTheme().defaultColor;
      var color = defaultColor;
      var colorAttribute = (_b = (_a = chart.geometries) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getAttribute('color');
      if (colorAttribute) {
        var colorField = colorAttribute.getFields()[0];
        var seriesValue = util_1.get(datum, colorField);
        color = g2_1.Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
      }
      var pattern = patternOption;
      
      if (typeof patternOption === 'function') {
        pattern = patternOption.call(_this, datum, color);
      }
      
      if (pattern instanceof CanvasPattern === false) {
        
        pattern = pattern_1.getCanvasPattern(utils_1.deepAssign({}, {
          cfg: {
            backgroundColor: color
          }
        }, pattern));
      }
      var styleOption = options[key];
      return tslib_1.__assign(tslib_1.__assign({}, typeof styleOption === 'function' ? styleOption.call.apply(styleOption, tslib_1.__spreadArrays([_this, datum], args)) : styleOption || {}), {
        fill: pattern || color
      });
    };
    return utils_1.deepAssign({}, params, {
      options: (_a = {}, _a[key] = style, _a)
    });
  };
}
exports.pattern = pattern;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.DEFAULT_TOOLTIP_OPTIONS = exports.Y_FIELD = exports.X_FIELD = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
exports.X_FIELD = 'x';
exports.Y_FIELD = 'y';
exports.DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function customContent(x, data) {
    return "" + util_1.get(data, [0, 'data', 'y'], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: '<span>{value}</span>',
  domStyles: {
    'g2-tooltip': {
      padding: '2px 4px',
      fontSize: '10px'
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: 'x'
  }
};
exports.DEFAULT_OPTIONS = {
  appendPadding: 2,
  tooltip: tslib_1.__assign({}, exports.DEFAULT_TOOLTIP_OPTIONS),
  animation: {}
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
    node,
    i = -1,
    n = nodes.length,
    k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Y_FIELD = exports.X_FIELD = exports.DEFAULT_TOOLTIP_OPTIONS = exports.DEFAULT_OPTIONS = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var X_FIELD = 'x';
exports.X_FIELD = X_FIELD;
var Y_FIELD = 'y';
exports.Y_FIELD = Y_FIELD;
var DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function customContent(x, data) {
    return "" + (0, _util.get)(data, [0, 'data', 'y'], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: '<span>{value}</span>',
  domStyles: {
    'g2-tooltip': {
      padding: '2px 4px',
      fontSize: '10px'
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: 'x'
  }
};
exports.DEFAULT_TOOLTIP_OPTIONS = DEFAULT_TOOLTIP_OPTIONS;
var DEFAULT_OPTIONS = {
  appendPadding: 2,
  tooltip: (0, _tslib.__assign)({}, DEFAULT_TOOLTIP_OPTIONS),
  animation: {}
};
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NODE_INDEX_FIELD = exports.NODE_ANCESTORS_FIELD = exports.CHILD_NODE_COUNT = void 0;
exports.getAllNodes = getAllNodes;
exports.getField = getField;
var _util = __webpack_require__(0);
var NODE_INDEX_FIELD = 'nodeIndex';
exports.NODE_INDEX_FIELD = NODE_INDEX_FIELD;
var CHILD_NODE_COUNT = 'childNodeCount';
exports.CHILD_NODE_COUNT = CHILD_NODE_COUNT;
var NODE_ANCESTORS_FIELD = 'nodeAncestor';
exports.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
var INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!';
function getField(options, defaultField) {
  var field = options.field,
    fields = options.fields;
  if ((0, _util.isString)(field)) {
    return field;
  }
  if ((0, _util.isArray)(field)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field[0];
  }
  console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");
  if ((0, _util.isString)(fields)) {
    return fields;
  }
  if ((0, _util.isArray)(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
  var nodes = [];
  if (root && root.each) {
    var parent_1;
    var index_1;
    
    root.each(function (node) {
      var _a, _b;
      if (node.parent !== parent_1) {
        parent_1 = node.parent;
        index_1 = 0;
      } else {
        index_1 += 1;
      }
      var ancestors = (0, _util.filter)((((_a = node.ancestors) === null || _a === void 0 ? void 0 : _a.call(node)) || []).map(function (d) {
        return nodes.find(function (n) {
          return n.name === d.name;
        }) || d;
      }), function (_a) {
        var depth = _a.depth;
        return depth > 0 && depth < node.depth;
      });
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index_1;
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    
    root.eachNode(function (node) {
      nodes.push(node);
    });
  }
  return nodes;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var constant_1 = __webpack_require__(21);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
var element_1 = (0, tslib_1.__importDefault)(__webpack_require__(269));
__webpack_require__(276);
var is_model_change_1 = __webpack_require__(449);
var diff_1 = __webpack_require__(450);
var Path = function (_super) {
  (0, tslib_1.__extends)(Path, _super);
  function Path(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = 'path';
    _this.shapeType = 'line';
    var _a = cfg.connectNulls,
      connectNulls = _a === void 0 ? false : _a,
      _b = cfg.showSinglePoint,
      showSinglePoint = _b === void 0 ? true : _b;
    _this.connectNulls = connectNulls;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
    Path.prototype.updateElements = function (mappingDataArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    
    var keyData = new Map();
    var keyIndex = new Map();
    var keys = [];
    var index = 0;
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      var key = this.getElementId(mappingData);
      keys.push(key);
      keyData.set(key, mappingData);
      keyIndex.set(key, index);
      index++;
    }
    this.elements = new Array(index);
    var _a = (0, diff_1.diff)(this.lastElementsMap, keys),
      added = _a.added,
      updated = _a.updated,
      removed = _a.removed;
    for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
      var key = added_1[_i];
      var mappingData = keyData.get(key);
      var shapeFactory = this.getShapeFactory();
      var shapeCfg = this.getShapeInfo(mappingData);
      var i = keyIndex.get(key);
      var element = new element_1.default({
        shapeFactory: shapeFactory,
        container: this.container,
        offscreenGroup: this.getOffscreenGroup(),
        elementIndex: i
      });
      element.geometry = this;
      element.animate = this.animateOption;
      element.draw(shapeCfg, isUpdate); 
      this.elementsMap[key] = element;
      this.elements[i] = element;
    }
    for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
      var key = updated_1[_b];
      var mappingData = keyData.get(key);
      var element = this.lastElementsMap[key];
      var i = keyIndex.get(key);
      var shapeCfg = this.getShapeInfo(mappingData);
      var preShapeCfg = element.getModel();
      if (this.isCoordinateChanged || (0, is_model_change_1.isModelChange)(preShapeCfg, shapeCfg)) {
        element.animate = this.animateOption;
        
        element.update(shapeCfg); 
      }

      this.elementsMap[key] = element;
      this.elements[i] = element;
    }
    for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
      var key = removed_1[_c];
      var element = this.lastElementsMap[key];
      
      element.animate = this.animateOption;
      element.destroy();
    }
  };
    Path.prototype.getPointsAndData = function (mappingData) {
    var points = [];
    var data = [];
    for (var i = 0, len = mappingData.length; i < len; i++) {
      var obj = mappingData[i];
      points.push({
        x: obj.x,
        y: obj.y
      });
      data.push(obj[constant_1.FIELD_ORIGIN]);
    }
    return {
      points: points,
      data: data
    };
  };
  Path.prototype.getShapeInfo = function (mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var _a = this.getPointsAndData(mappingData),
      points = _a.points,
      data = _a.data;
    shapeCfg.mappingData = mappingData;
    shapeCfg.data = data;
    shapeCfg.isStack = !!this.getAdjust('stack');
    shapeCfg.points = points;
    shapeCfg.connectNulls = this.connectNulls;
    shapeCfg.showSinglePoint = this.showSinglePoint;
    return shapeCfg;
  };
  return Path;
}(base_1.default);
exports.default = Path;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STATUS_ACTIVE = exports.STATUS_UNACTIVE = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(31);
var highlight_util_1 = __webpack_require__(287);
var state_1 = (0, tslib_1.__importDefault)(__webpack_require__(283));
var constant_1 = __webpack_require__(21);
exports.STATUS_UNACTIVE = constant_1.ELEMENT_STATE.INACTIVE;
exports.STATUS_ACTIVE = constant_1.ELEMENT_STATE.ACTIVE;
var ElementHighlight = function (_super) {
  (0, tslib_1.__extends)(ElementHighlight, _super);
  function ElementHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = exports.STATUS_ACTIVE;
    return _this;
  }
  
  ElementHighlight.prototype.setElementsStateByItem = function (elements, field, item, enable) {
    var _this = this;
    var callback = function callback(el) {
      return _this.isMathItem(el, field, item);
    };
    this.setHighlightBy(elements, callback, enable);
  };
  
  ElementHighlight.prototype.setElementHighlight = function (el, callback) {
    if (callback(el)) {
      if (el.hasState(exports.STATUS_UNACTIVE)) {
        el.setState(exports.STATUS_UNACTIVE, false);
      }
      el.setState(exports.STATUS_ACTIVE, true);
    } else if (!el.hasState(exports.STATUS_ACTIVE)) {
      el.setState(exports.STATUS_UNACTIVE, true);
    }
  };
  ElementHighlight.prototype.setHighlightBy = function (elements, callback, enable) {
    var _this = this;
    if (enable) {
      
      
      (0, util_1.each)(elements, function (el) {
        _this.setElementHighlight(el, callback);
      });
    } else {
      
      var activeElements = (0, util_2.getElementsByState)(this.context.view, exports.STATUS_ACTIVE);
      var allCancel_1 = true;
      
      (0, util_1.each)(activeElements, function (el) {
        if (!callback(el)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        
        this.clear();
      } else {
        
        
        (0, util_1.each)(elements, function (el) {
          if (callback(el)) {
            if (el.hasState(exports.STATUS_ACTIVE)) {
              el.setState(exports.STATUS_ACTIVE, false);
            }
            el.setState(exports.STATUS_UNACTIVE, true);
          }
        });
      }
    }
  };
  
  ElementHighlight.prototype.setElementState = function (element, enable) {
    var view = this.context.view;
    var elements = (0, util_2.getElements)(view);
    this.setHighlightBy(elements, function (el) {
      return element === el;
    }, enable);
  };
  ElementHighlight.prototype.highlight = function () {
    this.setState();
  };
  
  ElementHighlight.prototype.clear = function () {
    var view = this.context.view;
    (0, highlight_util_1.clearHighlight)(view);
  };
  return ElementHighlight;
}(state_1.default);
exports.default = ElementHighlight;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modifyCSS = exports.createDom = exports.removeDom = exports.getChartSize = void 0;
var constant_1 = __webpack_require__(21);
function getElementSize(ele) {
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function isNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}
function getChartSize(ele, autoFit, width, height) {
  var w = width;
  var h = height;
  if (autoFit) {
    var size = getElementSize(ele);
    w = size.width ? size.width : w;
    h = size.height ? size.height : h;
  }
  return {
    width: Math.max(isNumber(w) ? w : constant_1.MIN_CHART_WIDTH, constant_1.MIN_CHART_WIDTH),
    height: Math.max(isNumber(h) ? h : constant_1.MIN_CHART_HEIGHT, constant_1.MIN_CHART_HEIGHT)
  };
}
exports.getChartSize = getChartSize;
function removeDom(dom) {
  var parent = dom.parentNode;
  if (parent) {
    parent.removeChild(dom);
  }
}
exports.removeDom = removeDom;
var dom_util_1 = __webpack_require__(96);
Object.defineProperty(exports, "createDom", {
  enumerable: true,
  get: function get() {
    return dom_util_1.createDom;
  }
});
Object.defineProperty(exports, "modifyCSS", {
  enumerable: true,
  get: function get() {
    return dom_util_1.modifyCSS;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.antvLight = exports.createLightStyleSheet = void 0;
var BLACK_COLORS = {
  100: '#000',
  95: '#0D0D0D',
  85: '#262626',
  65: '#595959',
  45: '#8C8C8C',
  25: '#BFBFBF',
  15: '#D9D9D9',
  6: '#F0F0F0'
};
var WHITE_COLORS = {
  100: '#FFFFFF',
  95: '#F2F2F2',
  85: '#D9D9D9',
  65: '#A6A6A6',
  45: '#737373',
  25: '#404040',
  15: '#262626',
  6: '#0F0F0F'
};
var QUALITATIVE_10 = ['#5B8FF9', '#5AD8A6', '#5D7092', '#F6BD16', '#6F5EF9', '#6DC8EC', '#945FB9', '#FF9845', '#1E9493', '#FF99C3'];
var QUALITATIVE_20 = ['#5B8FF9', '#CDDDFD', '#5AD8A6', '#CDF3E4', '#5D7092', '#CED4DE', '#F6BD16', '#FCEBB9', '#6F5EF9', '#D3CEFD', '#6DC8EC', '#D3EEF9', '#945FB9', '#DECFEA', '#FF9845', '#FFE0C7', '#1E9493', '#BBDEDE', '#FF99C3', '#FFE0ED'];
var SINGLE_SEQUENCE = ['#B8E1FF', '#9AC5FF', '#7DAAFF', '#5B8FF9', '#3D76DD', '#085EC0', '#0047A5', '#00318A', '#001D70'];
var createLightStyleSheet = function createLightStyleSheet(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a = cfg.backgroundColor,
    backgroundColor = _a === void 0 ? 'transparent' : _a,
    _b = cfg.subColor,
    subColor = _b === void 0 ? 'rgba(0,0,0,0.05)' : _b,
    _c = cfg.paletteQualitative10,
    paletteQualitative10 = _c === void 0 ? QUALITATIVE_10 : _c,
    _d = cfg.paletteQualitative20,
    paletteQualitative20 = _d === void 0 ? QUALITATIVE_20 : _d,
    _e = cfg.paletteSemanticRed,
    paletteSemanticRed = _e === void 0 ? '#F4664A' : _e,
    _f = cfg.paletteSemanticGreen,
    paletteSemanticGreen = _f === void 0 ? '#30BF78' : _f,
    _g = cfg.paletteSemanticYellow,
    paletteSemanticYellow = _g === void 0 ? '#FAAD14' : _g,
    _h = cfg.paletteSequence,
    paletteSequence = _h === void 0 ? SINGLE_SEQUENCE : _h,
    _j = cfg.fontFamily,
    fontFamily = _j === void 0 ? "\"Segoe UI\", Roboto, \"Helvetica Neue\", Arial,\n    \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"" : _j;
  var _k = cfg.brandColor,
    brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
  return {
        backgroundColor: backgroundColor,
        brandColor: brandColor,
        subColor: subColor,
        paletteQualitative10: paletteQualitative10,
        paletteQualitative20: paletteQualitative20,
        paletteSemanticRed: paletteSemanticRed,
        paletteSemanticGreen: paletteSemanticGreen,
        paletteSemanticYellow: paletteSemanticYellow,
        paletteSequence: paletteSequence,
        fontFamily: fontFamily,
    
        axisLineBorderColor: BLACK_COLORS[25],
        axisLineBorder: 1,
        axisLineDash: null,
        axisTitleTextFillColor: BLACK_COLORS[65],
        axisTitleTextFontSize: 12,
        axisTitleTextLineHeight: 12,
        axisTitleTextFontWeight: 'normal',
        axisTitleSpacing: 12,
        axisTickLineBorderColor: BLACK_COLORS[25],
        axisTickLineLength: 4,
        axisTickLineBorder: 1,
        axisSubTickLineBorderColor: BLACK_COLORS[15],
        axisSubTickLineLength: 2,
        axisSubTickLineBorder: 1,
        axisLabelFillColor: BLACK_COLORS[45],
        axisLabelFontSize: 12,
        axisLabelLineHeight: 12,
        axisLabelFontWeight: 'normal',
        axisLabelOffset: 8,
        axisGridBorderColor: BLACK_COLORS[15],
        axisGridBorder: 1,
        axisGridLineDash: null,
    
        legendTitleTextFillColor: BLACK_COLORS[45],
        legendTitleTextFontSize: 12,
        legendTitleTextLineHeight: 21,
        legendTitleTextFontWeight: 'normal',
        legendMarkerColor: brandColor,
        legendMarkerSpacing: 8,
        legendMarkerSize: 4,
        legendCircleMarkerSize: 4,
        legendSquareMarkerSize: 4,
        legendLineMarkerSize: 5,
        legendItemNameFillColor: BLACK_COLORS[65],
        legendItemNameFontSize: 12,
        legendItemNameLineHeight: 12,
        legendItemNameFontWeight: 'normal',
        legendItemSpacing: 24,
        legendItemMarginBottom: 12,
        legendPadding: [8, 8, 8, 8],
        legendHorizontalPadding: [8, 0, 8, 0],
        legendVerticalPadding: [0, 8, 0, 8],
    
        legendPageNavigatorMarkerSize: 12,
        legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[100],
        legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
        legendPageNavigatorMarkerFillColor: BLACK_COLORS[100],
        legendPageNavigatorMarkerFillOpacity: 1,
        legendPageNavigatorTextFillColor: BLACK_COLORS[45],
        legendPageNavigatorTextFontSize: 12,
        sliderRailFillColor: BLACK_COLORS[15],
        sliderRailBorder: 0,
        sliderRailBorderColor: null,
        sliderRailWidth: 100,
        sliderRailHeight: 12,
        sliderLabelTextFillColor: BLACK_COLORS[45],
        sliderLabelTextFontSize: 12,
        sliderLabelTextLineHeight: 12,
        sliderLabelTextFontWeight: 'normal',
        sliderHandlerFillColor: BLACK_COLORS[6],
        sliderHandlerWidth: 10,
        sliderHandlerHeight: 14,
        sliderHandlerBorder: 1,
        sliderHandlerBorderColor: BLACK_COLORS[25],
    
        annotationArcBorderColor: BLACK_COLORS[15],
        annotationArcBorder: 1,
        annotationLineBorderColor: BLACK_COLORS[25],
        annotationLineBorder: 1,
        annotationLineDash: null,
        annotationTextFillColor: BLACK_COLORS[65],
        annotationTextFontSize: 12,
        annotationTextLineHeight: 12,
        annotationTextFontWeight: 'normal',
        annotationTextBorderColor: null,
        annotationTextBorder: 0,
        annotationRegionFillColor: BLACK_COLORS[100],
        annotationRegionFillOpacity: 0.06,
        annotationRegionBorder: 0,
        annotationRegionBorderColor: null,
        annotationDataMarkerLineLength: 16,
    
        tooltipCrosshairsBorderColor: BLACK_COLORS[25],
        tooltipCrosshairsBorder: 1,
        tooltipCrosshairsLineDash: null,
        tooltipContainerFillColor: 'rgb(255, 255, 255)',
    tooltipContainerFillOpacity: 0.95,
        tooltipContainerShadow: '0px 0px 10px #aeaeae',
        tooltipContainerBorderRadius: 3,
        tooltipTextFillColor: BLACK_COLORS[65],
        tooltipTextFontSize: 12,
        tooltipTextLineHeight: 12,
        tooltipTextFontWeight: 'bold',
    
        labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: '#2c3542',
    labelFillColorLight: '#ffffff',
        labelFontSize: 12,
        labelLineHeight: 12,
        labelFontWeight: 'normal',
        labelBorderColor: null,
        labelBorder: 0,
        innerLabelFillColor: WHITE_COLORS[100],
        innerLabelFontSize: 12,
        innerLabelLineHeight: 12,
        innerLabelFontWeight: 'normal',
        innerLabelBorderColor: null,
        innerLabelBorder: 0,
        overflowLabelFillColor: BLACK_COLORS[65],
        overflowLabelFontSize: 12,
        overflowLabelLineHeight: 12,
        overflowLabelFontWeight: 'normal',
        overflowLabelBorderColor: WHITE_COLORS[100],
        overflowLabelBorder: 1,
        labelLineBorder: 1,
        labelLineBorderColor: BLACK_COLORS[25],
    
        cSliderRailHieght: 16,
        cSliderBackgroundFillColor: '#416180',
        cSliderBackgroundFillOpacity: 0.05,
        cSliderForegroundFillColor: '#5B8FF9',
        cSliderForegroundFillOpacity: 0.15,
    
        cSliderHandlerHeight: 24,
        cSliderHandlerWidth: 10,
        cSliderHandlerFillColor: '#F7F7F7',
        cSliderHandlerFillOpacity: 1,
        cSliderHandlerHighlightFillColor: '#FFF',
        cSliderHandlerBorderColor: '#BFBFBF',
        cSliderHandlerBorder: 1,
        cSliderHandlerBorderRadius: 2,
    
        cSliderTextFillColor: '#000',
        cSliderTextFillOpacity: 0.45,
        cSliderTextFontSize: 12,
        cSliderTextLineHeight: 12,
        cSliderTextFontWeight: 'normal',
        cSliderTextBorderColor: null,
        cSliderTextBorder: 0,
    
        scrollbarTrackFillColor: 'rgba(0,0,0,0)',
        scrollbarThumbFillColor: 'rgba(0,0,0,0.15)',
        scrollbarThumbHighlightFillColor: 'rgba(0,0,0,0.2)',
    
        pointFillColor: brandColor,
        pointFillOpacity: 0.95,
        pointSize: 4,
        pointBorder: 1,
        pointBorderColor: WHITE_COLORS[100],
        pointBorderOpacity: 1,
        pointActiveBorderColor: BLACK_COLORS[100],
        pointSelectedBorder: 2,
        pointSelectedBorderColor: BLACK_COLORS[100],
        pointInactiveFillOpacity: 0.3,
        pointInactiveBorderOpacity: 0.3,
        hollowPointSize: 4,
        hollowPointBorder: 1,
        hollowPointBorderColor: brandColor,
        hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
        hollowPointActiveBorder: 1,
        hollowPointActiveBorderColor: BLACK_COLORS[100],
        hollowPointActiveBorderOpacity: 1,
        hollowPointSelectedBorder: 2,
        hollowPointSelectedBorderColor: BLACK_COLORS[100],
        hollowPointSelectedBorderOpacity: 1,
        hollowPointInactiveBorderOpacity: 0.3,
        lineBorder: 2,
        lineBorderColor: brandColor,
        lineBorderOpacity: 1,
        lineActiveBorder: 3,
        lineSelectedBorder: 3,
        lineInactiveBorderOpacity: 0.3,
        areaFillColor: brandColor,
        areaFillOpacity: 0.25,
        areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,
        areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,
        areaInactiveFillOpacity: 0.3,
        hollowAreaBorderColor: brandColor,
        hollowAreaBorder: 2,
        hollowAreaBorderOpacity: 1,
        hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
        hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
        hollowAreaInactiveBorderOpacity: 0.3,
        intervalFillColor: brandColor,
        intervalFillOpacity: 0.95,
        intervalActiveBorder: 1,
        intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
        intervalSelectedBorder: 2,
        intervalSelectedBorderColor: BLACK_COLORS[100],
        intervalSelectedBorderOpacity: 1,
        intervalInactiveBorderOpacity: 0.3,
        intervalInactiveFillOpacity: 0.3,
        hollowIntervalBorder: 2,
        hollowIntervalBorderColor: brandColor,
        hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
        hollowIntervalActiveBorder: 2,
        hollowIntervalActiveBorderColor: BLACK_COLORS[100],
        hollowIntervalSelectedBorder: 3,
        hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
        hollowIntervalSelectedBorderOpacity: 1,
        hollowIntervalInactiveBorderOpacity: 0.3
  };
};
exports.createLightStyleSheet = createLightStyleSheet;
exports.antvLight = (0, exports.createLightStyleSheet)();

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathIn = void 0;
function pathIn(element, animateCfg, cfg) {
  
  var length = element.getTotalLength();
  
  element.attr('lineDash', [length]);
  element.animate(function (ratio) {
    return {
      
      lineDashOffset: (1 - ratio) * length
    };
  }, animateCfg);
}
exports.pathIn = pathIn;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(100));
var IntervalLabel = function (_super) {
  (0, tslib_1.__extends)(IntervalLabel, _super);
  function IntervalLabel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
    IntervalLabel.prototype.getLabelValueDir = function (mappingData) {
    
    var dim = 'y';
    var points = mappingData.points;
    return points[0][dim] <= points[2][dim] ? 1 : -1;
  };
    IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {
    var _a;
    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var dim = transposed ? 'x' : 'y';
    var dir = this.getLabelValueDir(labelCfg.mappingData);
    point = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));
    if (coordinate.isReflect('x')) {
      point = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, point), {
        x: point.x * -1
      });
    }
    if (coordinate.isReflect('y')) {
      point = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, point), {
        y: point.y * -1
      });
    }
    return point;
  };
    IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {
    var geometry = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var theme = geometry.theme;
    
    return (0, util_1.deepMix)({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {
      offset: 0
    } : {}, labelCfg);
  };
  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var shapePoints = mappingData.points;
    var point0 = coordinate.convert(shapePoints[0]);
    var point2 = coordinate.convert(shapePoints[2]);
    var dir = this.getLabelValueDir(mappingData);
    var top;
    var right;
    var bottom;
    var left;
    var shape = (0, util_1.isArray)(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    if (shape === 'funnel' || shape === 'pyramid') {
      
      var nextPoints = (0, util_1.get)(mappingData, 'nextPoints');
      var points = (0, util_1.get)(mappingData, 'points');
      if (nextPoints) {
        
        var p0 = coordinate.convert(points[0]);
        var p1 = coordinate.convert(points[1]);
        var nextP0 = coordinate.convert(nextPoints[0]);
        var nextP1 = coordinate.convert(nextPoints[1]);
        
        if (transposed) {
          top = Math.min(nextP0.y, p0.y);
          bottom = Math.max(nextP0.y, p0.y);
          right = (p1.x + nextP1.x) / 2;
          left = (p0.x + nextP0.x) / 2;
        } else {
          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          right = nextP1.x;
          left = p0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right = point2.x;
        left = point0.x;
      }
    } else {
      top = Math.min(point2.y, point0.y);
      bottom = Math.max(point2.y, point0.y);
      right = point2.x;
      left = point0.x;
    }
    switch (position) {
      case 'right':
        labelPointCfg.x = right;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = (0, util_1.get)(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
        break;
      case 'left':
        labelPointCfg.x = left;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = (0, util_1.get)(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
        break;
      case 'bottom':
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }
        labelPointCfg.y = bottom;
        labelPointCfg.textAlign = (0, util_1.get)(labelPointCfg, 'textAlign', 'center');
        labelPointCfg.textBaseline = (0, util_1.get)(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
        break;
      case 'middle':
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = (0, util_1.get)(labelPointCfg, 'textAlign', 'center');
        labelPointCfg.textBaseline = (0, util_1.get)(labelPointCfg, 'textBaseline', 'middle');
        break;
      case 'top':
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }
        labelPointCfg.y = top;
        labelPointCfg.textAlign = (0, util_1.get)(labelPointCfg, 'textAlign', 'center');
        labelPointCfg.textBaseline = (0, util_1.get)(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
        break;
      default:
        break;
    }
  };
  return IntervalLabel;
}(base_1.default);
exports.default = IntervalLabel;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var coordinate_1 = __webpack_require__(48);
var graphics_1 = __webpack_require__(46);
var polar_1 = (0, tslib_1.__importDefault)(__webpack_require__(214));
var PieLabel = function (_super) {
  (0, tslib_1.__extends)(PieLabel, _super);
  function PieLabel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.defaultLayout = 'distribute';
    return _this;
  }
  PieLabel.prototype.getDefaultLabelCfg = function (offset, position) {
    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
    return (0, util_1.deepMix)({}, cfg, (0, util_1.get)(this.geometry.theme, 'pieLabels', {}));
  };
    PieLabel.prototype.getLabelOffset = function (offset) {
    return _super.prototype.getLabelOffset.call(this, offset) || 0;
  };
  PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {
    var rotate;
    if (offset < 0) {
      rotate = angle;
      if (rotate > Math.PI / 2) {
        rotate = rotate - Math.PI;
      }
      if (rotate < -Math.PI / 2) {
        rotate = rotate + Math.PI;
      }
    }
    return rotate;
  };
  PieLabel.prototype.getLabelAlign = function (point) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var align;
    if (point.angle <= Math.PI / 2 && point.x >= center.x) {
      align = 'left';
    } else {
      align = 'right';
    }
    if (point.offset <= 0) {
      if (align === 'right') {
        align = 'left';
      } else {
        align = 'right';
      }
    }
    return align;
  };
  PieLabel.prototype.getArcPoint = function (point) {
    return point;
  };
  PieLabel.prototype.getPointAngle = function (point) {
    var coordinate = this.getCoordinate();
    var startPoint = {
      x: (0, util_1.isArray)(point.x) ? point.x[0] : point.x,
      y: point.y[0]
    };
    var endPoint = {
      x: (0, util_1.isArray)(point.x) ? point.x[1] : point.x,
      y: point.y[1]
    };
    var angle;
    var startAngle = (0, coordinate_1.getAngleByPoint)(coordinate, startPoint);
    if (point.points && point.points[0].y === point.points[1].y) {
      angle = startAngle;
    } else {
      var endAngle = (0, coordinate_1.getAngleByPoint)(coordinate, endPoint);
      if (startAngle >= endAngle) {
        
        endAngle = endAngle + Math.PI * 2;
      }
      angle = startAngle + (endAngle - startAngle) / 2;
    }
    return angle;
  };
    PieLabel.prototype.getCirclePoint = function (angle, offset) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var r = coordinate.getRadius() + offset;
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, (0, graphics_1.polarToCartesian)(center.x, center.y, r, angle)), {
      angle: angle,
      r: r
    });
  };
  return PieLabel;
}(polar_1.default);
exports.default = PieLabel;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return visibleHelper; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
 var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2__);
 var _antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(623);
 var _antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3__);
 var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61);
 var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4__);






var visibleHelper = function visibleHelper(cfg) {
  var defaultVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2___default()(cfg) || react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(cfg)) {
    return {
      visible: true,
      text: cfg
    };
  }
  if (_antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3___default()(cfg)) {
    return {
      visible: cfg
    };
  }
  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4___default()(cfg)) {
    return object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
      visible: true
    }, cfg);
  }
  return {
    visible: defaultVisible
  };
};
var visibleHelperInvert = function visibleHelperInvert(cfg) {
  
  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4___default()(cfg) && cfg.visible !== false) {
    
    return cfg.text;
  }
  return cfg;
};

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "b", function() { return registerConnector; });
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(203);
 var _antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5__);
 var _antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(127);
 var _antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6__);
 var _antv_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
 var _antv_util__WEBPACK_IMPORTED_MODULE_7___default = __webpack_require__.n(_antv_util__WEBPACK_IMPORTED_MODULE_7__);
 var _core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var CONNECTOR_MAP = {};
var Connector = function () {
  function Connector(type) {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, Connector);
    this.cfg = {
      shared: true
    };
    this.chartMap = {};
    this.state = {};
    this.id = Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["uniqueId"])('bx-action');
    this.type = type || 'tooltip';
  }
  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(Connector, [{
    key: "connect",
    value: function connect(id, chart, pointFinder) {
      this.chartMap[id] = {
        chart: chart,
        pointFinder: pointFinder
      };
      chart.interaction("connect-".concat(this.type, "-").concat(this.id));
      if (this.type === 'tooltip' && this.cfg.shared) {
        if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["get"])(chart, ['options', 'tooltip', 'shared']) === undefined) {
          Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["set"])(chart, ['options', 'tooltip', 'shared'], true);
        }
        ;
      }
      return this;
    }
  }, {
    key: "unConnect",
    value: function unConnect(id) {
      this.chartMap[id].chart.removeInteraction("connect-".concat(this.type, "-").concat(this.id));
      delete this.chartMap[id];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      Object(_antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5__["unregisterAction"])("connect-".concat(this.type, "-").concat(this.id));
    }
  }]);
  return Connector;
}();

var createTooltipConnector = function createTooltipConnector() {
  var cm = new Connector('tooltip');
  Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerAction"])("connect-tooltip-".concat(cm.id), function (_TooltipAction) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0___default()(ConnectTooltip, _TooltipAction);
    var _super = _createSuper(ConnectTooltip);
    function ConnectTooltip() {
      var _this;
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, ConnectTooltip);
      _this = _super.apply(this, arguments);
      _this.CM = cm;
      return _this;
    }
    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(ConnectTooltip, [{
      key: "showTooltip",
      value: function showTooltip(view, point) {
        var records = view.getTooltipItems(point) || point;
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["forIn"])(this.CM.chartMap, function (item) {
          var chart = item.chart,
            pointFinder = item.pointFinder;
          if (chart.destroyed || !chart.visible) {
            return;
          }
          if (pointFinder) {
            var triggerPoint = pointFinder(records, chart);
            
            if (triggerPoint) {
              chart.showTooltip(triggerPoint);
            }
            ;
          } else {
            chart.showTooltip(point);
          }
        });
      }
    }, {
      key: "hideTooltip",
      value: function hideTooltip() {
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["forIn"])(this.CM.chartMap, function (_ref) {
          var chart = _ref.chart;
          return chart.hideTooltip();
        });
      }
    }]);
    return ConnectTooltip;
  }(_antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6___default.a));
  Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerInteraction"])("connect-tooltip-".concat(cm.id), {
    start: [{
      trigger: 'plot:mousemove',
      action: "connect-tooltip-".concat(cm.id, ":show")
    }],
    end: [{
      trigger: 'plot:mouseleave',
      action: "connect-tooltip-".concat(cm.id, ":hide")
    }]
  });
  return cm;
};
var registerConnector = function registerConnector(cid, tid, chart, shared, pointFinder) {
  var connector = CONNECTOR_MAP[cid];
  
  if (chart === null && connector) {
    connector.unConnect(tid);
    return;
  }
  
  if (connector) {
    connector.connect(tid, chart, pointFinder);
  } else {
    CONNECTOR_MAP[cid] = createTooltipConnector();
    
    CONNECTOR_MAP[cid].cfg.shared = !!shared;
    CONNECTOR_MAP[cid].connect(tid, chart, pointFinder);
  }
};
 __webpack_exports__["a"] = (createTooltipConnector);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.growInXY = exports.growInY = exports.growInX = void 0;
var util_1 = __webpack_require__(951);
function growInX(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate,
    minYPoint = cfg.minYPoint;
  (0, util_1.doScaleAnimate)(element, animateCfg, coordinate, minYPoint, 'x');
}
exports.growInX = growInX;
function growInY(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate,
    minYPoint = cfg.minYPoint;
  (0, util_1.doScaleAnimate)(element, animateCfg, coordinate, minYPoint, 'y');
}
exports.growInY = growInY;
function growInXY(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate,
    minYPoint = cfg.minYPoint;
  (0, util_1.doScaleAnimate)(element, animateCfg, coordinate, minYPoint, 'xy');
}
exports.growInXY = growInXY;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var is_array_1 = __webpack_require__(23);
var is_plain_object_1 = __webpack_require__(1054);
var MAX_MIX_LEVEL = 5;
function _deepMix(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];
      if (value !== null && is_plain_object_1.default(value)) {
        if (!is_plain_object_1.default(dist[key])) {
          dist[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist[key], value, level + 1, maxLevel);
        } else {
          dist[key] = src[key];
        }
      } else if (is_array_1.default(value)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value);
      } else if (value !== undefined) {
        dist[key] = value;
      }
    }
  }
}

var deepMix = function deepMix(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
exports.default = deepMix;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var _default = function _default(value) {
    var type = (0, _typeof2.default)(value);
  return value !== null && type === 'object' || type === 'function';
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
exports.glMatrix = glMatrix;
var mat2 = _interopRequireWildcard(__webpack_require__(748));
exports.mat2 = mat2;
var mat2d = _interopRequireWildcard(__webpack_require__(749));
exports.mat2d = mat2d;
var mat3 = _interopRequireWildcard(__webpack_require__(394));
exports.mat3 = mat3;
var mat4 = _interopRequireWildcard(__webpack_require__(395));
exports.mat4 = mat4;
var quat = _interopRequireWildcard(__webpack_require__(396));
exports.quat = quat;
var quat2 = _interopRequireWildcard(__webpack_require__(750));
exports.quat2 = quat2;
var vec2 = _interopRequireWildcard(__webpack_require__(398));
exports.vec2 = vec2;
var vec3 = _interopRequireWildcard(__webpack_require__(171));
exports.vec3 = vec3;
var vec4 = _interopRequireWildcard(__webpack_require__(397));
exports.vec4 = vec4;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }


function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}

function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

function transformQuat(out, a, q) {
  
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var x = a[0],
    y = a[1],
    z = a[2]; 
  

  var uvx = qy * z - qz * y,
    uvy = qz * x - qx * z,
    uvz = qx * y - qy * x; 

  var uuvx = qy * uvz - qz * uvy,
    uuvy = qz * uvx - qx * uvz,
    uuvz = qx * uvy - qy * uvx; 

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; 

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; 

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}

function rotateX(out, a, b, rad) {
  var p = [],
    r = []; 

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; 

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); 

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

function rotateY(out, a, b, rad) {
  var p = [],
    r = []; 

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; 

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); 

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

function rotateZ(out, a, b, rad) {
  var p = [],
    r = []; 

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; 

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; 

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
    mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
    mag = mag1 * mag2,
    cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

var sub = subtract;
exports.sub = sub;
var mul = multiply;
exports.mul = mul;
var div = divide;
exports.div = div;
var dist = distance;
exports.dist = dist;
var sqrDist = squaredDistance;
exports.sqrDist = sqrDist;
var len = length;
exports.len = len;
var sqrLen = squaredLength;
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
exports.forEach = forEach;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof3 = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var _d3Color = __webpack_require__(60);
var _rgb = _interopRequireDefault(__webpack_require__(400));
var _array = __webpack_require__(403);
var _date = _interopRequireDefault(__webpack_require__(404));
var _number = _interopRequireDefault(__webpack_require__(173));
var _object = _interopRequireDefault(__webpack_require__(405));
var _string = _interopRequireDefault(__webpack_require__(406));
var _constant = _interopRequireDefault(__webpack_require__(402));
var _numberArray = _interopRequireWildcard(__webpack_require__(248));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _default(a, b) {
  var t = (0, _typeof2.default)(b),
    c;
  return b == null || t === "boolean" ? (0, _constant.default)(b) : (t === "number" ? _number.default : t === "string" ? (c = (0, _d3Color.color)(b)) ? (b = c, _rgb.default) : _string.default : b instanceof _d3Color.color ? _rgb.default : b instanceof Date ? _date.default : (0, _numberArray.isNumberArray)(b) ? _numberArray.default : Array.isArray(b) ? _array.genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object.default : _number.default)(a, b);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = __webpack_require__(87);
var vec2 = _interopRequireWildcard(__webpack_require__(398));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _default = {
    box: function box(x1, y1, x2, y2) {
    return (0, _util.getBBoxByArray)([x1, x2], [y1, y2]);
  },
    length: function length(x1, y1, x2, y2) {
    return (0, _util.distance)(x1, y1, x2, y2);
  },
    pointAt: function pointAt(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
    pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
    
    
    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross < 0) {
      return (0, _util.distance)(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross > lengthSquare) {
      return (0, _util.distance)(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
    pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];
    
    if (vec2.exactEquals(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d[1], d[0]];
    vec2.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2.dot(a, u));
  },
    tangentAngle: function tangentAngle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YEAR = exports.SECOND = exports.MONTH = exports.MINUTE = exports.HOUR = exports.DAY = void 0;
exports.getTickInterval = getTickInterval;
exports.timeFormat = timeFormat;
exports.toTimeStamp = toTimeStamp;
var _util = __webpack_require__(0);
var fecha1 = _interopRequireWildcard(__webpack_require__(828));
var _bisector = _interopRequireDefault(__webpack_require__(829));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var FORMAT_METHOD = 'format';
function timeFormat(time, mask) {
  var method = fecha1[FORMAT_METHOD] || fecha1.default[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value) {
  if ((0, _util.isString)(value)) {
    if (value.indexOf('T') > 0) {
      value = new Date(value).getTime();
    } else {
      
      
      
      value = new Date(value.replace(/-/gi, '/')).getTime();
    }
  }
  if ((0, _util.isDate)(value)) {
    value = value.getTime();
  }
  return value;
}
var SECOND = 1000;
exports.SECOND = SECOND;
var MINUTE = 60 * SECOND;
exports.MINUTE = MINUTE;
var HOUR = 60 * MINUTE;
exports.HOUR = HOUR;
var DAY = 24 * HOUR;
exports.DAY = DAY;
var MONTH = DAY * 31;
exports.MONTH = MONTH;
var YEAR = DAY * 365;
exports.YEAR = YEAR;
var intervals = [['HH:mm:ss', SECOND], ['HH:mm:ss', SECOND * 10], ['HH:mm:ss', SECOND * 30], ['HH:mm', MINUTE], ['HH:mm', MINUTE * 10], ['HH:mm', MINUTE * 30], ['HH', HOUR], ['HH', HOUR * 6], ['HH', HOUR * 12], ['YYYY-MM-DD', DAY], ['YYYY-MM-DD', DAY * 4], ['YYYY-WW', DAY * 7], ['YYYY-MM', MONTH], ['YYYY-MM', MONTH * 4], ['YYYY-MM', MONTH * 6], ['YYYY', DAY * 380]];
function getTickInterval(min, max, tickCount) {
  var target = (max - min) / tickCount;
  var idx = (0, _bisector.default)(function (o) {
    return o[1];
  })(intervals, target) - 1;
  var interval = intervals[idx];
  if (idx < 0) {
    interval = intervals[0];
  } else if (idx >= intervals.length) {
    interval = (0, _util.last)(intervals);
  }
  return interval;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _base = _interopRequireDefault(__webpack_require__(141));
var Continuous = function (_super) {
  (0, _tslib.__extends)(Continuous, _super);
  function Continuous() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isContinuous = true;
    return _this;
  }
  Continuous.prototype.scale = function (value) {
    if ((0, _util.isNil)(value)) {
      return NaN;
    }
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var max = this.max;
    var min = this.min;
    if (max === min) {
      return rangeMin;
    }
    var percent = this.getScalePercent(value);
    return rangeMin + percent * (rangeMax - rangeMin);
  };
  Continuous.prototype.init = function () {
    _super.prototype.init.call(this);
    
    var ticks = this.ticks;
    var firstTick = (0, _util.head)(ticks);
    var lastTick = (0, _util.last)(ticks);
    if (firstTick < this.min) {
      this.min = firstTick;
    }
    if (lastTick > this.max) {
      this.max = lastTick;
    }
    
    if (!(0, _util.isNil)(this.minLimit)) {
      this.min = firstTick;
    }
    if (!(0, _util.isNil)(this.maxLimit)) {
      this.max = lastTick;
    }
  };
  Continuous.prototype.setDomain = function () {
    var _a = (0, _util.getRange)(this.values),
      min = _a.min,
      max = _a.max;
    if ((0, _util.isNil)(this.min)) {
      this.min = min;
    }
    if ((0, _util.isNil)(this.max)) {
      this.max = max;
    }
    if (this.min > this.max) {
      this.min = min;
      this.max = max;
    }
  };
  Continuous.prototype.calculateTicks = function () {
    var _this = this;
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      ticks = (0, _util.filter)(ticks, function (tick) {
        return tick >= _this.min && tick <= _this.max;
      });
    }
    return ticks;
  };
  
  Continuous.prototype.getScalePercent = function (value) {
    var max = this.max;
    var min = this.min;
    return (value - min) / (max - min);
  };
  Continuous.prototype.getInvertPercent = function (value) {
    return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
  };
  return Continuous;
}(_base.default);
var _default = Continuous;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calBase = calBase;
exports.getLogPositiveMin = getLogPositiveMin;
exports.log = log;
exports.precisionAdd = precisionAdd;
var _util = __webpack_require__(0);


function calBase(a, b) {
  var e = Math.E;
  var value;
  if (b >= 0) {
    value = Math.pow(e, Math.log(b) / a); 
  } else {
    value = Math.pow(e, Math.log(-b) / a) * -1; 
  }

  return value;
}
function log(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values, base, max) {
  if ((0, _util.isNil)(max)) {
    max = Math.max.apply(null, values);
  }
  var positiveMin = max;
  (0, _util.each)(values, function (value) {
    if (value > 0 && value < positiveMin) {
      positiveMin = value;
    }
  });
  if (positiveMin === max) {
    positiveMin = max / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}
function digitLength(num) {
  
  var eSplit = num.toString().split(/[eE]/);
  var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);
  return len > 0 ? len : 0;
}
/**
 * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题
 *
 * @param num1 加数
 * @param num2 被加数
 * @return {number} 返回值
 */
function precisionAdd(num1, num2) {
  var num1Digits = digitLength(num1);
  var num2Digits = digitLength(num2);
  var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _matrixUtil = __webpack_require__(32);
var _util = __webpack_require__(0);
/**
 * Coordinate Base Class
 */
var Coordinate = /** @class */function () {
  function Coordinate(cfg) {
    // 自身属性
    this.type = 'coordinate';
    this.isRect = false;
    this.isHelix = false;
    this.isPolar = false;
    this.isReflectX = false;
    this.isReflectY = false;
    var start = cfg.start,
      end = cfg.end,
      _a = cfg.matrix,
      matrix = _a === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a,
      _b = cfg.isTransposed,
      isTransposed = _b === void 0 ? false : _b;
    this.start = start;
    this.end = end;
    this.matrix = matrix;
    this.originalMatrix = (0, _tslib.__spreadArray)([], matrix); 
    this.isTransposed = isTransposed;
  }
    Coordinate.prototype.initial = function () {
    
    this.center = {
      x: (this.start.x + this.end.x) / 2,
      y: (this.start.y + this.end.y) / 2
    };
    this.width = Math.abs(this.end.x - this.start.x);
    this.height = Math.abs(this.end.y - this.start.y);
  };
    Coordinate.prototype.update = function (cfg) {
    (0, _util.assign)(this, cfg);
    this.initial();
  };
  Coordinate.prototype.convertDim = function (percent, dim) {
    var _a;
    var _b = this[dim],
      start = _b.start,
      end = _b.end;
    
    if (this.isReflect(dim)) {
      _a = [end, start], start = _a[0], end = _a[1];
    }
    return start + percent * (end - start);
  };
  Coordinate.prototype.invertDim = function (value, dim) {
    var _a;
    var _b = this[dim],
      start = _b.start,
      end = _b.end;
    
    if (this.isReflect(dim)) {
      _a = [end, start], start = _a[0], end = _a[1];
    }
    return (value - start) / (end - start);
  };
    Coordinate.prototype.applyMatrix = function (x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var vector = [x, y, tag];
    _matrixUtil.vec3.transformMat3(vector, vector, matrix);
    return vector;
  };
    Coordinate.prototype.invertMatrix = function (x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var inverted = _matrixUtil.mat3.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
    var vector = [x, y, tag];
    if (inverted) {
      
      _matrixUtil.vec3.transformMat3(vector, vector, inverted);
    }
    return vector;
  };
    Coordinate.prototype.convert = function (point) {
    var _a = this.convertPoint(point),
      x = _a.x,
      y = _a.y;
    var vector = this.applyMatrix(x, y, 1);
    return {
      x: vector[0],
      y: vector[1]
    };
  };
    Coordinate.prototype.invert = function (point) {
    var vector = this.invertMatrix(point.x, point.y, 1);
    return this.invertPoint({
      x: vector[0],
      y: vector[1]
    });
  };
    Coordinate.prototype.rotate = function (radian) {
    var matrix = this.matrix;
    var center = this.center;
    _matrixUtil.ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);
    _matrixUtil.ext.leftRotate(matrix, matrix, radian);
    _matrixUtil.ext.leftTranslate(matrix, matrix, [center.x, center.y]);
    return this;
  };
    Coordinate.prototype.reflect = function (dim) {
    if (dim === 'x') {
      this.isReflectX = !this.isReflectX;
    } else {
      this.isReflectY = !this.isReflectY;
    }
    return this;
  };
    Coordinate.prototype.scale = function (s1, s2) {
    var matrix = this.matrix;
    var center = this.center;
    _matrixUtil.ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);
    _matrixUtil.ext.leftScale(matrix, matrix, [s1, s2]);
    _matrixUtil.ext.leftTranslate(matrix, matrix, [center.x, center.y]);
    return this;
  };
    Coordinate.prototype.translate = function (x, y) {
    var matrix = this.matrix;
    _matrixUtil.ext.leftTranslate(matrix, matrix, [x, y]);
    return this;
  };
    Coordinate.prototype.transpose = function () {
    this.isTransposed = !this.isTransposed;
    return this;
  };
  Coordinate.prototype.getCenter = function () {
    return this.center;
  };
  Coordinate.prototype.getWidth = function () {
    return this.width;
  };
  Coordinate.prototype.getHeight = function () {
    return this.height;
  };
  Coordinate.prototype.getRadius = function () {
    return this.radius;
  };
    Coordinate.prototype.isReflect = function (dim) {
    return dim === 'x' ? this.isReflectX : this.isReflectY;
  };
    Coordinate.prototype.resetMatrix = function (matrix) {
    
    this.matrix = matrix ? matrix : (0, _tslib.__spreadArray)([], this.originalMatrix);
  };
  return Coordinate;
}();
var _default = Coordinate;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Annotation: true,
  Axis: true,
  Crosshair: true,
  Grid: true,
  Legend: true,
  Tooltip: true,
  Component: true,
  GroupComponent: true,
  HtmlComponent: true,
  Slider: true,
  Scrollbar: true,
  propagationDelegate: true,
  TOOLTIP_CSS_CONST: true
};
exports.Axis = exports.Annotation = void 0;
Object.defineProperty(exports, "Component", {
  enumerable: true,
  get: function get() {
    return _component.default;
  }
});
exports.Grid = exports.Crosshair = void 0;
Object.defineProperty(exports, "GroupComponent", {
  enumerable: true,
  get: function get() {
    return _groupComponent.default;
  }
});
Object.defineProperty(exports, "HtmlComponent", {
  enumerable: true,
  get: function get() {
    return _htmlComponent.default;
  }
});
exports.Legend = void 0;
Object.defineProperty(exports, "Scrollbar", {
  enumerable: true,
  get: function get() {
    return _scrollbar.Scrollbar;
  }
});
Object.defineProperty(exports, "Slider", {
  enumerable: true,
  get: function get() {
    return _slider.Slider;
  }
});
exports.Tooltip = exports.TOOLTIP_CSS_CONST = void 0;
Object.defineProperty(exports, "propagationDelegate", {
  enumerable: true,
  get: function get() {
    return _event.propagationDelegate;
  }
});
var Annotation = _interopRequireWildcard(__webpack_require__(854));
exports.Annotation = Annotation;
var Axis = _interopRequireWildcard(__webpack_require__(866));
exports.Axis = Axis;
var Crosshair = _interopRequireWildcard(__webpack_require__(872));
exports.Crosshair = Crosshair;
var Grid = _interopRequireWildcard(__webpack_require__(877));
exports.Grid = Grid;
var Legend = _interopRequireWildcard(__webpack_require__(880));
exports.Legend = Legend;
var Tooltip = _interopRequireWildcard(__webpack_require__(883));
exports.Tooltip = Tooltip;
var _component = _interopRequireDefault(__webpack_require__(254));
var _groupComponent = _interopRequireDefault(__webpack_require__(41));
var _htmlComponent = _interopRequireDefault(__webpack_require__(181));
var _slider = __webpack_require__(887);
var _scrollbar = __webpack_require__(894);
var _interfaces = __webpack_require__(896);
Object.keys(_interfaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interfaces[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interfaces[key];
    }
  });
});
var _types = __webpack_require__(897);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});
var _event = __webpack_require__(432);
var TOOLTIP_CSS_CONST = _interopRequireWildcard(__webpack_require__(259));
exports.TOOLTIP_CSS_CONST = TOOLTIP_CSS_CONST;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderTag = renderTag;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _label = __webpack_require__(142);
var _matrix = __webpack_require__(90);
var _util2 = __webpack_require__(42);
function renderTag(container, tagCfg) {
  var x = tagCfg.x,
    y = tagCfg.y,
    content = tagCfg.content,
    style = tagCfg.style,
    id = tagCfg.id,
    name = tagCfg.name,
    rotate = tagCfg.rotate,
    maxLength = tagCfg.maxLength,
    autoEllipsis = tagCfg.autoEllipsis,
    isVertical = tagCfg.isVertical,
    ellipsisPosition = tagCfg.ellipsisPosition,
    background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id + "-group",
    name: name + "-group",
    attrs: {
      x: x,
      y: y
    }
  });
  
  var text = tagGroup.addShape({
    type: 'text',
    id: id,
    name: name,
    attrs: (0, _tslib.__assign)({
      x: 0,
      y: 0,
      text: content
    }, style)
  });
  
  var padding = (0, _util2.formatPadding)((0, _util.get)(background, 'padding', 0));
  if (maxLength && autoEllipsis) {
    var maxTextLength = maxLength - (padding[1] + padding[3]);
    
    (0, _label.ellipsisLabel)(!isVertical, text, maxTextLength, ellipsisPosition);
  }
  if (background) {
    
    var backgroundStyle = (0, _util.get)(background, 'style', {});
    var _a = text.getCanvasBBox(),
      minX = _a.minX,
      minY = _a.minY,
      width = _a.width,
      height = _a.height;
    var tagBg = tagGroup.addShape('rect', {
      id: id + "-bg",
      name: id + "-bg",
      attrs: (0, _tslib.__assign)({
        x: minX - padding[3],
        y: minY - padding[0],
        width: width + padding[1] + padding[3],
        height: height + padding[0] + padding[2]
      }, backgroundStyle)
    });
    tagBg.toBack();
  }
  (0, _matrix.applyTranslate)(tagGroup, x, y);
  (0, _matrix.applyRotate)(tagGroup, rotate, x, y);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _domUtil = __webpack_require__(96);
var _util = __webpack_require__(0);
var _util2 = __webpack_require__(42);
var _component = _interopRequireDefault(__webpack_require__(254));
var HtmlComponent = function (_super) {
  (0, _tslib.__extends)(HtmlComponent, _super);
  function HtmlComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlComponent.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      container: null,
      containerTpl: '<div></div>',
      updateAutoRender: true,
      containerClassName: '',
      parent: null
    });
  };
  HtmlComponent.prototype.getContainer = function () {
    return this.get('container');
  };
    HtmlComponent.prototype.show = function () {
    var container = this.get('container');
    container.style.display = '';
    this.set('visible', true);
  };
    HtmlComponent.prototype.hide = function () {
    var container = this.get('container');
    container.style.display = 'none';
    this.set('visible', false);
  };
    HtmlComponent.prototype.setCapture = function (capture) {
    var container = this.getContainer();
    var value = capture ? 'auto' : 'none';
    container.style.pointerEvents = value;
    this.set('capture', capture);
  };
  HtmlComponent.prototype.getBBox = function () {
    var container = this.getContainer();
    var x = parseFloat(container.style.left) || 0;
    var y = parseFloat(container.style.top) || 0;
    return (0, _util2.createBBox)(x, y, container.clientWidth, container.clientHeight);
  };
  HtmlComponent.prototype.clear = function () {
    var container = this.get('container');
    (0, _util2.clearDom)(container);
  };
  HtmlComponent.prototype.destroy = function () {
    this.removeEvent();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
    HtmlComponent.prototype.init = function () {
    _super.prototype.init.call(this);
    this.initContainer();
    this.initDom();
    this.resetStyles(); 
    this.applyStyles(); 
    this.initEvent();
    this.initCapture();
    this.initVisible();
  };
  HtmlComponent.prototype.initCapture = function () {
    this.setCapture(this.get('capture'));
  };
  HtmlComponent.prototype.initVisible = function () {
    if (!this.get('visible')) {
      
      this.hide();
    } else {
      this.show();
    }
  };
  HtmlComponent.prototype.initDom = function () {};
  HtmlComponent.prototype.initContainer = function () {
    var container = this.get('container');
    if ((0, _util.isNil)(container)) {
      
      container = this.createDom();
      var parent_1 = this.get('parent');
      if ((0, _util.isString)(parent_1)) {
        parent_1 = document.getElementById(parent_1);
        this.set('parent', parent_1);
      }
      parent_1.appendChild(container);
      if (this.get('containerId')) {
        container.setAttribute('id', this.get('containerId'));
      }
      this.set('container', container);
    } else if ((0, _util.isString)(container)) {
      
      container = document.getElementById(container);
      this.set('container', container);
    } 
    if (!this.get('parent')) {
      this.set('parent', container.parentNode);
    }
  };
  
  HtmlComponent.prototype.resetStyles = function () {
    var style = this.get('domStyles');
    var defaultStyles = this.get('defaultStyles');
    if (!style) {
      style = defaultStyles;
    } else {
      style = (0, _util.deepMix)({}, defaultStyles, style);
    }
    this.set('domStyles', style);
  };
  
  HtmlComponent.prototype.applyStyles = function () {
    var domStyles = this.get('domStyles');
    if (!domStyles) {
      return;
    }
    var container = this.getContainer();
    this.applyChildrenStyles(container, domStyles);
    var containerClassName = this.get('containerClassName');
    if (containerClassName && (0, _util2.hasClass)(container, containerClassName)) {
      var containerCss = domStyles[containerClassName];
      (0, _domUtil.modifyCSS)(container, containerCss);
    }
  };
  HtmlComponent.prototype.applyChildrenStyles = function (element, styles) {
    (0, _util.each)(styles, function (style, name) {
      var elements = element.getElementsByClassName(name);
      (0, _util.each)(elements, function (el) {
        (0, _domUtil.modifyCSS)(el, style);
      });
    });
  };
  
  HtmlComponent.prototype.applyStyle = function (cssName, dom) {
    var domStyles = this.get('domStyles');
    (0, _domUtil.modifyCSS)(dom, domStyles[cssName]);
  };
    HtmlComponent.prototype.createDom = function () {
    var containerTpl = this.get('containerTpl');
    return (0, _domUtil.createDom)(containerTpl);
  };
    HtmlComponent.prototype.initEvent = function () {};
    HtmlComponent.prototype.removeDom = function () {
    var container = this.get('container');
    
    container && container.parentNode && container.parentNode.removeChild(container);
  };
    HtmlComponent.prototype.removeEvent = function () {};
  HtmlComponent.prototype.updateInner = function (cfg) {
    
    if ((0, _util.hasKey)(cfg, 'domStyles')) {
      this.resetStyles();
      this.applyStyles();
    }
    
    this.resetPosition();
  };
  HtmlComponent.prototype.resetPosition = function () {};
  ;
  return HtmlComponent;
}(_component.default);
var _default = HtmlComponent;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEndArrow = exports.addStartArrow = exports.getShortenOffset = void 0;
var tslib_1 = __webpack_require__(1);
var shape_1 = __webpack_require__(143);
var sin = Math.sin,
  cos = Math.cos,
  atan2 = Math.atan2,
  PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke,
    lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new shape_1.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: {
      
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      
      stroke: stroke,
      lineWidth: lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow,
    endArrow = attrs.endArrow,
    stroke = attrs.stroke,
    lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d,
    arrowFill = arrowAttrs.fill,
    arrowStroke = arrowAttrs.stroke,
    arrowLineWidth = arrowAttrs.lineWidth,
    restAttrs = tslib_1.__rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new shape_1.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: tslib_1.__assign(tslib_1.__assign({}, restAttrs), {
      
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
exports.getShortenOffset = getShortenOffset;
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.startArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set('startArrowShape', null);
  }
}
exports.addStartArrow = addStartArrow;
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.endArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set('startArrowShape', null);
  }
}
exports.addEndArrow = addEndArrow;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var g_math_1 = __webpack_require__(38);
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  
  
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  
  return g_math_1.Line.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}
exports.default = inLine;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var base_1 = __webpack_require__(62);
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return base_1.default;
  }
});
var circle_1 = __webpack_require__(915);
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return circle_1.default;
  }
});
var dom_1 = __webpack_require__(916);
Object.defineProperty(exports, "Dom", {
  enumerable: true,
  get: function get() {
    return dom_1.default;
  }
});
var ellipse_1 = __webpack_require__(917);
Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return ellipse_1.default;
  }
});
var image_1 = __webpack_require__(918);
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return image_1.default;
  }
});
var line_1 = __webpack_require__(919);
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return line_1.default;
  }
});
var marker_1 = __webpack_require__(920);
Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return marker_1.default;
  }
});
var path_1 = __webpack_require__(922);
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return path_1.default;
  }
});
var polygon_1 = __webpack_require__(923);
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return polygon_1.default;
  }
});
var polyline_1 = __webpack_require__(924);
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return polyline_1.default;
  }
});
var rect_1 = __webpack_require__(925);
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return rect_1.default;
  }
});
var text_1 = __webpack_require__(927);
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return text_1.default;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActionClass = exports.registerAction = exports.createAction = exports.Action = void 0;
var base_1 = __webpack_require__(44); 
Object.defineProperty(exports, "Action", {
  enumerable: true,
  get: function get() {
    return __importDefault(base_1).default;
  }
});
var register_1 = __webpack_require__(203);
Object.defineProperty(exports, "createAction", {
  enumerable: true,
  get: function get() {
    return register_1.createAction;
  }
});
Object.defineProperty(exports, "registerAction", {
  enumerable: true,
  get: function get() {
    return register_1.registerAction;
  }
});
Object.defineProperty(exports, "getActionClass", {
  enumerable: true,
  get: function get() {
    return register_1.getActionClass;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findItemsFromViewRecurisive = exports.findItemsFromView = exports.getTooltipItems = exports.findDataByPoint = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var scale_1 = __webpack_require__(111);
function snapEqual(v1, v2, scale) {
  var value1 = scale.translate(v1);
  var value2 = scale.translate(v2);
  return (0, util_1.isNumberEqual)(value1, value2);
}
function getXValueByPoint(point, geometry) {
  var coordinate = geometry.coordinate;
  var xScale = geometry.getXScale();
  var range = xScale.range;
  var rangeMax = range[range.length - 1];
  var rangeMin = range[0];
  var invertPoint = coordinate.invert(point);
  var xValue = invertPoint.x;
  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin; 
  }

  return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data, point, geometry) {
  var coordinate = geometry.coordinate;
  var yScale = geometry.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate.invert(point);
  var yValue = yScale.invert(invertPoint.y);
  var result = (0, util_1.find)(data, function (obj) {
    var originData = obj[constant_1.FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result || data[data.length - 1];
}
var getXDistance = (0, util_1.memoize)(function (scale) {
  if (scale.isCategory) {
    return 1;
  }
  var scaleValues = scale.values; 
  var length = scaleValues.length;
  var min = scale.translate(scaleValues[0]);
  var max = min;
  for (var index = 0; index < length; index++) {
    var value = scaleValues[index];
    
    var numericValue = scale.translate(value);
    if (numericValue < min) {
      min = numericValue;
    }
    if (numericValue > max) {
      max = numericValue;
    }
  }
  return (max - min) / (length - 1);
});
function getTooltipTitle(originData, geometry, title) {
  var positionAttr = geometry.getAttribute('position');
  var fields = positionAttr.getFields();
  var scales = geometry.scales;
  var titleField = (0, util_1.isFunction)(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField];
  
  
  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return (0, util_1.isFunction)(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry) {
  var attributes = (0, util_1.values)(geometry.attributes);
  return (0, util_1.filter)(attributes, function (attribute) {
    return (0, util_1.contains)(constant_1.GROUP_ATTRS, attribute.type);
  });
}
function getTooltipValueScale(geometry) {
  var attributes = getAttributesForLegend(geometry);
  var scale;
  for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
    var attribute = attributes_1[_i];
    var tmpScale = attribute.getScale(attribute.type);
    if (tmpScale && tmpScale.isLinear) {
      
      scale = tmpScale;
      break;
    }
  }
  var xScale = geometry.getXScale();
  var yScale = geometry.getYScale();
  return scale || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
  var field = valueScale.field;
  var value = originData[field];
  if ((0, util_1.isArray)(value)) {
    var texts = value.map(function (eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join('-');
  }
  return valueScale.getText(value);
}

function getTooltipName(originData, geometry) {
  var nameScale;
  var groupScales = geometry.getGroupScales();
  if (groupScales.length) {
    
    nameScale = groupScales[0];
  }
  if (nameScale) {
    var field = nameScale.field;
    return nameScale.getText(originData[field]);
  }
  var valueScale = getTooltipValueScale(geometry);
  return (0, scale_1.getName)(valueScale);
}
function findDataByPoint(point, data, geometry) {
  if (data.length === 0) {
    return null;
  }
  var geometryType = geometry.type;
  var xScale = geometry.getXScale();
  var yScale = geometry.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null;
  
  if (geometryType === 'heatmap' || geometryType === 'point') {
    
    var coordinate = geometry.coordinate;
    var invertPoint = coordinate.invert(point); 
    var x = xScale.invert(invertPoint.x); 
    var y = yScale.invert(invertPoint.y); 
    var min = Infinity;
    for (var index = 0; index < data.length; index++) {
      var obj = data[index];
      var originData = obj[constant_1.FIELD_ORIGIN];
      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
      if (range < min) {
        min = range;
        rst = obj;
      }
    }
    return rst;
  }
  
  var first = data[0];
  var last = data[data.length - 1];
  var xValue = getXValueByPoint(point, geometry);
  var firstXValue = first[constant_1.FIELD_ORIGIN][xField];
  var firstYValue = first[constant_1.FIELD_ORIGIN][yField];
  var lastXValue = last[constant_1.FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && (0, util_1.isArray)(firstYValue); 
  
  if ((0, util_1.isArray)(firstXValue)) {
    for (var index = 0; index < data.length; index++) {
      var record = data[index];
      var originData = record[constant_1.FIELD_ORIGIN];
      
      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          
          if (!(0, util_1.isArray)(rst)) {
            rst = [];
          }
          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }
    if ((0, util_1.isArray)(rst)) {
      rst = filterYValue(rst, point, geometry);
    }
  } else {
    var next = void 0;
    if (!xScale.isLinear && xScale.type !== 'timeCat') {
      
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var originData = record[constant_1.FIELD_ORIGIN];
        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!(0, util_1.isArray)(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last = record;
          next = data[index + 1];
        }
      }
      if ((0, util_1.isArray)(rst)) {
        rst = filterYValue(rst, point, geometry);
      }
    } else {
      
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        
        return null;
      }
      var firstIdx = 0;
      var lastIdx = data.length - 1;
      var middleIdx = void 0;
      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data[middleIdx][constant_1.FIELD_ORIGIN][xField];
        if (snapEqual(item, xValue, xScale)) {
          return data[middleIdx];
        }
        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last = data[middleIdx];
          next = data[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last = data[0];
          }
          lastIdx = middleIdx - 1;
        }
      }
    }
    if (last && next) {
      
      if (Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[constant_1.FIELD_ORIGIN][xField]) - xValue)) {
        last = next;
      }
    }
  }
  var distance = getXDistance(geometry.getXScale()); 
  if (!rst && Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {
    rst = last;
  }
  return rst;
}
exports.findDataByPoint = findDataByPoint;
function getTooltipItems(data, geometry, title, showNil) {
  if (title === void 0) {
    title = '';
  }
  if (showNil === void 0) {
    showNil = false;
  }
  var originData = data[constant_1.FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry, title);
  var tooltipOption = geometry.tooltipOption;
  var defaultColor = geometry.theme.defaultColor;
  var items = [];
  var name;
  var value;
  function addItem(itemName, itemValue) {
    if (showNil || !(0, util_1.isNil)(itemValue) && itemValue !== '') {
      // 值为 null的时候，忽视
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data,
        name: itemName,
        value: itemValue,
        color: data.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }
  if ((0, util_1.isObject)(tooltipOption)) {
    var fields = tooltipOption.fields,
      callback = tooltipOption.callback;
    if (callback) {
      // 用户定义了回调函数
      var callbackParams = fields.map(function (field) {
        return data[constant_1.FIELD_ORIGIN][field];
      });
      var cfg = callback.apply(void 0, callbackParams);
      var itemCfg = (0, tslib_1.__assign)({
        data: data[constant_1.FIELD_ORIGIN],
        mappingData: data,
        title: tooltipTitle,
        color: data.color || defaultColor,
        marker: true
      }, cfg);
      items.push(itemCfg);
    } else {
      var scales = geometry.scales;
      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
        var field = fields_1[_i];
        if (!(0, util_1.isNil)(originData[field])) {
          // 字段数据为null, undefined 时不显示
          var scale = scales[field];
          name = (0, scale_1.getName)(scale);
          value = scale.getText(originData[field]);
          addItem(name, value);
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry);
    // 字段数据为null ,undefined时不显示
    value = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry);
    addItem(name, value);
  }
  return items;
}
exports.getTooltipItems = getTooltipItems;
function getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var dataArray = geometry.dataArray;
  if (!(0, util_1.isEmpty)(dataArray)) {
    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找
    for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {
      var data = dataArray_1[_i];
      var record = findDataByPoint(point, data, geometry);
      if (record) {
        var elementId = geometry.getElementId(record);
        var element = geometry.elementsMap[elementId];
        if (geometry.type === 'heatmap' || element.visible) {
          
          
          var items = getTooltipItems(record, geometry, title, showNil);
          if (items.length) {
            result.push(items);
          }
        }
      }
    }
  }
  return result;
}
function getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var container = geometry.container;
  var shape = container.getShape(point.x, point.y);
  if (shape && shape.get('visible') && shape.get('origin')) {
    var mappingData = shape.get('origin').mappingData;
    var items = getTooltipItems(mappingData, geometry, title, showNil);
    if (items.length) {
      result.push(items);
    }
  }
  return result;
}
function findItemsFromView(view, point, tooltipCfg) {
  var result = [];
  
  var geometries = view.geometries;
  var shared = tooltipCfg.shared,
    title = tooltipCfg.title,
    reversed = tooltipCfg.reversed;
  for (var _i = 0, geometries_1 = geometries; _i < geometries_1.length; _i++) {
    var geometry = geometries_1[_i];
    if (geometry.visible && geometry.tooltipOption !== false) {
      
      var geometryType = geometry.type;
      var tooltipItems = void 0;
      if (['point', 'edge', 'polygon'].includes(geometryType)) {
        
        tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
      } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {
        
        tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
      } else {
        if (shared !== false) {
          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
        } else {
          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
        }
      }
      if (tooltipItems.length) {
        if (reversed) {
          tooltipItems.reverse();
        }
        
        result.push(tooltipItems);
      }
    }
  }
  return result;
}
exports.findItemsFromView = findItemsFromView;
function findItemsFromViewRecurisive(view, point, tooltipCfg) {
  var result = findItemsFromView(view, point, tooltipCfg);
  
  for (var _i = 0, _a = view.views; _i < _a.length; _i++) {
    var childView = _a[_i];
    result = result.concat(findItemsFromView(childView, point, tooltipCfg));
  }
  return result;
}
exports.findItemsFromViewRecurisive = findItemsFromViewRecurisive;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setGlobal = exports.GLOBAL = void 0;
var util_1 = __webpack_require__(0);
exports.GLOBAL = {
    locale: 'en-US'
};
function setGlobal(datum) {
  util_1.each(datum, function (v, k) {
    return exports.GLOBAL[k] = v;
  });
}
exports.setGlobal = setGlobal;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEndArrow = addEndArrow;
exports.addStartArrow = addStartArrow;
exports.getShortenOffset = getShortenOffset;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var _tslib = __webpack_require__(1);
var _shape = __webpack_require__(147);
var sin = Math.sin,
  cos = Math.cos,
  atan2 = Math.atan2,
  PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke,
    lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new _shape.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: {
      
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      
      stroke: stroke,
      lineWidth: lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow,
    endArrow = attrs.endArrow,
    stroke = attrs.stroke,
    lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d,
    arrowFill = arrowAttrs.fill,
    arrowStroke = arrowAttrs.stroke,
    arrowLineWidth = arrowAttrs.lineWidth,
    restAttrs = (0, _tslib.__rest)(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new _shape.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, restAttrs), {
      
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.startArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set('startArrowShape', null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.endArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set('startArrowShape', null);
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inLine;
var _gMath = __webpack_require__(38);
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  
  
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  
  return _gMath.Line.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Dom", {
  enumerable: true,
  get: function get() {
    return _dom.default;
  }
});
Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return _ellipse.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _image.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return _marker.default;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _path.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return _polyline.default;
  }
});
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return _rect.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return _text.default;
  }
});
var _base = _interopRequireDefault(__webpack_require__(63));
var _circle = _interopRequireDefault(__webpack_require__(967));
var _dom = _interopRequireDefault(__webpack_require__(968));
var _ellipse = _interopRequireDefault(__webpack_require__(969));
var _image = _interopRequireDefault(__webpack_require__(970));
var _line = _interopRequireDefault(__webpack_require__(971));
var _marker = _interopRequireDefault(__webpack_require__(972));
var _path = _interopRequireDefault(__webpack_require__(974));
var _polygon = _interopRequireDefault(__webpack_require__(975));
var _polyline = _interopRequireDefault(__webpack_require__(976));
var _rect = _interopRequireDefault(__webpack_require__(977));
var _text = _interopRequireDefault(__webpack_require__(979));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.freeze = void 0;
var freeze = function freeze(obj) {
  return Object.freeze(obj);
};
exports.freeze = freeze;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSVG = exports.isReplacedElement = exports.isHidden = exports.isElement = void 0;
var isSVG = function isSVG(target) {
  return target instanceof SVGElement && 'getBBox' in target;
};
exports.isSVG = isSVG;
var isHidden = function isHidden(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(),
      width = _a.width,
      height = _a.height;
    return !width && !height;
  }
  var _b = target,
    offsetWidth = _b.offsetWidth,
    offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
exports.isHidden = isHidden;
var isElement = function isElement(obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
exports.isElement = isElement;
var isReplacedElement = function isReplacedElement(target) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }
    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }
  return false;
};
exports.isReplacedElement = isReplacedElement;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cluster", {
  enumerable: true,
  get: function get() {
    return _cluster.default;
  }
});
Object.defineProperty(exports, "hierarchy", {
  enumerable: true,
  get: function get() {
    return _index.default;
  }
});
Object.defineProperty(exports, "pack", {
  enumerable: true,
  get: function get() {
    return _index2.default;
  }
});
Object.defineProperty(exports, "packEnclose", {
  enumerable: true,
  get: function get() {
    return _enclose.default;
  }
});
Object.defineProperty(exports, "packSiblings", {
  enumerable: true,
  get: function get() {
    return _siblings.default;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function get() {
    return _partition.default;
  }
});
Object.defineProperty(exports, "stratify", {
  enumerable: true,
  get: function get() {
    return _stratify.default;
  }
});
Object.defineProperty(exports, "tree", {
  enumerable: true,
  get: function get() {
    return _tree.default;
  }
});
Object.defineProperty(exports, "treemap", {
  enumerable: true,
  get: function get() {
    return _index3.default;
  }
});
Object.defineProperty(exports, "treemapBinary", {
  enumerable: true,
  get: function get() {
    return _binary.default;
  }
});
Object.defineProperty(exports, "treemapDice", {
  enumerable: true,
  get: function get() {
    return _dice.default;
  }
});
Object.defineProperty(exports, "treemapResquarify", {
  enumerable: true,
  get: function get() {
    return _resquarify.default;
  }
});
Object.defineProperty(exports, "treemapSlice", {
  enumerable: true,
  get: function get() {
    return _slice.default;
  }
});
Object.defineProperty(exports, "treemapSliceDice", {
  enumerable: true,
  get: function get() {
    return _sliceDice.default;
  }
});
Object.defineProperty(exports, "treemapSquarify", {
  enumerable: true,
  get: function get() {
    return _squarify.default;
  }
});
var _cluster = _interopRequireDefault(__webpack_require__(1092));
var _index = _interopRequireDefault(__webpack_require__(297));
var _index2 = _interopRequireDefault(__webpack_require__(1108));
var _siblings = _interopRequireDefault(__webpack_require__(515));
var _enclose = _interopRequireDefault(__webpack_require__(517));
var _partition = _interopRequireDefault(__webpack_require__(1109));
var _stratify = _interopRequireDefault(__webpack_require__(1110));
var _tree = _interopRequireDefault(__webpack_require__(1111));
var _index3 = _interopRequireDefault(__webpack_require__(1112));
var _binary = _interopRequireDefault(__webpack_require__(1113));
var _dice = _interopRequireDefault(__webpack_require__(155));
var _slice = _interopRequireDefault(__webpack_require__(194));
var _sliceDice = _interopRequireDefault(__webpack_require__(1114));
var _squarify = _interopRequireDefault(__webpack_require__(299));
var _resquarify = _interopRequireDefault(__webpack_require__(1115));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
    node,
    i = -1,
    n = nodes.length,
    k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.legend = exports.meta = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var common_1 = __webpack_require__(34);
var conversion_tag_1 = __webpack_require__(1121);
var connected_area_1 = __webpack_require__(1122);
var geometries_1 = __webpack_require__(43);
var pattern_1 = __webpack_require__(153);
var brush_1 = __webpack_require__(522);
var utils_1 = __webpack_require__(15);
var percent_1 = __webpack_require__(119);
function defaultOptions(params) {
  var options = params.options;
  
  var legend = options.legend;
  var seriesField = options.seriesField,
    isStack = options.isStack;
  if (seriesField) {
    if (legend !== false) {
      legend = tslib_1.__assign({
        position: isStack ? 'right-top' : 'top-left'
      }, legend);
    }
  } else {
    legend = false;
  }
  
  params.options.legend = legend;
  return params;
}
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    columnStyle = options.columnStyle,
    color = options.color,
    columnWidthRatio = options.columnWidthRatio,
    isPercent = options.isPercent,
    isGroup = options.isGroup,
    isStack = options.isStack,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField,
    groupField = options.groupField,
    tooltip = options.tooltip,
    shape = options.shape;
  var percentData = isPercent && isGroup && isStack ? percent_1.getDeepPercent(data, yField, [xField, groupField], yField) : percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent);
  var chartData = [];
  
  if (isStack && seriesField && !isGroup) {
    percentData.forEach(function (item) {
      var stackedItem = chartData.find(function (v) {
        return v[xField] === item[xField] && v[seriesField] === item[seriesField];
      });
      if (stackedItem) {
        stackedItem[yField] += item[yField] || 0;
      } else {
        chartData.push(tslib_1.__assign({}, item));
      }
    });
  } else {
    chartData = percentData;
  }
  chart.data(chartData);
  
  var tooltipOptions = isPercent ? tslib_1.__assign({
    formatter: function formatter(datum) {
      return {
        name: isGroup && isStack ? datum[seriesField] + " - " + datum[groupField] : datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var p = utils_1.deepAssign({}, params, {
    options: {
      data: chartData,
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        shape: shape,
        style: columnStyle,
        color: color
      }
    }
  });
  geometries_1.interval(p);
  return p;
}
function meta(params) {
  var _a, _b;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField,
    data = options.data,
    isPercent = options.isPercent;
  var percentYMeta = isPercent ? {
    max: 1,
    min: 0,
    minLimit: 0,
    maxLimit: 1
  } : {};
  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = tslib_1.__assign(tslib_1.__assign({}, utils_1.adjustYMetaByZero(data, yField)), percentYMeta), _b)))(params);
}
exports.meta = meta;
function axis(params) {
  var chart = params.chart,
    options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField;
  
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    seriesField = options.seriesField;
  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }
  return params;
}
exports.legend = legend;
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    yField = options.yField,
    isRange = options.isRange;
  var geometry = utils_1.findGeometry(chart, 'interval');
  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
      cfg = tslib_1.__rest(label, ["callback"]);
    geometry.label({
      fields: [yField],
      callback: callback,
      cfg: tslib_1.__assign({
        
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? undefined : [{
          type: 'interval-adjust-position'
        }, {
          type: 'interval-hide-overlap'
        }, {
          type: 'adjust-color'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, utils_1.transformLabel(isRange ? tslib_1.__assign({
        content: function content(item) {
          var _a;
          return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
        }
      }, cfg) : cfg))
    });
  }
  return params;
}
function columnTooltip(params) {
  var chart = params.chart,
    options = params.options;
  var tooltip = options.tooltip,
    isGroup = options.isGroup,
    isStack = options.isStack,
    groupField = options.groupField,
    data = options.data,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField;
  if (tooltip === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip;
    
    if (isGroup && isStack) {
      var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || function (datum) {
        return {
          name: datum[seriesField] + " - " + datum[groupField],
          value: datum[yField]
        };
      };
      tooltipOptions = tslib_1.__assign(tslib_1.__assign({}, tooltipOptions), {
        customItems: function customItems(originalItems) {
          var items = [];
          util_1.each(originalItems, function (item) {
            
            var datas = util_1.filter(data, function (d) {
              return util_1.isMatch(d, utils_1.pick(item.data, [xField, seriesField]));
            });
            datas.forEach(function (datum) {
              items.push(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, item), {
                value: datum[yField],
                data: datum,
                mappingData: {
                  _origin: datum
                }
              }), tooltipFormatter_1(datum)));
            });
          });
          return items;
        }
      });
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptor(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }
  var options = params.options;
  var seriesField = options.seriesField;
  return utils_1.flow(defaultOptions,
  
  common_1.theme,
  
  pattern_1.pattern('columnStyle'), common_1.state, geometry, meta, axis, legend, columnTooltip, common_1.slider, common_1.scrollbar, label, brush_1.brushInteraction, common_1.interaction, common_1.animation, common_1.annotation(), conversion_tag_1.conversionTag(options.yField, !isBar, !!seriesField),
  
  connected_area_1.connectedArea(!options.isStack), common_1.limitInPlot)(params);
}
exports.adaptor = adaptor;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLocale = getLocale;
exports.registerLocale = registerLocale;
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
var _global = __webpack_require__(543);
var LocaleMap = {};
function registerLocale(locale, localeObj) {
  LocaleMap[locale] = localeObj;
}
function getLocale(locale) {
  return {
    get: function get(key, obj) {
      return (0, _utils.template)((0, _util.get)(LocaleMap[locale], key) || (0, _util.get)(LocaleMap[_global.GLOBAL.locale], key) || (0, _util.get)(LocaleMap['en-US'], key) || key, obj);
    }
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adjustYMetaByZero = adjustYMetaByZero;
exports.processIllegalData = processIllegalData;
exports.transformDataToNodeLinkData = transformDataToNodeLinkData;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _invariant = __webpack_require__(539);
var _pick = __webpack_require__(538);
function adjustYMetaByZero(data, field) {
  
  var numberData = data.filter(function (datum) {
    var v = (0, _util.get)(datum, [field]);
    return (0, _util.isNumber)(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function (datum) {
    return (0, _util.get)(datum, [field]) >= 0;
  });
  var ltZero = numberData.every(function (datum) {
    return (0, _util.get)(datum, [field]) <= 0;
  });
  
  if (gtZero) {
    return {
      min: 0
    };
  }
  if (ltZero) {
    return {
      max: 0
    };
  }
  return {};
}
function transformDataToNodeLinkData(data, sourceField, targetField, weightField, rawFields) {
  if (rawFields === void 0) {
    rawFields = [];
  }
  if (!Array.isArray(data)) {
    return {
      nodes: [],
      links: []
    };
  }
  
  var links = [];
  
  var nodesMap = {};
  var nodesIndex = -1;
  
  data.forEach(function (datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField];
    var rawData = (0, _pick.pick)(datum, rawFields);
    
    if (!nodesMap[source]) {
      nodesMap[source] = (0, _tslib.__assign)({
        id: ++nodesIndex,
        name: source
      }, rawData);
    }
    if (!nodesMap[target]) {
      nodesMap[target] = (0, _tslib.__assign)({
        id: ++nodesIndex,
        name: target
      }, rawData);
    }
    
    links.push((0, _tslib.__assign)({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      
      
      value: weight
    }, rawData));
  });
  return {
    
    nodes: Object.values(nodesMap).sort(function (a, b) {
      return a.id - b.id;
    }),
    links: links
  };
}
function processIllegalData(data, field) {
  var processData = (0, _util.filter)(data, function (d) {
    var v = d[field];
    return v === null || typeof v === 'number' && !isNaN(v);
  });
  
  (0, _invariant.log)(_invariant.LEVEL.WARN, processData.length === data.length, 'illegal data existed in chart data.');
  return processData;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.legend = legend;
exports.meta = meta;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _common = __webpack_require__(22);
var _conversionTag = __webpack_require__(1196);
var _connectedArea = __webpack_require__(1197);
var _geometries = __webpack_require__(30);
var _pattern = __webpack_require__(122);
var _brush = __webpack_require__(552);
var _utils = __webpack_require__(7);
var _percent = __webpack_require__(123);
function defaultOptions(params) {
  var options = params.options;
  
  var legend = options.legend;
  var seriesField = options.seriesField,
    isStack = options.isStack;
  if (seriesField) {
    if (legend !== false) {
      legend = (0, _tslib.__assign)({
        position: isStack ? 'right-top' : 'top-left'
      }, legend);
    }
  } else {
    legend = false;
  }
  
  params.options.legend = legend;
  return params;
}
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    columnStyle = options.columnStyle,
    color = options.color,
    columnWidthRatio = options.columnWidthRatio,
    isPercent = options.isPercent,
    isGroup = options.isGroup,
    isStack = options.isStack,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField,
    groupField = options.groupField,
    tooltip = options.tooltip,
    shape = options.shape;
  var percentData = isPercent && isGroup && isStack ? (0, _percent.getDeepPercent)(data, yField, [xField, groupField], yField) : (0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent);
  var chartData = [];
  
  if (isStack && seriesField && !isGroup) {
    percentData.forEach(function (item) {
      var stackedItem = chartData.find(function (v) {
        return v[xField] === item[xField] && v[seriesField] === item[seriesField];
      });
      if (stackedItem) {
        stackedItem[yField] += item[yField] || 0;
      } else {
        chartData.push((0, _tslib.__assign)({}, item));
      }
    });
  } else {
    chartData = percentData;
  }
  chart.data(chartData);
  
  var tooltipOptions = isPercent ? (0, _tslib.__assign)({
    formatter: function formatter(datum) {
      return {
        name: isGroup && isStack ? datum[seriesField] + " - " + datum[groupField] : datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      data: chartData,
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        shape: shape,
        style: columnStyle,
        color: color
      }
    }
  });
  (0, _geometries.interval)(p);
  return p;
}
function meta(params) {
  var _a, _b;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField,
    data = options.data,
    isPercent = options.isPercent;
  var percentYMeta = isPercent ? {
    max: 1,
    min: 0,
    minLimit: 0,
    maxLimit: 1
  } : {};
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _utils.adjustYMetaByZero)(data, yField)), percentYMeta), _b)))(params);
}
function axis(params) {
  var chart = params.chart,
    options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField;
  
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    seriesField = options.seriesField;
  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }
  return params;
}
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    yField = options.yField,
    isRange = options.isRange;
  var geometry = (0, _utils.findGeometry)(chart, 'interval');
  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
      cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _tslib.__assign)({
        
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? undefined : [{
          type: 'interval-adjust-position'
        }, {
          type: 'interval-hide-overlap'
        }, {
          type: 'adjust-color'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, (0, _utils.transformLabel)(isRange ? (0, _tslib.__assign)({
        content: function content(item) {
          var _a;
          return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
        }
      }, cfg) : cfg))
    });
  }
  return params;
}
function columnTooltip(params) {
  var chart = params.chart,
    options = params.options;
  var tooltip = options.tooltip,
    isGroup = options.isGroup,
    isStack = options.isStack,
    groupField = options.groupField,
    data = options.data,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField;
  if (tooltip === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip;
    
    if (isGroup && isStack) {
      var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || function (datum) {
        return {
          name: datum[seriesField] + " - " + datum[groupField],
          value: datum[yField]
        };
      };
      tooltipOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tooltipOptions), {
        customItems: function customItems(originalItems) {
          var items = [];
          (0, _util.each)(originalItems, function (item) {
            
            var datas = (0, _util.filter)(data, function (d) {
              return (0, _util.isMatch)(d, (0, _utils.pick)(item.data, [xField, seriesField]));
            });
            datas.forEach(function (datum) {
              items.push((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, item), {
                value: datum[yField],
                data: datum,
                mappingData: {
                  _origin: datum
                }
              }), tooltipFormatter_1(datum)));
            });
          });
          return items;
        }
      });
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptor(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }
  var options = params.options;
  var seriesField = options.seriesField;
  return (0, _utils.flow)(defaultOptions,
  
  _common.theme,
  
  (0, _pattern.pattern)('columnStyle'), _common.state, geometry, meta, axis, legend, columnTooltip, _common.slider, _common.scrollbar, label, _brush.brushInteraction, _common.interaction, _common.animation, (0, _common.annotation)(), (0, _conversionTag.conversionTag)(options.yField, !isBar, !!seriesField),
  
  (0, _connectedArea.connectedArea)(!options.isStack), _common.limitInPlot)(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.meta = meta;
var _common = __webpack_require__(22);
var _utils = __webpack_require__(7);
var _geometries = __webpack_require__(30);
var _constants = __webpack_require__(156);
var _utils2 = __webpack_require__(124);
var _data = __webpack_require__(197);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    color = options.color,
    areaStyle = options.areaStyle,
    pointOptions = options.point,
    lineOptions = options.line;
  var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
  var seriesData = (0, _utils2.getTinyData)(data);
  chart.data(seriesData);
  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constants.X_FIELD,
      yField: _constants.Y_FIELD,
      area: {
        color: color,
        style: areaStyle
      },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false
    }
  });
  var pointParams = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  
  (0, _geometries.area)(primary);
  (0, _geometries.line)(second);
  (0, _geometries.point)(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function meta(params) {
  var _a, _b;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    data = options.data;
  var seriesData = (0, _utils2.getTinyData)(data);
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[_constants.X_FIELD] = xAxis, _a[_constants.Y_FIELD] = yAxis, _a), (_b = {}, _b[_constants.X_FIELD] = {
    type: 'cat'
  }, _b[_constants.Y_FIELD] = (0, _data.adjustYMetaByZero)(seriesData, _constants.Y_FIELD), _b)))(params);
}
function adaptor(params) {
  return (0, _utils.flow)((0, _common.pattern)('areaStyle'), geometry, meta, _common.tooltip, _common.theme, _common.animation, (0, _common.annotation)())(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PATH_FIELD = exports.ID_FIELD = exports.DEFAULT_OPTIONS = void 0;

var ID_FIELD = 'id';
exports.ID_FIELD = ID_FIELD;
var PATH_FIELD = 'path';
exports.PATH_FIELD = PATH_FIELD;
var DEFAULT_OPTIONS = {
  appendPadding: [10, 0, 20, 0],
  blendMode: 'multiply',
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ['id', 'size'],
    formatter: function formatter(datum) {
      return {
        name: datum.id,
        value: datum.size
      };
    }
  },
  legend: {
    position: 'top-left'
  },
  label: {
    style: {
      textAlign: 'center',
      fill: '#fff'
    }
  },
  
  interactions: [{
    type: 'legend-filter',
    enable: false
  }],
  state: {
    active: {
      style: {
        stroke: '#000'
      }
    },
    selected: {
      style: {
        stroke: '#000',
        lineWidth: 2
      }
    },
    inactive: {
      style: {
        fillOpacity: 0.3,
        strokeOpacity: 0.3
      }
    }
  },
  
  defaultInteractions: ['tooltip', 'venn-legend-active']
};
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PADDING_TOP = exports.HIERARCHY_DATA_TRANSFORM_PARAMS = exports.DrillDownAction = exports.DEFAULT_BREAD_CRUMB_CONFIG = exports.BREAD_CRUMB_NAME = void 0;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var _util = __webpack_require__(0);
var _deepAssign = __webpack_require__(541);

var PADDING = 4;

var PADDING_LEFT = 0;

var PADDING_TOP = 5;
exports.PADDING_TOP = PADDING_TOP;
var BREAD_CRUMB_NAME = 'drilldown-bread-crumb';

exports.BREAD_CRUMB_NAME = BREAD_CRUMB_NAME;
var DEFAULT_BREAD_CRUMB_CONFIG = {
    position: 'top-left',
  dividerText: '/',
  textStyle: {
    fontSize: 12,
    fill: 'rgba(0, 0, 0, 0.65)',
    cursor: 'pointer'
  },
  activeTextStyle: {
    fill: '#87B5FF'
  }
};
exports.DEFAULT_BREAD_CRUMB_CONFIG = DEFAULT_BREAD_CRUMB_CONFIG;
var HIERARCHY_DATA_TRANSFORM_PARAMS = 'hierarchy-data-transform-params';
exports.HIERARCHY_DATA_TRANSFORM_PARAMS = HIERARCHY_DATA_TRANSFORM_PARAMS;
var DrillDownAction = function (_super) {
  (0, _tslib.__extends)(DrillDownAction, _super);
  function DrillDownAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'drill-down';
    
    _this.historyCache = [];
    
    _this.breadCrumbGroup = null;
    
    _this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
    return _this;
  }
    DrillDownAction.prototype.click = function () {
    var data = (0, _util.get)(this.context, ['event', 'data', 'data']);
    if (!data) return false;
    this.drill(data);
    this.drawBreadCrumb();
  };
    DrillDownAction.prototype.resetPosition = function () {
    
    if (!this.breadCrumbGroup) return;
    var coordinate = this.context.view.getCoordinate();
    var breadCrumbGroup = this.breadCrumbGroup;
    var bbox = breadCrumbGroup.getBBox();
    var position = this.getButtonCfg().position;
    
    
    var point = {
      x: coordinate.start.x,
      y: coordinate.end.y - (bbox.height + PADDING_TOP * 2)
    };
    if (coordinate.isPolar) {
      
      point = {
        x: 0,
        y: 0
      };
    }
    if (position === 'bottom-left') {
      
      point = {
        x: coordinate.start.x,
        y: coordinate.start.y
      };
    }
        var matrix = _g.Util.transform(null, [['t', point.x + PADDING_LEFT, point.y + bbox.height + PADDING_TOP]]);
    breadCrumbGroup.setMatrix(matrix);
  };
    DrillDownAction.prototype.back = function () {
    if ((0, _util.size)(this.historyCache)) {
      this.backTo(this.historyCache.slice(0, -1));
    }
  };
    DrillDownAction.prototype.reset = function () {
    if (this.historyCache[0]) {
      this.backTo(this.historyCache.slice(0, 1));
    }
    
    this.historyCache = [];
    this.hideCrumbGroup();
  };
    DrillDownAction.prototype.drill = function (nodeInfo) {
    var view = this.context.view;
    var transformData = (0, _util.get)(view, ['interactions', 'drill-down', 'cfg', 'transformData'], function (v) {
      return v;
    });
    
    var drillData = transformData((0, _tslib.__assign)({
      data: nodeInfo.data
    }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
    view.changeData(drillData);
    
    var historyCache = [];
    var node = nodeInfo;
    while (node) {
      var nodeData = node.data;
      historyCache.unshift({
        id: nodeData.name + "_" + node.height + "_" + node.depth,
        name: nodeData.name,
        
        children: transformData((0, _tslib.__assign)({
          data: nodeData
        }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]))
      });
      node = node.parent;
    }
    this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
  };
    DrillDownAction.prototype.backTo = function (historyCache) {
    if (!historyCache || historyCache.length <= 0) {
      return;
    }
    var view = this.context.view;
    var data = (0, _util.last)(historyCache).children; 
    view.changeData(data);
    if (historyCache.length > 1) {
      this.historyCache = historyCache;
      this.drawBreadCrumb();
    } else {
      
      this.historyCache = [];
      this.hideCrumbGroup();
    }
  };
    DrillDownAction.prototype.getButtonCfg = function () {
    var view = this.context.view;
    var drillDownConfig = (0, _util.get)(view, ['interactions', 'drill-down', 'cfg', 'drillDownConfig']);
    return (0, _deepAssign.deepAssign)(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
  };
    DrillDownAction.prototype.drawBreadCrumb = function () {
    this.drawBreadCrumbGroup();
    this.resetPosition();
    this.breadCrumbGroup.show();
  };
    DrillDownAction.prototype.drawBreadCrumbGroup = function () {
    var _this = this;
    var config = this.getButtonCfg();
    var cache = this.historyCache;
    
    if (!this.breadCrumbGroup) {
      this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
        name: BREAD_CRUMB_NAME
      });
    } else {
      this.breadCrumbGroup.clear();
    }
    
    var left = 0;
    cache.forEach(function (record, index) {
      
      var textShape = _this.breadCrumbGroup.addShape({
        type: 'text',
        id: record.id,
        name: BREAD_CRUMB_NAME + "_" + record.name + "_text",
        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({
          text: index === 0 && !(0, _util.isNil)(config.rootText) ? config.rootText : record.name
        }, config.textStyle), {
          x: left,
          y: 0
        })
      });
      var textShapeBox = textShape.getBBox();
      left += textShapeBox.width + PADDING;
      
      textShape.on('click', function (event) {
        var _a;
        var targetId = event.target.get('id');
        if (targetId !== ((_a = (0, _util.last)(cache)) === null || _a === void 0 ? void 0 : _a.id)) {
          var newHistoryCache = cache.slice(0, cache.findIndex(function (d) {
            return d.id === targetId;
          }) + 1);
          _this.backTo(newHistoryCache);
        }
      });
      
      textShape.on('mouseenter', function (event) {
        var _a;
        var targetId = event.target.get('id');
        if (targetId !== ((_a = (0, _util.last)(cache)) === null || _a === void 0 ? void 0 : _a.id)) {
          textShape.attr(config.activeTextStyle);
        } else {
          textShape.attr({
            cursor: 'default'
          });
        }
      });
      textShape.on('mouseleave', function () {
        textShape.attr(config.textStyle);
      });
      if (index < cache.length - 1) {
        
        var dividerShape = _this.breadCrumbGroup.addShape({
          type: 'text',
          name: config.name + "_" + record.name + "_divider",
          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({
            text: config.dividerText
          }, config.textStyle), {
            x: left,
            y: 0
          })
        });
        var dividerBox = dividerShape.getBBox();
        left += dividerBox.width + PADDING;
      }
    });
  };
    DrillDownAction.prototype.hideCrumbGroup = function () {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.hide();
    }
  };
    DrillDownAction.prototype.destroy = function () {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return DrillDownAction;
}(_g.Action);
exports.DrillDownAction = DrillDownAction;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTextPoint = exports.toPx = exports.updateClip = exports.getBBoxWithClip = exports.mergeBBox = exports.intersectBBox = exports.near = exports.wait = exports.distance = exports.getCirclePoint = exports.getValueByPercent = exports.createBBox = exports.pointsToBBox = exports.regionToBBox = exports.hasClass = exports.clearDom = exports.formatPadding = void 0;
var util_1 = __webpack_require__(0);
function formatPadding(padding) {
  var top = 0;
  var left = 0;
  var right = 0;
  var bottom = 0;
  if (util_1.isNumber(padding)) {
    top = left = right = bottom = padding;
  } else if (util_1.isArray(padding)) {
    top = padding[0];
    right = !util_1.isNil(padding[1]) ? padding[1] : padding[0];
    bottom = !util_1.isNil(padding[2]) ? padding[2] : padding[0];
    left = !util_1.isNil(padding[3]) ? padding[3] : right;
  }
  return [top, right, bottom, left];
}
exports.formatPadding = formatPadding;
function clearDom(container) {
  var children = container.childNodes;
  var length = children.length;
  for (var i = length - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}
exports.clearDom = clearDom;
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
exports.hasClass = hasClass;
function regionToBBox(region) {
  var start = region.start,
    end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
exports.regionToBBox = regionToBBox;
function pointsToBBox(points) {
  var xs = points.map(function (point) {
    return point.x;
  });
  var ys = points.map(function (point) {
    return point.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
exports.pointsToBBox = pointsToBBox;
function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY = y + height;
  return {
    x: x,
    y: y,
    width: width,
    height: height,
    minX: x,
    minY: y,
    
    
    
    
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY) ? 0 : maxY
  };
}
exports.createBBox = createBBox;
function getValueByPercent(min, max, percent) {
  return (1 - percent) * min + max * percent;
}
exports.getValueByPercent = getValueByPercent;
function getCirclePoint(center, radius, angle) {
  return {
    x: center.x + Math.cos(angle) * radius,
    y: center.y + Math.sin(angle) * radius
  };
}
exports.getCirclePoint = getCirclePoint;
function distance(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
exports.distance = distance;
exports.wait = function (interval) {
  return new Promise(function (resolve) {
    setTimeout(resolve, interval);
  });
};
exports.near = function (x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }
  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}
exports.intersectBBox = intersectBBox;
function mergeBBox(box1, box2) {
  var minX = Math.min(box1.minX, box2.minX);
  var minY = Math.min(box1.minY, box2.minY);
  var maxX = Math.max(box1.maxX, box2.maxX);
  var maxY = Math.max(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}
exports.mergeBBox = mergeBBox;
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      util_1.each(children, function (child) {
        if (child.get('visible')) {
          
          if (child.isGroup() && child.get('children').length === 0) {
            return true;
          }
          var box = getBBoxWithClip(child);
          
          var leftTop = child.applyToMatrix([box.minX, box.minY, 1]);
          var leftBottom = child.applyToMatrix([box.minX, box.maxY, 1]);
          var rightTop = child.applyToMatrix([box.maxX, box.minY, 1]);
          var rightBottom = child.applyToMatrix([box.maxX, box.maxY, 1]);
          
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox(bbox, clipBBox);
  } else {
    return bbox;
  }
}
exports.getBBoxWithClip = getBBoxWithClip;
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    
    element.setClip(null); 
    return;
  }
  var clipCfg = {
    type: newClipShape.get('type'),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
exports.updateClip = updateClip;
function toPx(number) {
  return number + "px";
}
exports.toPx = toPx;
function getTextPoint(start, end, position, offset) {
  var lineLength = distance(start, end);
  var offsetPercent = offset / lineLength; 
  var percent = 0;
  if (position === 'start') {
    percent = 0 - offsetPercent;
  } else if (position === 'end') {
    percent = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent),
    y: getValueByPercent(start.y, end.y, percent)
  };
}
exports.getTextPoint = getTextPoint;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCallbackAction = exports.unregisterAction = exports.registerAction = exports.getActionClass = exports.createAction = void 0;
var tslib_1 = __webpack_require__(1);
var callback_1 = (0, tslib_1.__importDefault)(__webpack_require__(937));
var util_1 = __webpack_require__(0);

var ActionCache = {};
function createAction(actionName, context) {
  var actionOption = ActionCache[actionName];
  var action = null;
  if (actionOption) {
    var ActionClass = actionOption.ActionClass,
      cfg = actionOption.cfg;
    action = new ActionClass(context, cfg);
    action.name = actionName;
    action.init();
  }
  return action;
}
exports.createAction = createAction;
function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return (0, util_1.get)(actionOption, 'ActionClass');
}
exports.getActionClass = getActionClass;
function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass: ActionClass,
    cfg: cfg
  };
}
exports.registerAction = registerAction;
function unregisterAction(actionName) {
  delete ActionCache[actionName];
}
exports.unregisterAction = unregisterAction;
function createCallbackAction(callback, context) {
  var action = new callback_1.default(context);
  action.callback = callback;
  action.name = 'callback';
  return action;
}
exports.createCallbackAction = createCallbackAction;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var dependents_1 = __webpack_require__(69);
var coordinate_1 = __webpack_require__(48);
var graphics_1 = __webpack_require__(46);
var tooltip_1 = __webpack_require__(186);
var bbox_1 = __webpack_require__(80);
var base_1 = __webpack_require__(104);
var event_1 = (0, tslib_1.__importDefault)(__webpack_require__(268));

function uniq(items) {
  var uniqItems = [];
  var _loop_1 = function _loop_1(index) {
    var item = items[index];
    var result = (0, util_1.find)(uniqItems, function (subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });
    if (!result) {
      uniqItems.push(item);
    }
  };
  for (var index = 0; index < items.length; index++) {
    _loop_1(index);
  }
  return uniqItems;
}
var Tooltip = function (_super) {
  (0, tslib_1.__extends)(Tooltip, _super);
  function Tooltip() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isLocked = false;
    return _this;
  }
  Object.defineProperty(Tooltip.prototype, "name", {
    get: function get() {
      return 'tooltip';
    },
    enumerable: false,
    configurable: true
  });
  Tooltip.prototype.init = function () {};
  Tooltip.prototype.isVisible = function () {
    var option = this.view.getOptions().tooltip;
    return option !== false;
  };
  Tooltip.prototype.render = function () {};
    Tooltip.prototype.showTooltip = function (point) {
    this.point = point;
    if (!this.isVisible()) {
      
      return;
    }
    var view = this.view;
    var items = this.getTooltipItems(point);
    if (!items.length) {
      
      this.hideTooltip();
      return;
    }
    var title = this.getTitle(items);
    var dataPoint = {
      x: items[0].x,
      y: items[0].y
    }; 
    view.emit('tooltip:show', event_1.default.fromData(view, 'tooltip:show', (0, tslib_1.__assign)({
      items: items,
      title: title
    }, point)));
    var cfg = this.getTooltipCfg();
    var follow = cfg.follow,
      showMarkers = cfg.showMarkers,
      showCrosshairs = cfg.showCrosshairs,
      showContent = cfg.showContent,
      marker = cfg.marker;
    var lastItems = this.items;
    var lastTitle = this.title;
    if (!(0, util_1.isEqual)(lastTitle, title) || !(0, util_1.isEqual)(lastItems, items)) {
      
      view.emit('tooltip:change', event_1.default.fromData(view, 'tooltip:change', (0, tslib_1.__assign)({
        items: items,
        title: title
      }, point)));
      if ((0, util_1.isFunction)(showContent) ? showContent(items) : showContent) {
        
        if (!this.tooltip) {
          
          this.renderTooltip();
        }
        this.tooltip.update((0, util_1.mix)({}, cfg, {
          items: this.getItemsAfterProcess(items),
          title: title
        }, follow ? point : {}));
        this.tooltip.show();
      }
      if (showMarkers) {
        
        this.renderTooltipMarkers(items, marker);
      }
    } else {
      
      if (this.tooltip && follow) {
        this.tooltip.update(point);
        this.tooltip.show(); 
      }

      if (this.tooltipMarkersGroup) {
        this.tooltipMarkersGroup.show();
      }
    }
    this.items = items;
    this.title = title;
    if (showCrosshairs) {
      
      var isCrosshairsFollowCursor = (0, util_1.get)(cfg, ['crosshairs', 'follow'], false); 
      this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);
    }
  };
  Tooltip.prototype.hideTooltip = function () {
    var follow = this.getTooltipCfg().follow;
    if (!follow) {
      this.point = null;
      return;
    }
    
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.hide();
    }
    
    var xCrosshair = this.xCrosshair;
    var yCrosshair = this.yCrosshair;
    if (xCrosshair) {
      xCrosshair.hide();
    }
    if (yCrosshair) {
      yCrosshair.hide();
    }
    var tooltip = this.tooltip;
    if (tooltip) {
      tooltip.hide();
    }
    this.view.emit('tooltip:hide', event_1.default.fromData(this.view, 'tooltip:hide', {}));
    this.point = null;
  };
    Tooltip.prototype.lockTooltip = function () {
    this.isLocked = true;
    if (this.tooltip) {
      
      this.tooltip.setCapture(true);
    }
  };
    Tooltip.prototype.unlockTooltip = function () {
    this.isLocked = false;
    var cfg = this.getTooltipCfg();
    if (this.tooltip) {
      
      this.tooltip.setCapture(cfg.capture);
    }
  };
    Tooltip.prototype.isTooltipLocked = function () {
    return this.isLocked;
  };
  Tooltip.prototype.clear = function () {
    var _a = this,
      tooltip = _a.tooltip,
      xCrosshair = _a.xCrosshair,
      yCrosshair = _a.yCrosshair,
      tooltipMarkersGroup = _a.tooltipMarkersGroup;
    if (tooltip) {
      tooltip.hide();
      tooltip.clear();
    }
    if (xCrosshair) {
      xCrosshair.clear();
    }
    if (yCrosshair) {
      yCrosshair.clear();
    }
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.clear();
    }
    
    if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.get("customContent")) {
      this.tooltip.destroy();
      this.tooltip = null;
    }
    
    
    this.title = null;
    this.items = null;
  };
  Tooltip.prototype.destroy = function () {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    if (this.xCrosshair) {
      this.xCrosshair.destroy();
    }
    if (this.yCrosshair) {
      this.yCrosshair.destroy();
    }
    if (this.guideGroup) {
      this.guideGroup.remove(true);
    }
    this.reset();
  };
  Tooltip.prototype.reset = function () {
    this.items = null;
    this.title = null;
    this.tooltipMarkersGroup = null;
    this.tooltipCrosshairsGroup = null;
    this.xCrosshair = null;
    this.yCrosshair = null;
    this.tooltip = null;
    this.guideGroup = null;
    this.isLocked = false;
    this.point = null;
  };
  Tooltip.prototype.changeVisible = function (visible) {
    if (this.visible === visible) {
      return;
    }
    var _a = this,
      tooltip = _a.tooltip,
      tooltipMarkersGroup = _a.tooltipMarkersGroup,
      xCrosshair = _a.xCrosshair,
      yCrosshair = _a.yCrosshair;
    if (visible) {
      if (tooltip) {
        tooltip.show();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.show();
      }
      if (xCrosshair) {
        xCrosshair.show();
      }
      if (yCrosshair) {
        yCrosshair.show();
      }
    } else {
      if (tooltip) {
        tooltip.hide();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
    }
    this.visible = visible;
  };
  Tooltip.prototype.getTooltipItems = function (point) {
    var items = this.findItemsFromView(this.view, point);
    if (items.length) {
      
      items = (0, util_1.flatten)(items);
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var itemArr = items_1[_i];
        for (var _a = 0, itemArr_1 = itemArr; _a < itemArr_1.length; _a++) {
          var item = itemArr_1[_a];
          var _b = item.mappingData,
            x = _b.x,
            y = _b.y;
          item.x = (0, util_1.isArray)(x) ? x[x.length - 1] : x;
          item.y = (0, util_1.isArray)(y) ? y[y.length - 1] : y;
        }
      }
      var shared = this.getTooltipCfg().shared;
      
      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min = Math.abs(point.y - snapItem[0].y);
        for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
          var aItem = items_2[_c];
          var yDistance = Math.abs(point.y - aItem[0].y);
          if (yDistance <= min) {
            snapItem = aItem;
            min = yDistance;
          }
        }
        items = [snapItem];
      }
      return uniq((0, util_1.flatten)(items));
    }
    return [];
  };
  Tooltip.prototype.layout = function () {};
  Tooltip.prototype.update = function () {
    if (this.point) {
      this.showTooltip(this.point);
    }
    if (this.tooltip) {
      
      
      var canvas = this.view.getCanvas();
      
      
      this.tooltip.set('region', {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: canvas.get('width'),
          y: canvas.get('height')
        }
      });
    }
  };
    Tooltip.prototype.isCursorEntered = function (point) {
    
    if (this.tooltip) {
      var el = this.tooltip.getContainer();
      var capture = this.tooltip.get('capture');
      if (el && capture) {
        var _a = el.getBoundingClientRect(),
          x = _a.x,
          y = _a.y,
          width = _a.width,
          height = _a.height;
        return new bbox_1.BBox(x, y, width, height).isPointIn(point);
      }
    }
    return false;
  };
  
  Tooltip.prototype.getTooltipCfg = function () {
    var view = this.view;
    var option = view.getOptions().tooltip;
    var processOption = this.processCustomContent(option);
    var theme = view.getTheme();
    var defaultCfg = (0, util_1.get)(theme, ['components', 'tooltip'], {});
    var enterable = (0, util_1.get)(processOption, 'enterable', defaultCfg.enterable);
    return (0, util_1.deepMix)({}, defaultCfg, processOption, {
      capture: enterable || this.isLocked ? true : false
    });
  };
  
  Tooltip.prototype.processCustomContent = function (option) {
    if ((0, util_1.isBoolean)(option) || !(0, util_1.get)(option, 'customContent')) {
      return option;
    }
    var currentCustomContent = option.customContent;
    var customContent = function customContent(title, items) {
      var content = currentCustomContent(title, items) || '';
      return (0, util_1.isString)(content) ? '<div class="g2-tooltip">' + content + '</div>' : content;
    };
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
      customContent: customContent
    });
  };
  Tooltip.prototype.getTitle = function (items) {
    var title = items[0].title || items[0].name;
    this.title = title;
    return title;
  };
  Tooltip.prototype.renderTooltip = function () {
    var canvas = this.view.getCanvas();
    var region = {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: canvas.get('width'),
        y: canvas.get('height')
      }
    };
    var cfg = this.getTooltipCfg();
    var tooltip = new dependents_1.HtmlTooltip((0, tslib_1.__assign)((0, tslib_1.__assign)({
      parent: canvas.get('el').parentNode,
      region: region
    }, cfg), {
      visible: false,
      crosshairs: null
    }));
    tooltip.init();
    this.tooltip = tooltip;
  };
  Tooltip.prototype.renderTooltipMarkers = function (items, marker) {
    var tooltipMarkersGroup = this.getTooltipMarkersGroup();
    for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
      var item = items_3[_i];
      var x = item.x,
        y = item.y;
      var attrs = (0, tslib_1.__assign)((0, tslib_1.__assign)({
        fill: item.color,
        symbol: 'circle',
        shadowColor: item.color
      }, marker), {
        x: x,
        y: y
      });
      tooltipMarkersGroup.addShape('marker', {
        attrs: attrs
      });
    }
  };
  Tooltip.prototype.renderCrosshairs = function (point, cfg) {
    var crosshairsType = (0, util_1.get)(cfg, ['crosshairs', 'type'], 'x'); 
    if (crosshairsType === 'x') {
      if (this.yCrosshair) {
        this.yCrosshair.hide();
      }
      this.renderXCrosshairs(point, cfg);
    } else if (crosshairsType === 'y') {
      if (this.xCrosshair) {
        this.xCrosshair.hide();
      }
      this.renderYCrosshairs(point, cfg);
    } else if (crosshairsType === 'xy') {
      this.renderXCrosshairs(point, cfg);
      this.renderYCrosshairs(point, cfg);
    }
  };
  
  Tooltip.prototype.renderXCrosshairs = function (point, tooltipCfg) {
    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
    if (!(0, coordinate_1.isPointInCoordinate)(coordinate, point)) {
      return;
    }
    var start;
    var end;
    if (coordinate.isRect) {
      if (coordinate.isTransposed) {
        start = {
          x: coordinate.start.x,
          y: point.y
        };
        end = {
          x: coordinate.end.x,
          y: point.y
        };
      } else {
        start = {
          x: point.x,
          y: coordinate.end.y
        };
        end = {
          x: point.x,
          y: coordinate.start.y
        };
      }
    } else {
      
      var angle = (0, coordinate_1.getAngleByPoint)(coordinate, point);
      var center = coordinate.getCenter();
      var radius = coordinate.getRadius();
      end = (0, graphics_1.polarToCartesian)(center.x, center.y, radius, angle);
      start = center;
    }
    var cfg = (0, util_1.deepMix)({
      start: start,
      end: end,
      container: this.getTooltipCrosshairsGroup()
    }, (0, util_1.get)(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('x', point, tooltipCfg));
    delete cfg.type; 
    var xCrosshair = this.xCrosshair;
    if (xCrosshair) {
      xCrosshair.update(cfg);
    } else {
      xCrosshair = new dependents_1.Crosshair.Line(cfg);
      xCrosshair.init();
    }
    xCrosshair.render();
    xCrosshair.show();
    this.xCrosshair = xCrosshair;
  };
  
  Tooltip.prototype.renderYCrosshairs = function (point, tooltipCfg) {
    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
    if (!(0, coordinate_1.isPointInCoordinate)(coordinate, point)) {
      return;
    }
    var cfg;
    var type;
    if (coordinate.isRect) {
      var start = void 0;
      var end = void 0;
      if (coordinate.isTransposed) {
        start = {
          x: point.x,
          y: coordinate.end.y
        };
        end = {
          x: point.x,
          y: coordinate.start.y
        };
      } else {
        start = {
          x: coordinate.start.x,
          y: point.y
        };
        end = {
          x: coordinate.end.x,
          y: point.y
        };
      }
      cfg = {
        start: start,
        end: end
      };
      type = 'Line';
    } else {
      
      cfg = {
        center: coordinate.getCenter(),
        
        radius: (0, coordinate_1.getDistanceToCenter)(coordinate, point),
        startAngle: coordinate.startAngle,
        endAngle: coordinate.endAngle
      };
      type = 'Circle';
    }
    cfg = (0, util_1.deepMix)({
      container: this.getTooltipCrosshairsGroup()
    }, cfg, (0, util_1.get)(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('y', point, tooltipCfg));
    delete cfg.type; 
    var yCrosshair = this.yCrosshair;
    if (yCrosshair) {
      
      if (coordinate.isRect && yCrosshair.get('type') === 'circle' || !coordinate.isRect && yCrosshair.get('type') === 'line') {
        yCrosshair = new dependents_1.Crosshair[type](cfg);
        yCrosshair.init();
      } else {
        yCrosshair.update(cfg);
      }
    } else {
      yCrosshair = new dependents_1.Crosshair[type](cfg);
      yCrosshair.init();
    }
    yCrosshair.render();
    yCrosshair.show();
    this.yCrosshair = yCrosshair;
  };
  Tooltip.prototype.getCrosshairsText = function (type, point, tooltipCfg) {
    var textCfg = (0, util_1.get)(tooltipCfg, ['crosshairs', 'text']);
    var follow = (0, util_1.get)(tooltipCfg, ['crosshairs', 'follow']);
    var items = this.items;
    if (textCfg) {
      var view = this.getViewWithGeometry(this.view);
      
      var firstItem = items[0];
      var xScale = view.getXScale();
      var yScale = view.getYScales()[0];
      var xValue = void 0;
      var yValue = void 0;
      if (follow) {
        
        var invertPoint = this.view.getCoordinate().invert(point);
        xValue = xScale.invert(invertPoint.x); 
        yValue = yScale.invert(invertPoint.y); 
      } else {
        xValue = firstItem.data[xScale.field];
        yValue = firstItem.data[yScale.field];
      }
      var content = type === 'x' ? xValue : yValue;
      if ((0, util_1.isFunction)(textCfg)) {
        textCfg = textCfg(type, content, items, point);
      } else {
        textCfg.content = content;
      }
      return {
        text: textCfg
      };
    }
  };
  
  Tooltip.prototype.getGuideGroup = function () {
    if (!this.guideGroup) {
      var foregroundGroup = this.view.foregroundGroup;
      this.guideGroup = foregroundGroup.addGroup({
        name: 'tooltipGuide',
        capture: false
      });
    }
    return this.guideGroup;
  };
  
  Tooltip.prototype.getTooltipMarkersGroup = function () {
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
      tooltipMarkersGroup.clear();
      tooltipMarkersGroup.show();
    } else {
      tooltipMarkersGroup = this.getGuideGroup().addGroup({
        name: 'tooltipMarkersGroup'
      });
      tooltipMarkersGroup.toFront();
      this.tooltipMarkersGroup = tooltipMarkersGroup;
    }
    return tooltipMarkersGroup;
  };
  
  Tooltip.prototype.getTooltipCrosshairsGroup = function () {
    var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
    if (!tooltipCrosshairsGroup) {
      tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
        name: 'tooltipCrosshairsGroup',
        capture: false
      });
      tooltipCrosshairsGroup.toBack();
      this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
    }
    return tooltipCrosshairsGroup;
  };
  Tooltip.prototype.findItemsFromView = function (view, point) {
    if (view.getOptions().tooltip === false) {
      
      return [];
    }
    var tooltipCfg = this.getTooltipCfg();
    var result = (0, tooltip_1.findItemsFromView)(view, point, tooltipCfg);
    
    for (var _i = 0, _a = view.views; _i < _a.length; _i++) {
      var childView = _a[_i];
      result = result.concat(this.findItemsFromView(childView, point));
    }
    return result;
  };
  
  
  Tooltip.prototype.getViewWithGeometry = function (view) {
    var _this = this;
    if (view.geometries.length) {
      return view;
    }
    return (0, util_1.find)(view.views, function (childView) {
      return _this.getViewWithGeometry(childView);
    });
  };
    Tooltip.prototype.getItemsAfterProcess = function (originalItems) {
    var customItems = this.getTooltipCfg().customItems;
    var fn = customItems ? customItems : function (v) {
      return v;
    };
    return fn(originalItems);
  };
  return Tooltip;
}(base_1.Controller);
exports.default = Tooltip;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  Shape: true,
  Canvas: true,
  Group: true,
  getArcParams: true
};
Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return _canvas.default;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
exports.Shape = void 0;
Object.defineProperty(exports, "getArcParams", {
  enumerable: true,
  get: function get() {
    return _arcParams.default;
  }
});
exports.version = void 0;
var Shape = _interopRequireWildcard(__webpack_require__(147));
exports.Shape = Shape;
var _gBase = __webpack_require__(26);
Object.keys(_gBase).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _gBase[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _gBase[key];
    }
  });
});
var _canvas = _interopRequireDefault(__webpack_require__(965));
var _group = _interopRequireDefault(__webpack_require__(273));
var _arcParams = _interopRequireDefault(__webpack_require__(454));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var version = '0.5.12';
exports.version = version;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.antvDark = exports.createDarkStyleSheet = void 0;
var WHITE_COLORS = {
  100: '#000',
  95: '#0D0D0D',
  85: '#262626',
  65: '#595959',
  45: '#8C8C8C',
  25: '#BFBFBF',
  15: '#D9D9D9',
  6: '#F0F0F0'
};
var BLACK_COLORS = {
  100: '#FFFFFF',
  95: '#F2F2F2',
  85: '#D9D9D9',
  65: '#A6A6A6',
  45: '#737373',
  25: '#404040',
  15: '#262626',
  6: '#0F0F0F'
};
var QUALITATIVE_10 = ['#5B8FF9', '#5AD8A6', '#5D7092', '#F6BD16', '#E86452', '#6DC8EC', '#945FB9', '#FF9845', '#1E9493', '#FF99C3'];
var QUALITATIVE_20 = ['#5B8FF9', '#CDDDFD', '#5AD8A6', '#CDF3E4', '#5D7092', '#CED4DE', '#F6BD16', '#FCEBB9', '#E86452', '#F8D0CB', '#6DC8EC', '#D3EEF9', '#945FB9', '#DECFEA', '#FF9845', '#FFE0C7', '#1E9493', '#BBDEDE', '#FF99C3', '#FFE0ED'];
var SINGLE_SEQUENCE = ['#B8E1FF', '#9AC5FF', '#7DAAFF', '#5B8FF9', '#3D76DD', '#085EC0', '#0047A5', '#00318A', '#001D70'];
var createDarkStyleSheet = function createDarkStyleSheet(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a = cfg.backgroundColor,
    backgroundColor = _a === void 0 ? '#141414' : _a,
    _b = cfg.subColor,
    subColor = _b === void 0 ? 'rgba(255,255,255,0.05)' : _b,
    _c = cfg.paletteQualitative10,
    paletteQualitative10 = _c === void 0 ? QUALITATIVE_10 : _c,
    _d = cfg.paletteQualitative20,
    paletteQualitative20 = _d === void 0 ? QUALITATIVE_20 : _d,
    _e = cfg.paletteSemanticRed,
    paletteSemanticRed = _e === void 0 ? '#F4664A' : _e,
    _f = cfg.paletteSemanticGreen,
    paletteSemanticGreen = _f === void 0 ? '#30BF78' : _f,
    _g = cfg.paletteSemanticYellow,
    paletteSemanticYellow = _g === void 0 ? '#FAAD14' : _g,
    _h = cfg.paletteSequence,
    paletteSequence = _h === void 0 ? SINGLE_SEQUENCE : _h,
    _j = cfg.fontFamily,
    fontFamily = _j === void 0 ? "\"Segoe UI\", Roboto, \"Helvetica Neue\", Arial,\n    \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"" : _j;
  var _k = cfg.brandColor,
    brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
  return {
        backgroundColor: backgroundColor,
        brandColor: brandColor,
        subColor: subColor,
        paletteQualitative10: paletteQualitative10,
        paletteQualitative20: paletteQualitative20,
        paletteSemanticRed: paletteSemanticRed,
        paletteSemanticGreen: paletteSemanticGreen,
        paletteSemanticYellow: paletteSemanticYellow,
        paletteSequence: paletteSequence,
        fontFamily: fontFamily,
    
        axisLineBorderColor: BLACK_COLORS[25],
        axisLineBorder: 1,
        axisLineDash: null,
        axisTitleTextFillColor: BLACK_COLORS[65],
        axisTitleTextFontSize: 12,
        axisTitleTextLineHeight: 12,
        axisTitleTextFontWeight: 'normal',
        axisTitleSpacing: 12,
        axisTickLineBorderColor: BLACK_COLORS[25],
        axisTickLineLength: 4,
        axisTickLineBorder: 1,
        axisSubTickLineBorderColor: BLACK_COLORS[15],
        axisSubTickLineLength: 2,
        axisSubTickLineBorder: 1,
        axisLabelFillColor: BLACK_COLORS[45],
        axisLabelFontSize: 12,
        axisLabelLineHeight: 12,
        axisLabelFontWeight: 'normal',
        axisLabelOffset: 8,
        axisGridBorderColor: BLACK_COLORS[15],
        axisGridBorder: 1,
        axisGridLineDash: null,
    
        legendTitleTextFillColor: BLACK_COLORS[45],
        legendTitleTextFontSize: 12,
        legendTitleTextLineHeight: 21,
        legendTitleTextFontWeight: 'normal',
        legendMarkerColor: QUALITATIVE_10[0],
        legendMarkerSpacing: 8,
        legendMarkerSize: 4,
        legendCircleMarkerSize: 4,
        legendSquareMarkerSize: 4,
        legendLineMarkerSize: 5,
        legendItemNameFillColor: BLACK_COLORS[65],
        legendItemNameFontSize: 12,
        legendItemNameLineHeight: 12,
        legendItemNameFontWeight: 'normal',
        legendItemSpacing: 24,
        legendItemMarginBottom: 12,
        legendSpacing: 16,
        legendPadding: [8, 8, 8, 8],
        legendHorizontalPadding: [8, 0, 8, 0],
        legendVerticalPadding: [0, 8, 0, 8],
    
        legendPageNavigatorMarkerSize: 12,
        legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[45],
        legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
        legendPageNavigatorMarkerFillColor: BLACK_COLORS[45],
        legendPageNavigatorMarkerFillOpacity: 1,
        legendPageNavigatorTextFillColor: BLACK_COLORS[65],
        legendPageNavigatorTextFontSize: 12,
        sliderRailFillColor: BLACK_COLORS[15],
        sliderRailBorder: 0,
        sliderRailBorderColor: null,
        sliderRailWidth: 100,
        sliderRailHeight: 12,
        sliderLabelTextFillColor: BLACK_COLORS[45],
        sliderLabelTextFontSize: 12,
        sliderLabelTextLineHeight: 12,
        sliderLabelTextFontWeight: 'normal',
        sliderHandlerFillColor: WHITE_COLORS[6],
        sliderHandlerWidth: 10,
        sliderHandlerHeight: 14,
        sliderHandlerBorder: 1,
        sliderHandlerBorderColor: WHITE_COLORS[25],
    
        annotationArcBorderColor: BLACK_COLORS[15],
        annotationArcBorder: 1,
        annotationLineBorderColor: BLACK_COLORS[25],
        annotationLineBorder: 1,
        annotationLineDash: null,
        annotationTextFillColor: BLACK_COLORS[65],
        annotationTextFontSize: 12,
        annotationTextLineHeight: 12,
        annotationTextFontWeight: 'normal',
        annotationTextBorderColor: null,
        annotationTextBorder: 0,
        annotationRegionFillColor: BLACK_COLORS[100],
        annotationRegionFillOpacity: 0.06,
        annotationRegionBorder: 0,
        annotationRegionBorderColor: null,
        annotationDataMarkerLineLength: 16,
    
        tooltipCrosshairsBorderColor: BLACK_COLORS[25],
        tooltipCrosshairsBorder: 1,
        tooltipCrosshairsLineDash: null,
        tooltipContainerFillColor: '#1f1f1f',
    tooltipContainerFillOpacity: 0.95,
        tooltipContainerShadow: '0px 2px 4px rgba(0,0,0,.5)',
        tooltipContainerBorderRadius: 3,
        tooltipTextFillColor: BLACK_COLORS[65],
        tooltipTextFontSize: 12,
        tooltipTextLineHeight: 12,
        tooltipTextFontWeight: 'bold',
    
        labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: '#2c3542',
    labelFillColorLight: '#ffffff',
        labelFontSize: 12,
        labelLineHeight: 12,
        labelFontWeight: 'normal',
        labelBorderColor: null,
        labelBorder: 0,
        innerLabelFillColor: WHITE_COLORS[100],
        innerLabelFontSize: 12,
        innerLabelLineHeight: 12,
        innerLabelFontWeight: 'normal',
        innerLabelBorderColor: null,
        innerLabelBorder: 0,
        overflowLabelFillColor: BLACK_COLORS[65],
    overflowLabelFillColorDark: '#2c3542',
    overflowLabelFillColorLight: '#ffffff',
        overflowLabelFontSize: 12,
        overflowLabelLineHeight: 12,
        overflowLabelFontWeight: 'normal',
        overflowLabelBorderColor: WHITE_COLORS[100],
        overflowLabelBorder: 1,
        labelLineBorder: 1,
        labelLineBorderColor: BLACK_COLORS[25],
    
        cSliderRailHieght: 16,
        cSliderBackgroundFillColor: '#416180',
        cSliderBackgroundFillOpacity: 0.05,
        cSliderForegroundFillColor: '#5B8FF9',
        cSliderForegroundFillOpacity: 0.15,
    
        cSliderHandlerHeight: 24,
        cSliderHandlerWidth: 10,
        cSliderHandlerFillColor: '#F7F7F7',
        cSliderHandlerFillOpacity: 1,
        cSliderHandlerHighlightFillColor: '#FFF',
        cSliderHandlerBorderColor: '#BFBFBF',
        cSliderHandlerBorder: 1,
        cSliderHandlerBorderRadius: 2,
    
        cSliderTextFillColor: '#fff',
        cSliderTextFillOpacity: 0.45,
        cSliderTextFontSize: 12,
        cSliderTextLineHeight: 12,
        cSliderTextFontWeight: 'normal',
        cSliderTextBorderColor: null,
        cSliderTextBorder: 0,
    
        scrollbarTrackFillColor: 'rgba(255,255,255,0.65)',
        scrollbarThumbFillColor: 'rgba(0,0,0,0.35)',
        scrollbarThumbHighlightFillColor: 'rgba(0,0,0,0.45)',
    
        pointFillColor: QUALITATIVE_10[0],
        pointFillOpacity: 0.95,
        pointSize: 4,
        pointBorder: 1,
        pointBorderColor: WHITE_COLORS[100],
        pointBorderOpacity: 1,
        pointActiveBorderColor: BLACK_COLORS[100],
        pointSelectedBorder: 2,
        pointSelectedBorderColor: BLACK_COLORS[100],
        pointInactiveFillOpacity: 0.3,
        pointInactiveBorderOpacity: 0.3,
        hollowPointSize: 4,
        hollowPointBorder: 1,
        hollowPointBorderColor: QUALITATIVE_10[0],
        hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
        hollowPointActiveBorder: 1,
        hollowPointActiveBorderColor: BLACK_COLORS[100],
        hollowPointActiveBorderOpacity: 1,
        hollowPointSelectedBorder: 2,
        hollowPointSelectedBorderColor: BLACK_COLORS[100],
        hollowPointSelectedBorderOpacity: 1,
        hollowPointInactiveBorderOpacity: 0.3,
        lineBorder: 2,
        lineBorderColor: QUALITATIVE_10[0],
        lineBorderOpacity: 1,
        lineActiveBorder: 3,
        lineSelectedBorder: 3,
        lineInactiveBorderOpacity: 0.3,
        areaFillColor: QUALITATIVE_10[0],
        areaFillOpacity: 0.25,
        areaActiveFillColor: QUALITATIVE_10[0],
    areaActiveFillOpacity: 0.5,
        areaSelectedFillColor: QUALITATIVE_10[0],
    areaSelectedFillOpacity: 0.5,
        areaInactiveFillOpacity: 0.3,
        hollowAreaBorderColor: QUALITATIVE_10[0],
        hollowAreaBorder: 2,
        hollowAreaBorderOpacity: 1,
        hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
        hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
        hollowAreaInactiveBorderOpacity: 0.3,
        intervalFillColor: QUALITATIVE_10[0],
        intervalFillOpacity: 0.95,
        intervalActiveBorder: 1,
        intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
        intervalSelectedBorder: 2,
        intervalSelectedBorderColor: BLACK_COLORS[100],
        intervalSelectedBorderOpacity: 1,
        intervalInactiveBorderOpacity: 0.3,
        intervalInactiveFillOpacity: 0.3,
        hollowIntervalBorder: 2,
        hollowIntervalBorderColor: QUALITATIVE_10[0],
        hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
        hollowIntervalActiveBorder: 2,
        hollowIntervalActiveBorderColor: BLACK_COLORS[100],
        hollowIntervalSelectedBorder: 3,
        hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
        hollowIntervalSelectedBorderOpacity: 1,
        hollowIntervalInactiveBorderOpacity: 0.3
  };
};
exports.createDarkStyleSheet = createDarkStyleSheet;
exports.antvDark = (0, exports.createDarkStyleSheet)();

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Arc; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Arc = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Arc, _Base);
  var _super = _createSuper(Arc);
  function Arc() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Arc);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'arc';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(Arc);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return DataMarker; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DataMarker = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(DataMarker, _Base);
  var _super = _createSuper(DataMarker);
  function DataMarker() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DataMarker);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'dataMarker';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(DataMarker);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return DataRegion; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DataRegion = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(DataRegion, _Base);
  var _super = _createSuper(DataRegion);
  function DataRegion() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DataRegion);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'dataRegion';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(DataRegion);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Image; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Image = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Image, _Base);
  var _super = _createSuper(Image);
  function Image() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Image);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'image';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(Image);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Line; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Line = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Line, _Base);
  var _super = _createSuper(Line);
  function Line() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Line);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'line';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(Line);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Region; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Region = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Region, _Base);
  var _super = _createSuper(Region);
  function Region() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Region);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'region';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(Region);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Text; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Text = function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Text, _Base);
  var _super = _createSuper(Text);
  function Text() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Text);
    _this = _super.apply(this, arguments);
    _this.annotationType = 'text';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(Text);
}(_base__WEBPACK_IMPORTED_MODULE_5__[ "a"]);

;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var coordinate_1 = __webpack_require__(48);
var coordinate_2 = __webpack_require__(48);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(100));
var HALF_PI = Math.PI / 2;
var PolarLabel = function (_super) {
  (0, tslib_1.__extends)(PolarLabel, _super);
  function PolarLabel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
    PolarLabel.prototype.getLabelOffset = function (offset) {
    var coordinate = this.getCoordinate();
    var actualOffset = 0;
    if ((0, util_1.isNumber)(offset)) {
      actualOffset = offset;
    } else if ((0, util_1.isString)(offset) && offset.indexOf('%') !== -1) {
      var r = coordinate.getRadius();
      if (coordinate.innerRadius > 0) {
        r = r * (1 - coordinate.innerRadius);
      }
      actualOffset = parseFloat(offset) * 0.01 * r;
    }
    return actualOffset;
  };
    PolarLabel.prototype.getLabelItems = function (mapppingArray) {
    var items = _super.prototype.getLabelItems.call(this, mapppingArray);
    var yScale = this.geometry.getYScale();
    return (0, util_1.map)(items, function (item) {
      if (item && yScale) {
        var percent = yScale.scale((0, util_1.get)(item.data, yScale.field));
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, item), {
          percent: percent
        });
      }
      return item;
    });
  };
    PolarLabel.prototype.getLabelAlign = function (point) {
    var coordinate = this.getCoordinate();
    var align;
    if (point.labelEmit) {
      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';
    } else if (!coordinate.isTransposed) {
      align = 'center';
    } else {
      var center = coordinate.getCenter();
      var offset = point.offset;
      if (Math.abs(point.x - center.x) < 1) {
        align = 'center';
      } else if (point.angle > Math.PI || point.angle <= 0) {
        align = offset > 0 ? 'left' : 'right';
      } else {
        align = offset > 0 ? 'right' : 'left';
      }
    }
    return align;
  };
    PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
    var factor = 1;
    var arcPoint;
    var content = labelCfg.content[index];
    if (this.isToMiddle(mappingData)) {
      arcPoint = this.getMiddlePoint(mappingData.points);
    } else {
      if (labelCfg.content.length === 1 && index === 0) {
        index = 1;
      } else if (index === 0) {
        factor = -1;
      }
      arcPoint = this.getArcPoint(mappingData, index);
    }
    var offset = labelCfg.offset * factor;
    var middleAngle = this.getPointAngle(arcPoint);
    var isLabelEmit = labelCfg.labelEmit;
    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
    if (labelPositionCfg.r === 0) {
      
      labelPositionCfg.content = '';
    } else {
      labelPositionCfg.content = content;
      labelPositionCfg.angle = middleAngle;
      labelPositionCfg.color = mappingData.color;
    }
    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
    labelPositionCfg.start = {
      x: arcPoint.x,
      y: arcPoint.y
    };
    return labelPositionCfg;
  };
  /**
   * 获取圆弧的位置
   */
  PolarLabel.prototype.getArcPoint = function (mappingData, index) {
    if (index === void 0) {
      index = 0;
    }
    if (!(0, util_1.isArray)(mappingData.x) && !(0, util_1.isArray)(mappingData.y)) {
      return {
        x: mappingData.x,
        y: mappingData.y
      };
    }
    return {
      x: (0, util_1.isArray)(mappingData.x) ? mappingData.x[index] : mappingData.x,
      y: (0, util_1.isArray)(mappingData.y) ? mappingData.y[index] : mappingData.y
    };
  };
  /**
   * 计算坐标线点在极坐标系下角度
   * @param point
   */
  PolarLabel.prototype.getPointAngle = function (point) {
    return (0, coordinate_2.getAngleByPoint)(this.getCoordinate(), point);
  };
  /**
   * 获取坐标点与圆心形成的圆的位置信息
   * @param angle
   * @param offset
   * @param point
   * @param isLabelEmit
   */
  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var r = (0, coordinate_1.getDistanceToCenter)(coordinate, point);
    if (r === 0) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, center), {
        r: r
      });
    }
    var labelAngle = angle;
    if (coordinate.isTransposed && r > offset && !isLabelEmit) {
      var appendAngle = Math.asin(offset / (2 * r));
      labelAngle = angle + appendAngle * 2;
    } else {
      r = r + offset;
    }
    return {
      x: center.x + r * Math.cos(labelAngle),
      y: center.y + r * Math.sin(labelAngle),
      r: r
    };
  };
  /**
   * 获取 label 的旋转角度
   * @param angle
   * @param offset
   * @param isLabelEmit
   */
  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {
    var rotate = angle + HALF_PI;
    if (isLabelEmit) {
      rotate -= HALF_PI;
    }
    if (rotate) {
      if (rotate > HALF_PI) {
        rotate = rotate - Math.PI;
      } else if (rotate < -HALF_PI) {
        rotate = rotate + Math.PI;
      }
    }
    return rotate;
  };
  // 获取中心的位置
  PolarLabel.prototype.getMiddlePoint = function (points) {
    var coordinate = this.getCoordinate();
    var count = points.length;
    var middlePoint = {
      x: 0,
      y: 0
    };
    (0, util_1.each)(points, function (point) {
      middlePoint.x += point.x;
      middlePoint.y += point.y;
    });
    middlePoint.x /= count;
    middlePoint.y /= count;
    middlePoint = coordinate.convert(middlePoint);
    return middlePoint;
  };
  // 是否居中
  PolarLabel.prototype.isToMiddle = function (mappingData) {
    return mappingData.x.length > 2;
  };
  return PolarLabel;
}(base_1.default);
exports.default = PolarLabel;

/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Coordinate; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


// import _tranPropsToArray from '../../utils/tranPropsToArray';

function Coordinate(props) {
  var type = props.type,
    transpose = props.transpose,
    rotate = props.rotate,
    scale = props.scale,
    reflect = props.reflect,
    actions = props.actions,
    options = __rest(props, ["type", "transpose", "rotate", "scale", "reflect", "actions"]);
  var view = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_4__[ "a"])();
  var coordIns = view.coordinate();
  
  coordIns.update({});
  if (type) {
    view.coordinate(type, object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, options));
  } else {
    view.coordinate('rect', object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, options));
  }
  if (rotate) {
    coordIns.rotate(rotate);
  }
  if (scale) {
    coordIns.scale.apply(coordIns, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(scale));
  }
  if (!_antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2___default()(reflect)) {
    coordIns.reflect(reflect);
  }
  if (transpose) {
    coordIns.transpose();
  }
  if (_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3___default()(actions)) {
    actions(coordIns);
  }
  return null;
}

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return EdgeGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(326);
 var _antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_5__);
 var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
 var _antv_g2_lib_geometry_shape_edge__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(461);
 var _antv_g2_lib_geometry_shape_edge__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_edge__WEBPACK_IMPORTED_MODULE_8__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Edge', _antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_5___default.a);
var EdgeGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(EdgeGeom, _BaseGemo);
  var _super = _createSuper(EdgeGeom);
  function EdgeGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, EdgeGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'edge';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(EdgeGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_6__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return HeatmapGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(327);
 var _antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_5__);
 var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Heatmap', _antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_5___default.a);
var HeatmapGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(HeatmapGeom, _BaseGemo);
  var _super = _createSuper(HeatmapGeom);
  function HeatmapGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, HeatmapGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'heatmap';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(HeatmapGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_6__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return IntervalGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(328);
 var _antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_5__);
 var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(163);
 var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_6__);
 var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(164);
 var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_7___default = __webpack_require__.n(_antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_7__);
 var _Base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8);
 var _antv_g2_lib_geometry_shape_interval_funnel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(465);
 var _antv_g2_lib_geometry_shape_interval_funnel__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_interval_funnel__WEBPACK_IMPORTED_MODULE_10__);
 var _antv_g2_lib_geometry_shape_interval_hollow_rect__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(466);
 var _antv_g2_lib_geometry_shape_interval_hollow_rect__WEBPACK_IMPORTED_MODULE_11___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_interval_hollow_rect__WEBPACK_IMPORTED_MODULE_11__);
 var _antv_g2_lib_geometry_shape_interval_line__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(467);
 var _antv_g2_lib_geometry_shape_interval_line__WEBPACK_IMPORTED_MODULE_12___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_interval_line__WEBPACK_IMPORTED_MODULE_12__);
 var _antv_g2_lib_geometry_shape_interval_pyramid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(468);
 var _antv_g2_lib_geometry_shape_interval_pyramid__WEBPACK_IMPORTED_MODULE_13___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_interval_pyramid__WEBPACK_IMPORTED_MODULE_13__);
 var _antv_g2_lib_geometry_shape_interval_tick__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(469);
 var _antv_g2_lib_geometry_shape_interval_tick__WEBPACK_IMPORTED_MODULE_14___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_interval_tick__WEBPACK_IMPORTED_MODULE_14__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometry"])('Interval', _antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_5___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('interval', _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_6___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('pie', _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_7___default.a);






Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerInteraction"])('active-region', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'active-region:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'active-region:hide'
  }]
});
var IntervalGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(IntervalGeom, _BaseGemo);
  var _super = _createSuper(IntervalGeom);
  function IntervalGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, IntervalGeom);
    _this = _super.apply(this, arguments);
    _this.interactionTypes = ['active-region', 'element-highlight'];
    
    
    
    
    
    
    
    
    
    _this.GemoBaseClassName = 'interval';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(IntervalGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_8__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return PolygonGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(331);
 var _antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_5__);
 var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
 var _antv_g2_lib_geometry_shape_polygon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(462);
 var _antv_g2_lib_geometry_shape_polygon__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_polygon__WEBPACK_IMPORTED_MODULE_8__);
 var _antv_g2_lib_geometry_shape_polygon_square__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(475);
 var _antv_g2_lib_geometry_shape_polygon_square__WEBPACK_IMPORTED_MODULE_9___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_polygon_square__WEBPACK_IMPORTED_MODULE_9__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Polygon', _antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_5___default.a);
var PolygonGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(PolygonGeom, _BaseGemo);
  var _super = _createSuper(PolygonGeom);
  function PolygonGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PolygonGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'polygon';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(PolygonGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_6__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
 var _antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__);
 var _antv_g2_lib_geometry_shape_line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(276);
 var _antv_g2_lib_geometry_shape_line__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_line__WEBPACK_IMPORTED_MODULE_3__);
 var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(278);
 var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61);
 var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5__);
 var _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(168);
 var _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6__);
 var _antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(18);
 var _antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default = __webpack_require__.n(_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7__);
 var _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(20);
 var _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8__);
 var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8);
 var d3_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(60);
 var d3_color__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(d3_color__WEBPACK_IMPORTED_MODULE_10__);
 var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(40);
 var _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(81);
 var _Line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(129);
 var _Point__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(130);
 var _Area__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(128);

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
















var areaStyle = {
  "default": {
    "style": {
      "fill": "#5B8FF9",
      "fillOpacity": 0.25,
      "stroke": null
    }
  },
  "active": {
    "style": {
      "fillOpacity": 0.5
    }
  },
  "inactive": {
    "style": {
      "fillOpacity": 0.4
    }
  },
  "selected": {
    "style": {
      "fillOpacity": 0.5
    }
  }
};
var LineAdvance = function LineAdvance(props) {
  var point = props.point,
    area = props.area,
    shape = props.shape,
    cfg = __rest(props, ["point", "area", "shape"]);
  var pointCfg = {
    shape: 'circle'
  };
  var chart = Object(_hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_12__[ "a"])();
  var view = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_11__[ "a"])();
  var areaCfg = {
    shape: shape === 'smooth' ? 'gradient-smooth' : 'gradient'
  };
  var theme = view.getTheme();
  
  theme.geometries.area.gradient = areaStyle;
  
  theme.geometries.area['gradient-smooth'] = areaStyle;
  if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(chart, ['options', 'tooltip']) !== false) {
    
    if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(view, ['options', 'tooltip', 'shared']) === undefined) {
      _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default()(view, ['options', 'tooltip', 'shared'], true);
    }
    ;
    
    if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(view, ['options', 'tooltip', 'showCrosshairs']) === undefined) {
      _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default()(view, ['options', 'tooltip', 'showCrosshairs'], true);
    }
    ;
    if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(view, ['options', 'tooltip', 'showMarkers']) === undefined) {
      _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default()(view, ['options', 'tooltip', 'showMarkers'], true);
    }
    ;
  }
  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5___default()(pointCfg)) {
    _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6___default()(pointCfg, point);
  }
  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5___default()(areaCfg)) {
    _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6___default()(areaCfg, area);
  }
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Line__WEBPACK_IMPORTED_MODULE_13__[ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
    shape: shape,
    state: {
      "default": {
        style: {
          shadowColor: '#ddd',
          shadowBlur: 3,
          shadowOffsetY: 2
        }
      },
      active: {
        style: {
          shadowColor: '#ddd',
          shadowBlur: 3,
          shadowOffsetY: 5
        }
      }
    }
  }, cfg)), !!area && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Area__WEBPACK_IMPORTED_MODULE_15__[ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg, {
    tooltip: false
  }, areaCfg)), !!point && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Point__WEBPACK_IMPORTED_MODULE_14__[ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
    size: 3
  }, cfg, {
    state: {
      active: {
        style: {
          stroke: '#fff',
          lineWidth: 1.5,
          strokeOpacity: 0.9
        }
      }
    },
    tooltip: false
  }, pointCfg)));
};

Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerShape"])('area', 'gradient', {
  draw: function draw(cfg, container) {
    var attrs = Object(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__["getShapeAttrs"])(cfg, false, false, this);
    var c = attrs.fill;
    var clr = d3_color__WEBPACK_IMPORTED_MODULE_10__["color"](c);
    if (clr) {
      attrs.fill = "l (90) 0:".concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 1).formatRgb(), " 1:").concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 0.1).formatRgb());
    }
    
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  }
});
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerShape"])('area', 'gradient-smooth', {
  draw: function draw(cfg, container) {
    var coordinate = this.coordinate;
    var attrs = Object(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__["getShapeAttrs"])(cfg, false, true, this, Object(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__["getConstraint"])(coordinate));
    var c = attrs.fill;
    var clr = d3_color__WEBPACK_IMPORTED_MODULE_10__["color"](c);
    if (clr) {
      attrs.fill = "l (90) 0:".concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 1).formatRgb(), " 1:").concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 0.1).formatRgb());
    }
    
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  }
});
 __webpack_exports__["a"] = (LineAdvance);

 }),
 (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__221__;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fadeOut = exports.fadeIn = void 0;
var util_1 = __webpack_require__(0);
function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: (0, util_1.isNil)(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity'),
    strokeOpacity: (0, util_1.isNil)(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity'),
    opacity: (0, util_1.isNil)(shape.attr('opacity')) ? 1 : shape.attr('opacity')
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}
exports.fadeIn = fadeIn;
function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing,
    duration = animateCfg.duration,
    delay = animateCfg.delay;
  shape.animate(endState, duration, easing, function () {
    shape.remove(true);
  }, delay);
}
exports.fadeOut = fadeOut;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scaleInY = exports.scaleInX = void 0;
var matrix_util_1 = __webpack_require__(32);
function scaleInX(shape, animateCfg, cfg) {
  var box = shape.getBBox();
  var mappingData = shape.get('origin').mappingData;
  var points = mappingData.points;
  
  var x = points[0].y - points[1].y > 0 ? box.maxX : box.minX;
  var y = (box.minY + box.maxY) / 2;
  shape.applyToMatrix([x, y, 1]);
  var matrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 1], ['t', x, y]])
  }, animateCfg);
}
exports.scaleInX = scaleInX;
function scaleInY(shape, animateCfg, cfg) {
  var box = shape.getBBox();
  var mappingData = shape.get('origin').mappingData;
  var x = (box.minX + box.maxX) / 2;
  var points = mappingData.points;
  
  var y = points[0].y - points[1].y <= 0 ? box.maxY : box.minY;
  shape.applyToMatrix([x, y, 1]);
  var matrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 100], ['t', x, y]])
  }, animateCfg);
}
exports.scaleInY = scaleInY;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomOut = exports.zoomIn = void 0;
var tslib_1 = __webpack_require__(1);
var matrix_util_1 = __webpack_require__(32);
var util_1 = __webpack_require__(0);
function doShapeZoom(shape, animateCfg, type) {
  if (shape.isGroup()) {
    (0, util_1.each)(shape.getChildren(), function (child) {
      doShapeZoom(child, animateCfg, type);
    });
  } else {
    var bbox = shape.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    if (type === 'zoomIn') {
      
      var matrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 100], ['t', x, y]])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]])
      }, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, animateCfg), {
        callback: function callback() {
          shape.remove(true);
        }
      }));
    }
  }
}
function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, 'zoomIn');
}
exports.zoomIn = zoomIn;
function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, 'zoomOut');
}
exports.zoomOut = zoomOut;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overlap = exports.fixedOverlap = void 0;
var util_1 = __webpack_require__(0);
var MAX_TIMES = 100;
var Greedy = function () {
  function Greedy(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.bitmap = {};
    var _a = cfg.xGap,
      xGap = _a === void 0 ? 1 : _a,
      _b = cfg.yGap,
      yGap = _b === void 0 ? 8 : _b;
    this.xGap = xGap;
    this.yGap = yGap;
  }
  Greedy.prototype.hasGap = function (bbox) {
    var hasGap = true;
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);
    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
        continue;
      }
      if (i === minX || i === maxX) {
        for (var j = minY; j <= maxY; j++) {
          if (bitmap[i][j]) {
            hasGap = false;
            break;
          }
        }
      } else {
        if (bitmap[i][minY] || bitmap[i][maxY]) {
          hasGap = false;
          break;
        }
      }
    }
    return hasGap;
  };
  Greedy.prototype.fillGap = function (bbox) {
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);
    
    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
      }
    }
    for (var i = minX; i <= maxX; i += this.xGap) {
      for (var j = minY; j <= maxY; j += this.yGap) {
        bitmap[i][j] = true;
      }
      bitmap[i][maxY] = true;
    }
    
    if (this.yGap !== 1) {
      for (var i = minY; i <= maxY; i += 1) {
        bitmap[minX][i] = true;
        bitmap[maxX][i] = true;
      }
    }
    
    if (this.xGap !== 1) {
      for (var i = minX; i <= maxX; i += 1) {
        bitmap[i][minY] = true;
        bitmap[i][maxY] = true;
      }
    }
  };
  Greedy.prototype.destroy = function () {
    this.bitmap = {};
  };
  return Greedy;
}();
function spiralFill(label, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }
  var dt = -1;
  var _a = label.attr(),
    x = _a.x,
    y = _a.y;
  var bbox = label.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t = -dt;
  var dx = 0;
  var dy = 0;
  var f = function f(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };
  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }
  var canFill = false;
  var times = 0;
  var accessedCache = {};
  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    if (!dx && !dy || accessedCache[dx + "-" + dy]) {
      continue;
    }
    label.attr({
      x: x + dx,
      y: y + dy
    });
    if (dx + dy < 0) {
      label.attr('textAlign', 'right');
    }
    times++;
    if (greedy.hasGap(label.getCanvasBBox())) {
      greedy.fillGap(label.getCanvasBBox());
      canFill = true;
      accessedCache[dx + "-" + dy] = true;
      break;
    }
  }
  return canFill;
}
function adjustLabelPosition(label, x, y, index) {
  var _a = label.getCanvasBBox(),
    width = _a.width,
    height = _a.height;
  var attrs = {
    x: x,
    y: y,
    textAlign: 'center'
  };
  switch (index) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = 'left';
      break;
    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = 'right';
      break;
    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = 'right';
      break;
    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = 'left';
      break;
    case 5:
      attrs.y -= height * 2 + 2;
      break;
    case 6:
      attrs.y += height * 2 + 2;
      break;
    case 7:
      attrs.x += width + 1;
      attrs.textAlign = 'left';
      break;
    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = 'right';
      break;
    default:
      break;
  }
  label.attr(attrs);
  return label.getCanvasBBox();
}
function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  (0, util_1.each)(labels, function (label) {
    var labelShape = label.find(function (shape) {
      return shape.get('type') === 'text';
    });
    if (!spiralFill(labelShape, greedy)) {
      label.remove(true);
    }
  });
  greedy.destroy();
}
exports.fixedOverlap = fixedOverlap;
function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  (0, util_1.each)(labels, function (label) {
    var labelShape = label.find(function (shape) {
      return shape.get('type') === 'text';
    });
    var _a = labelShape.attr(),
      x = _a.x,
      y = _a.y;
    var canFill = false;
    for (var i = 0; i <= 8; i++) {
      var bbox = adjustLabelPosition(labelShape, x, y, i);
      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }
    if (!canFill) {
      label.remove(true);
    }
  });
  greedy.destroy();
}
exports.overlap = overlap;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ELEMENT_RANGE_HIGHLIGHT_EVENTS = void 0;
var tslib_1 = __webpack_require__(1);
var chart_1 = __webpack_require__(98);
var highlight_util_1 = __webpack_require__(287);
var range_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(285));
var EVENTS;
(function (EVENTS) {
  EVENTS["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
  EVENTS["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
  EVENTS["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
  EVENTS["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS || (EVENTS = {}));
exports.ELEMENT_RANGE_HIGHLIGHT_EVENTS = EVENTS;
var ElementRangeHighlight = function (_super) {
  (0, tslib_1.__extends)(ElementRangeHighlight, _super);
  function ElementRangeHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'active';
    return _this;
  }
  
  ElementRangeHighlight.prototype.clearViewState = function (view) {
    (0, highlight_util_1.clearHighlight)(view);
  };
    ElementRangeHighlight.prototype.highlight = function () {
    var _a = this.context,
      view = _a.view,
      event = _a.event;
    var elements = this.getIntersectElements();
    var payload = {
      view: view,
      event: event,
      highlightElements: elements
    };
    view.emit(EVENTS.BEFORE_HIGHLIGHT, chart_1.Event.fromData(view, EVENTS.BEFORE_HIGHLIGHT, payload));
    this.setState();
    view.emit(EVENTS.AFTER_HIGHLIGHT, chart_1.Event.fromData(view, EVENTS.AFTER_HIGHLIGHT, payload));
  };
    ElementRangeHighlight.prototype.clear = function () {
    var view = this.context.view;
    view.emit(EVENTS.BEFORE_CLEAR, chart_1.Event.fromData(view, EVENTS.BEFORE_CLEAR, {}));
    _super.prototype.clear.call(this);
    view.emit(EVENTS.AFTER_CLEAR, chart_1.Event.fromData(view, EVENTS.AFTER_CLEAR, {}));
  };
  ElementRangeHighlight.prototype.setElementsState = function (elements, enable, allElements) {
    (0, highlight_util_1.setHighlightBy)(allElements, function (el) {
      return elements.indexOf(el) >= 0;
    }, enable);
  };
  return ElementRangeHighlight;
}(range_state_1.default);
exports.default = ElementRangeHighlight;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var list_highlight_util_1 = __webpack_require__(1014);
var list_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(151));
var STATUS_UNACTIVE = 'inactive';
var STATUS_ACTIVE = 'active';
var ListHighlight = function (_super) {
  (0, tslib_1.__extends)(ListHighlight, _super);
  function ListHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE;
    _this.ignoreItemStates = ['unchecked']; 
    return _this;
  }
  
  ListHighlight.prototype.setItemsState = function (list, name, enable) {
    this.setHighlightBy(list, function (item) {
      return item.name === name;
    }, enable);
  };
  
  ListHighlight.prototype.setItemState = function (list, item, enable) {
    var items = list.getItems();
    this.setHighlightBy(list, function (el) {
      return el === item;
    }, enable);
  };
  
  ListHighlight.prototype.setHighlightBy = function (list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      
      (0, util_1.each)(items, function (item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNACTIVE)) {
            list.setItemState(item, STATUS_UNACTIVE, false);
          }
          list.setItemState(item, STATUS_ACTIVE, true);
        } else if (!list.hasState(item, STATUS_ACTIVE)) {
          list.setItemState(item, STATUS_UNACTIVE, true);
        }
      });
    } else {
      var activeItems = list.getItemsByState(STATUS_ACTIVE);
      var allCancel_1 = true;
      
      (0, util_1.each)(activeItems, function (item) {
        if (!callback(item)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        
        
        (0, util_1.each)(items, function (item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_ACTIVE)) {
              list.setItemState(item, STATUS_ACTIVE, false);
            }
            list.setItemState(item, STATUS_UNACTIVE, true);
          }
        });
      }
    }
  };
    ListHighlight.prototype.highlight = function () {
    this.setState();
  };
  
  ListHighlight.prototype.clear = function () {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      (0, list_highlight_util_1.clearList)(triggerInfo.list);
    } else {
      
      var components = this.getAllowComponents();
      (0, util_1.each)(components, function (component) {
        component.clearItemsState(STATUS_ACTIVE);
        component.clearItemsState(STATUS_UNACTIVE);
      });
    }
  };
  return ListHighlight;
}(list_state_1.default);
exports.default = ListHighlight;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
      args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
exports.default = debounce;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function sumFnc(x) {
  
  if (x.length === 0) {
    return 0;
  }
  
  var sum = x[0];
  
  var correction = 0;
  var transition;
  for (var i = 1; i < x.length; i++) {
    transition = sum + x[i];
    
    
    if (Math.abs(sum) >= Math.abs(x[i])) {
      correction += sum - transition + x[i];
    } else {
      correction += x[i] - transition + sum;
    }
    sum = transition;
  }
  
  return sum + correction;
}
 __webpack_exports__["a"] = (sumFnc);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ResizeObserver", {
  enumerable: true,
  get: function get() {
    return _ResizeObserver.ResizeObserver;
  }
});
Object.defineProperty(exports, "ResizeObserverEntry", {
  enumerable: true,
  get: function get() {
    return _ResizeObserverEntry.ResizeObserverEntry;
  }
});
Object.defineProperty(exports, "ResizeObserverSize", {
  enumerable: true,
  get: function get() {
    return _ResizeObserverSize.ResizeObserverSize;
  }
});
var _ResizeObserver = __webpack_require__(1039);
var _ResizeObserverEntry = __webpack_require__(483);
var _ResizeObserverSize = __webpack_require__(485);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Line = void 0;
var tslib_1 = __webpack_require__(1);
var plot_1 = __webpack_require__(24);
var adaptor_1 = __webpack_require__(512);
var constants_1 = __webpack_require__(1087);
__webpack_require__(1088);
var Line = function (_super) {
  tslib_1.__extends(Line, _super);
  function Line() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'line';
    return _this;
  }
    Line.getDefaultOptions = function () {
    return constants_1.DEFAULT_OPTIONS;
  };
    Line.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    adaptor_1.meta({
      chart: chart,
      options: options
    });
    this.chart.changeData(data);
  };
    Line.prototype.getDefaultOptions = function () {
    return Line.getDefaultOptions();
  };
    Line.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  return Line;
}(plot_1.Plot);
exports.Line = Line;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pie = void 0;
var tslib_1 = __webpack_require__(1);
var g2_1 = __webpack_require__(14);
var plot_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(15);
var adaptor_1 = __webpack_require__(1128);
var contants_1 = __webpack_require__(525);
var utils_2 = __webpack_require__(526);
__webpack_require__(527);
var Pie = function (_super) {
  tslib_1.__extends(Pie, _super);
  function Pie() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'pie';
    return _this;
  }
    Pie.getDefaultOptions = function () {
    return contants_1.DEFAULT_OPTIONS;
  };
    Pie.prototype.changeData = function (data) {
    this.chart.emit(g2_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, g2_1.Event.fromData(this.chart, g2_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    var prevOptions = this.options;
    var angleField = this.options.angleField;
    var prevData = utils_1.processIllegalData(prevOptions.data, angleField);
    var curData = utils_1.processIllegalData(data, angleField);
    
    if (utils_2.isAllZero(prevData, angleField) || utils_2.isAllZero(curData, angleField)) {
      this.update({
        data: data
      });
    } else {
      this.updateOption({
        data: data
      });
      this.chart.data(curData);
      
      adaptor_1.pieAnnotation({
        chart: this.chart,
        options: this.options
      });
      this.chart.render(true);
    }
    this.chart.emit(g2_1.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, g2_1.Event.fromData(this.chart, g2_1.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
    Pie.prototype.getDefaultOptions = function () {
    return Pie.getDefaultOptions();
  };
    Pie.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  return Pie;
}(plot_1.Plot);
exports.Pie = Pie;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scatter = void 0;
var tslib_1 = __webpack_require__(1);
var g2_1 = __webpack_require__(14);
var plot_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(15);
var adaptor_1 = __webpack_require__(1154);
var constant_1 = __webpack_require__(1156);
__webpack_require__(1157);
var Scatter = function (_super) {
  tslib_1.__extends(Scatter, _super);
  function Scatter(container, options) {
    var _this = _super.call(this, container, options) || this;
        _this.type = 'scatter';
    
    _this.on(g2_1.VIEW_LIFE_CIRCLE.BEFORE_RENDER, function (evt) {
      var _a, _b;
      
      var _c = _this,
        options = _c.options,
        chart = _c.chart;
      if (((_a = evt.data) === null || _a === void 0 ? void 0 : _a.source) === g2_1.BRUSH_FILTER_EVENTS.FILTER) {
        var filteredData = _this.chart.filterData(_this.chart.getData());
        adaptor_1.meta({
          chart: chart,
          options: tslib_1.__assign(tslib_1.__assign({}, options), {
            data: filteredData
          })
        });
      }
      if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === g2_1.BRUSH_FILTER_EVENTS.RESET) {
        adaptor_1.meta({
          chart: chart,
          options: options
        });
      }
    });
    return _this;
  }
    Scatter.getDefaultOptions = function () {
    return constant_1.DEFAULT_OPTIONS;
  };
    Scatter.prototype.changeData = function (data) {
    this.updateOption(adaptor_1.transformOptions(utils_1.deepAssign({}, this.options, {
      data: data
    })));
    var _a = this,
      options = _a.options,
      chart = _a.chart;
    adaptor_1.meta({
      chart: chart,
      options: options
    });
    this.chart.changeData(data);
  };
    Scatter.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  Scatter.prototype.getDefaultOptions = function () {
    return Scatter.getDefaultOptions();
  };
  return Scatter;
}(plot_1.Plot);
exports.Scatter = Scatter;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.getArcParams = exports.Shape = exports.Group = exports.Canvas = void 0;
var tslib_1 = __webpack_require__(1);
var Shape = __webpack_require__(143);
exports.Shape = Shape;
tslib_1.__exportStar(__webpack_require__(26), exports);
var canvas_1 = __webpack_require__(913);
Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return canvas_1.default;
  }
});
var group_1 = __webpack_require__(260);
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return group_1.default;
  }
});
var arc_params_1 = __webpack_require__(438);
Object.defineProperty(exports, "getArcParams", {
  enumerable: true,
  get: function get() {
    return arc_params_1.default;
  }
});
exports.version = '0.5.12';

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;


var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = __webpack_require__(650)();
var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; 

var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : (0, _typeof2.default)(JSON)) === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};
var doEval = function doEval(name) {
  var value;
  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var bind = __webpack_require__(237);
var hasOwn = __webpack_require__(652);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }
    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }
  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }
  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }
    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }
        return void undefined;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;

        
        
        
        
        
        
        
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(651);
module.exports = Function.prototype.bind || implementation;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArrayLike = _interopRequireDefault(__webpack_require__(56));
var contains = function contains(arr, value) {
  if (!(0, _isArrayLike.default)(arr)) {
    return false;
  }
  return arr.indexOf(value) > -1;
};
var _default = contains;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var isObjectLike = function isObjectLike(value) {
    return (0, _typeof2.default)(value) === 'object' && value !== null;
};
var _default = isObjectLike;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _each = _interopRequireDefault(__webpack_require__(107));
var _isFunction = _interopRequireDefault(__webpack_require__(57));

var values = Object.values ? function (obj) {
  return Object.values(obj);
} : function (obj) {
  var result = [];
  (0, _each.default)(obj, function (value, key) {
    if (!((0, _isFunction.default)(obj) && key === 'prototype')) {
      result.push(value);
    }
  });
  return result;
};
var _default = values;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mix;

function _mix(dist, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
      dist[key] = obj[key];
    }
  }
}
function mix(dist, src1, src2, src3) {
  if (src1) _mix(dist, src1);
  if (src2) _mix(dist, src2);
  if (src3) _mix(dist, src3);
  return dist;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchBotDeviceInfo = exports.ReactNativeInfo = exports.NodeInfo = exports.BrowserInfo = exports.BotInfo = void 0;
exports.browserName = browserName;
exports.detect = detect;
exports.detectOS = detectOS;
exports.getNodeVersion = getNodeVersion;
exports.parseUserAgent = parseUserAgent;
var __spreadArray = void 0 && (void 0).__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = function () {
  function BrowserInfo(name, version, os) {
    this.name = name;
    this.version = version;
    this.os = os;
    this.type = 'browser';
  }
  return BrowserInfo;
}();
exports.BrowserInfo = BrowserInfo;
var NodeInfo = function () {
  function NodeInfo(version) {
    this.version = version;
    this.type = 'node';
    this.name = 'node';
    this.os = process.platform;
  }
  return NodeInfo;
}();
exports.NodeInfo = NodeInfo;
var SearchBotDeviceInfo = function () {
  function SearchBotDeviceInfo(name, version, os, bot) {
    this.name = name;
    this.version = version;
    this.os = os;
    this.bot = bot;
    this.type = 'bot-device';
  }
  return SearchBotDeviceInfo;
}();
exports.SearchBotDeviceInfo = SearchBotDeviceInfo;
var BotInfo = function () {
  function BotInfo() {
    this.type = 'bot';
    this.bot = true; 
    this.name = 'bot';
    this.version = null;
    this.os = null;
  }
  return BotInfo;
}();
exports.BotInfo = BotInfo;
var ReactNativeInfo = function () {
  function ReactNativeInfo() {
    this.type = 'react-native';
    this.name = 'react-native';
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo;
}();
exports.ReactNativeInfo = ReactNativeInfo;

var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /EdgA?\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FB[AS]V\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['curl', /^curl\/([0-9\.]+)$/], ['searchbot', SEARCHBOX_UA_REGEX]];
var operatingSystemRules = [['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Chrome OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== 'undefined') {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  
  
  
  
  return ua !== '' && userAgentRules.reduce(function (matched, _a) {
    var browser = _a[0],
      regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function browserName(ua) {
  var data = matchUserAgent(ua);
  return data ? data[0] : null;
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0],
    match = matchedRule[1];
  if (name === 'searchbot') {
    return new BotInfo();
  }
  
  var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join('.');
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii],
      os = _a[0],
      regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== 'undefined' && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push('0');
  }
  return output;
}
}.call(this, __webpack_require__(747)))

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invert = invert;
exports.multiplyMatrix = multiplyMatrix;
exports.multiplyVec2 = multiplyVec2;
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timer = Timer;
exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var frame = 0,
  
  timeout = 0,
  
  interval = 0,
  
  pokeDelay = 1000,
  
  taskHead,
  taskTail,
  clockLast = 0,
  clockNow = 0,
  clockSkew = 0,
  clock = (typeof performance === "undefined" ? "undefined" : (0, _typeof2.default)(performance)) === "object" && performance.now ? performance : Date,
  setFrame = (typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
    setTimeout(f, 17);
  };
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now(); 
  ++frame; 
  var t = taskHead,
    e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now = clock.now(),
    delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}
function nap() {
  var t0,
    t1 = taskHead,
    t2,
    time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return; 
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; 
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = Color;
exports.Rgb = Rgb;
exports.darker = exports.brighter = void 0;
exports.default = color;
exports.hsl = hsl;
exports.hslConvert = hslConvert;
exports.rgb = rgb;
exports.rgbConvert = rgbConvert;
var _define = _interopRequireWildcard(__webpack_require__(246));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function Color() {}
var _darker = 0.7;
exports.darker = _darker;
var _brighter = 1 / _darker;
exports.brighter = _brighter;
var reI = "\\s*([+-]?\\d+)\\s*",
  reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
  reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
  reHex = /^#([0-9a-f]{3,8})$/,
  reRgbInteger = new RegExp("^rgb\\(".concat(reI, ",").concat(reI, ",").concat(reI, "\\)$")),
  reRgbPercent = new RegExp("^rgb\\(".concat(reP, ",").concat(reP, ",").concat(reP, "\\)$")),
  reRgbaInteger = new RegExp("^rgba\\(".concat(reI, ",").concat(reI, ",").concat(reI, ",").concat(reN, "\\)$")),
  reRgbaPercent = new RegExp("^rgba\\(".concat(reP, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$")),
  reHslPercent = new RegExp("^hsl\\(".concat(reN, ",").concat(reP, ",").concat(reP, "\\)$")),
  reHslaPercent = new RegExp("^hsla\\(".concat(reN, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$"));
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
(0, _define.default)(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
(0, _define.default)(Rgb, rgb, (0, _define.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  clamp: function clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b));
}
function rgb_formatHex8() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b)).concat(hex((isNaN(this.opacity) ? 1 : this.opacity) * 255));
}
function rgb_formatRgb() {
  var a = clampa(this.opacity);
  return "".concat(a === 1 ? "rgb(" : "rgba(").concat(clampi(this.r), ", ").concat(clampi(this.g), ", ").concat(clampi(this.b)).concat(a === 1 ? ")" : ", ".concat(a, ")"));
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
    g = o.g / 255,
    b = o.b / 255,
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    h = NaN,
    s = max - min,
    l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
(0, _define.default)(Hsl, hsl, (0, _define.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
      s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
      l = this.l,
      m2 = l + (l < 0.5 ? l : 1 - l) * s,
      m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp: function clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = clampa(this.opacity);
    return "".concat(a === 1 ? "hsl(" : "hsla(").concat(clamph(this.h), ", ").concat(clampt(this.s) * 100, "%, ").concat(clampt(this.l) * 100, "%").concat(a === 1 ? ")" : ", ".concat(a, ")"));
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.extend = extend;
function _default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) {
    prototype[key] = definition[key];
  }
  return prototype;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basis = basis;
exports.default = _default;
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
    t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function _default(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
      v1 = values[i],
      v2 = values[i + 1],
      v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
      v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.isNumberArray = isNumberArray;
function _default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
    c = b.slice(),
    i;
  return function (t) {
    for (i = 0; i < n; ++i) {
      c[i] = a[i] * (1 - t) + b[i] * t;
    }
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeArrowBBox = mergeArrowBBox;
exports.mergeBBox = mergeBBox;

function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}

function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get('startArrowShape');
  var endArrowShape = shape.get('endArrowShape');
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MARGIN_RATIO = exports.GAP = exports.DODGE_RATIO = exports.DEFAULT_Y = void 0;
var DEFAULT_Y = 0; 

exports.DEFAULT_Y = DEFAULT_Y;
var MARGIN_RATIO = 1 / 2;
exports.MARGIN_RATIO = MARGIN_RATIO;
var DODGE_RATIO = 1 / 2;

exports.DODGE_RATIO = DODGE_RATIO;
var GAP = 0.05;
exports.GAP = GAP;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Attribute: true,
  Color: true,
  Opacity: true,
  Position: true,
  Shape: true,
  Size: true,
  getAttribute: true,
  registerAttribute: true
};
Object.defineProperty(exports, "Attribute", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Color", {
  enumerable: true,
  get: function get() {
    return _color.default;
  }
});
Object.defineProperty(exports, "Opacity", {
  enumerable: true,
  get: function get() {
    return _opacity.default;
  }
});
Object.defineProperty(exports, "Position", {
  enumerable: true,
  get: function get() {
    return _position.default;
  }
});
Object.defineProperty(exports, "Shape", {
  enumerable: true,
  get: function get() {
    return _shape.default;
  }
});
Object.defineProperty(exports, "Size", {
  enumerable: true,
  get: function get() {
    return _size.default;
  }
});
Object.defineProperty(exports, "getAttribute", {
  enumerable: true,
  get: function get() {
    return _factory.getAttribute;
  }
});
Object.defineProperty(exports, "registerAttribute", {
  enumerable: true,
  get: function get() {
    return _factory.registerAttribute;
  }
});
var _base = _interopRequireDefault(__webpack_require__(103));
var _color = _interopRequireDefault(__webpack_require__(821));
var _opacity = _interopRequireDefault(__webpack_require__(822));
var _position = _interopRequireDefault(__webpack_require__(823));
var _shape = _interopRequireDefault(__webpack_require__(824));
var _size = _interopRequireDefault(__webpack_require__(825));
var _factory = __webpack_require__(826);
var _interface = __webpack_require__(424);
Object.keys(_interface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interface[key];
    }
  });
});
(0, _factory.registerAttribute)('Color', _color.default);
(0, _factory.registerAttribute)('Opacity', _opacity.default);
(0, _factory.registerAttribute)('Position', _position.default);
(0, _factory.registerAttribute)('Shape', _shape.default);
(0, _factory.registerAttribute)('Size', _size.default);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = intervalTicks;
var _util = __webpack_require__(0);
function snapMultiple(v, base, snapType) {
  var div;
  if (snapType === 'ceil') {
    div = Math.ceil(v / base);
  } else if (snapType === 'floor') {
    div = Math.floor(v / base);
  } else {
    div = Math.round(v / base);
  }
  return div * base;
}
function intervalTicks(min, max, interval) {
  
  var minTick = snapMultiple(min, interval, 'floor');
  var maxTick = snapMultiple(max, interval, 'ceil');
  
  minTick = (0, _util.fixedBase)(minTick, interval);
  maxTick = (0, _util.fixedBase)(maxTick, interval);
  var ticks = [];
  
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval);
  for (var i = minTick; i <= maxTick; i = i + availableInterval) {
    var tickValue = (0, _util.fixedBase)(i, availableInterval); 
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks: ticks
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = strictLimit;
var _util = __webpack_require__(0);
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a;
  var minLimit = cfg.minLimit,
    maxLimit = cfg.maxLimit,
    min = cfg.min,
    max = cfg.max,
    _b = cfg.tickCount,
    tickCount = _b === void 0 ? 5 : _b;
  var tickMin = (0, _util.isNil)(minLimit) ? (0, _util.isNil)(defaultMin) ? min : defaultMin : minLimit;
  var tickMax = (0, _util.isNil)(maxLimit) ? (0, _util.isNil)(defaultMax) ? max : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a = [tickMin, tickMax], tickMax = _a[0], tickMin = _a[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }
  return ticks;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _gBase = __webpack_require__(26);
var _util = __webpack_require__(0);
var LOCATION_FIELD_MAP = {
  none: [],
  point: ['x', 'y'],
  region: ['start', 'end'],
  points: ['points'],
  circle: ['center', 'radius', 'startAngle', 'endAngle']
};
var Component = function (_super) {
  (0, _tslib.__extends)(Component, _super);
  function Component(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initCfg();
    return _this;
  }
    Component.prototype.getDefaultCfg = function () {
    return {
      id: '',
      name: '',
      type: '',
      locationType: 'none',
      offsetX: 0,
      offsetY: 0,
      animate: false,
      capture: true,
      updateAutoRender: false,
      animateOption: {
        appear: null,
        update: {
          duration: 400,
          easing: 'easeQuadInOut'
        },
        enter: {
          duration: 400,
          easing: 'easeQuadInOut'
        },
        leave: {
          duration: 350,
          easing: 'easeQuadIn'
        }
      },
      events: null,
      defaultCfg: {},
      visible: true
    };
  };
    Component.prototype.clear = function () {};
    Component.prototype.update = function (cfg) {
    var _this = this;
    var defaultCfg = this.get('defaultCfg') || {};
    (0, _util.each)(cfg, function (value, name) {
      var originCfg = _this.get(name);
      var newCfg = value;
      if (originCfg !== value) {
        
        if ((0, _util.isObject)(value) && defaultCfg[name]) {
          
          newCfg = (0, _util.deepMix)({}, defaultCfg[name], value);
        }
        _this.set(name, newCfg);
      }
    });
    this.updateInner(cfg);
    this.afterUpdate(cfg);
  };
  
  Component.prototype.updateInner = function (cfg) {};
  Component.prototype.afterUpdate = function (cfg) {
    
    if ((0, _util.hasKey)(cfg, 'visible')) {
      if (cfg.visible) {
        this.show();
      } else {
        this.hide();
      }
    }
    
    if ((0, _util.hasKey)(cfg, 'capture')) {
      this.setCapture(cfg.capture);
    }
  };
  Component.prototype.getLayoutBBox = function () {
    return this.getBBox(); 
  };

  Component.prototype.getLocationType = function () {
    return this.get('locationType');
  };
  Component.prototype.getOffset = function () {
    return {
      offsetX: this.get('offsetX'),
      offsetY: this.get('offsetY')
    };
  };
  
  Component.prototype.setOffset = function (offsetX, offsetY) {
    this.update({
      offsetX: offsetX,
      offsetY: offsetY
    });
  };
  Component.prototype.setLocation = function (cfg) {
    var location = (0, _tslib.__assign)({}, cfg);
    this.update(location);
  };
  
  Component.prototype.getLocation = function () {
    var _this = this;
    var location = {};
    var locationType = this.get('locationType');
    var fields = LOCATION_FIELD_MAP[locationType];
    (0, _util.each)(fields, function (field) {
      location[field] = _this.get(field);
    });
    return location;
  };
  Component.prototype.isList = function () {
    return false;
  };
  Component.prototype.isSlider = function () {
    return false;
  };
    Component.prototype.init = function () {};
  
  Component.prototype.initCfg = function () {
    var _this = this;
    var defaultCfg = this.get('defaultCfg');
    (0, _util.each)(defaultCfg, function (value, name) {
      var cfg = _this.get(name);
      if ((0, _util.isObject)(cfg)) {
        var newCfg = (0, _util.deepMix)({}, value, cfg);
        _this.set(name, newCfg);
      }
    });
  };
  return Component;
}(_gBase.Base);
var _default = Component;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _matrixUtil = __webpack_require__(32);
var _util = __webpack_require__(0);
var _groupComponent = _interopRequireDefault(__webpack_require__(41));
var _matrix = __webpack_require__(90);
var _state = __webpack_require__(433);
var _theme = _interopRequireDefault(__webpack_require__(58));
var AxisBase = function (_super) {
  (0, _tslib.__extends)(AxisBase, _super);
  function AxisBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'axis',
      ticks: [],
      line: {},
      tickLine: {},
      subTickLine: null,
      title: null,
            label: {},
            verticalFactor: 1,
      
      verticalLimitLength: null,
      overlapOrder: ['autoRotate', 'autoEllipsis', 'autoHide'],
      tickStates: {},
      optimize: {},
      defaultCfg: {
        line: {
          
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          }
        },
        tickLine: {
          
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          },
          alignTick: true,
          length: 5,
          displayWithLabel: true
        },
        subTickLine: {
          
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          },
          count: 4,
          length: 2
        },
        label: {
          autoRotate: true,
          autoHide: false,
          autoEllipsis: false,
          style: {
            fontSize: 12,
            fill: _theme.default.textColor,
            fontFamily: _theme.default.fontFamily,
            fontWeight: 'normal'
          },
          offset: 10,
          offsetX: 0,
          offsetY: 0
        },
        title: {
          autoRotate: true,
          spacing: 5,
          position: 'center',
          style: {
            fontSize: 12,
            fill: _theme.default.textColor,
            textBaseline: 'middle',
            fontFamily: _theme.default.fontFamily,
            textAlign: 'center'
          },
          iconStyle: {
            fill: _theme.default.descriptionIconFill,
            stroke: _theme.default.descriptionIconStroke
          },
          description: ''
        },
        tickStates: {
          active: {
            labelStyle: {
              fontWeight: 500
            },
            tickLineStyle: {
              lineWidth: 2
            }
          },
          inactive: {
            labelStyle: {
              fill: _theme.default.uncheckedColor
            }
          }
        },
        // 针对大数据量进行优化配置
        optimize: {
          enable: true,
          threshold: 400
        }
      },
      theme: {}
    });
  };
  /**
   * 绘制组件
   */
  AxisBase.prototype.renderInner = function (group) {
    if (this.get('line')) {
      this.drawLine(group);
    }
    
    this.drawTicks(group);
    if (this.get('title')) {
      this.drawTitle(group);
    }
  };
  
  AxisBase.prototype.isList = function () {
    return true;
  };
    AxisBase.prototype.getItems = function () {
    return this.get('ticks');
  };
    AxisBase.prototype.setItems = function (items) {
    this.update({
      ticks: items
    });
  };
    AxisBase.prototype.updateItem = function (item, cfg) {
    (0, _util.mix)(item, cfg);
    this.clear(); 
    this.render();
  };
    AxisBase.prototype.clearItems = function () {
    var itemGroup = this.getElementByLocalId('label-group');
    itemGroup && itemGroup.clear();
  };
    AxisBase.prototype.setItemState = function (item, state, value) {
    item[state] = value;
    this.updateTickStates(item); 
  };
    AxisBase.prototype.hasState = function (item, state) {
    return !!item[state];
  };
  AxisBase.prototype.getItemStates = function (item) {
    var tickStates = this.get('tickStates');
    var rst = [];
    (0, _util.each)(tickStates, function (v, k) {
      if (item[k]) {
        
        rst.push(k);
      }
    });
    return rst;
  };
    AxisBase.prototype.clearItemsState = function (state) {
    var _this = this;
    var items = this.getItemsByState(state);
    (0, _util.each)(items, function (item) {
      _this.setItemState(item, state, false);
    });
  };
    AxisBase.prototype.getItemsByState = function (state) {
    var _this = this;
    var items = this.getItems();
    return (0, _util.filter)(items, function (item) {
      return _this.hasState(item, state);
    });
  };
  AxisBase.prototype.getSidePoint = function (point, offset) {
    var self = this;
    var vector = self.getSideVector(offset, point);
    return {
      x: point.x + vector[0],
      y: point.y + vector[1]
    };
  };
  AxisBase.prototype.getTextAnchor = function (vector) {
    var align;
    if ((0, _util.isNumberEqual)(vector[0], 0)) {
      align = 'center';
    } else if (vector[0] > 0) {
      align = 'start';
    } else if (vector[0] < 0) {
      align = 'end';
    }
    return align;
  };
  AxisBase.prototype.getTextBaseline = function (vector) {
    var base;
    if ((0, _util.isNumberEqual)(vector[1], 0)) {
      base = 'middle';
    } else if (vector[1] > 0) {
      base = 'top';
    } else if (vector[1] < 0) {
      base = 'bottom';
    }
    return base;
  };
  AxisBase.prototype.processOverlap = function (labelGroup) {};
  
  AxisBase.prototype.drawLine = function (group) {
    var path = this.getLinePath();
    var line = this.get('line'); 
    this.addShape(group, {
      type: 'path',
      id: this.getElementId('line'),
      name: 'axis-line',
      attrs: (0, _util.mix)({
        path: path
      }, line.style)
    });
  };
  AxisBase.prototype.getTickLineItems = function (ticks) {
    var _this = this;
    var tickLineItems = [];
    var tickLine = this.get('tickLine');
    var alignTick = tickLine.alignTick;
    var tickLineLength = tickLine.length;
    var tickSegment = 1;
    var tickCount = ticks.length;
    if (tickCount >= 2) {
      tickSegment = ticks[1].value - ticks[0].value;
    }
    (0, _util.each)(ticks, function (tick) {
      var point = tick.point;
      if (!alignTick) {
        
        point = _this.getTickPoint(tick.value - tickSegment / 2);
      }
      var endPoint = _this.getSidePoint(point, tickLineLength);
      tickLineItems.push({
        startPoint: point,
        tickValue: tick.value,
        endPoint: endPoint,
        tickId: tick.id,
        id: "tickline-" + tick.id
      });
    });
    
    
    
    
    
    return tickLineItems;
  };
  AxisBase.prototype.getSubTickLineItems = function (tickLineItems) {
    var subTickLineItems = [];
    var subTickLine = this.get('subTickLine');
    var subCount = subTickLine.count;
    var tickLineCount = tickLineItems.length;
    
    if (tickLineCount >= 2) {
      for (var i = 0; i < tickLineCount - 1; i++) {
        var pre = tickLineItems[i];
        var next = tickLineItems[i + 1];
        for (var j = 0; j < subCount; j++) {
          var percent = (j + 1) / (subCount + 1);
          var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;
          var point = this.getTickPoint(tickValue);
          var endPoint = this.getSidePoint(point, subTickLine.length);
          subTickLineItems.push({
            startPoint: point,
            endPoint: endPoint,
            tickValue: tickValue,
            id: "sub-" + pre.id + "-" + j
          });
        }
      }
    }
    return subTickLineItems;
  };
  AxisBase.prototype.getTickLineAttrs = function (tickItem, type, index, tickItems) {
    var style = this.get(type).style;
    
    var item = {
      points: [tickItem.startPoint, tickItem.endPoint]
    };
    var defaultTickLineStyle = (0, _util.get)(this.get('theme'), ['tickLine', 'style'], {});
    style = (0, _util.isFunction)(style) ? (0, _util.mix)({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
    var startPoint = tickItem.startPoint,
      endPoint = tickItem.endPoint;
    return (0, _tslib.__assign)({
      x1: startPoint.x,
      y1: startPoint.y,
      x2: endPoint.x,
      y2: endPoint.y
    }, style);
  };
  
  AxisBase.prototype.drawTick = function (tickItem, tickLineGroup, type, index, tickItems) {
    this.addShape(tickLineGroup, {
      type: 'line',
      id: this.getElementId(tickItem.id),
      name: "axis-" + type,
      attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
    });
  };
  
  AxisBase.prototype.drawTickLines = function (group) {
    var _this = this;
    var ticks = this.get('ticks');
    var subTickLine = this.get('subTickLine');
    var tickLineItems = this.getTickLineItems(ticks);
    var tickLineGroup = this.addGroup(group, {
      name: 'axis-tickline-group',
      id: this.getElementId('tickline-group')
    });
    var tickCfg = this.get('tickLine');
    (0, _util.each)(tickLineItems, function (item, index) {
      if (tickCfg.displayWithLabel) {
        
        var labelId = _this.getElementId("label-" + item.tickId);
        if (group.findById(labelId)) {
          _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);
        }
      } else {
        _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);
      }
    });
    if (subTickLine) {
      var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
      (0, _util.each)(subTickLineItems_1, function (item, index) {
        _this.drawTick(item, tickLineGroup, 'subTickLine', index, subTickLineItems_1);
      });
    }
  };
  
  AxisBase.prototype.processTicks = function () {
    var _this = this;
    var ticks = this.get('ticks');
    (0, _util.each)(ticks, function (tick) {
      tick.point = _this.getTickPoint(tick.value);
      
      if ((0, _util.isNil)(tick.id)) {
        
        tick.id = tick.name;
      }
    });
  };
  
  AxisBase.prototype.drawTicks = function (group) {
    var _this = this;
    this.optimizeTicks();
    this.processTicks();
    if (this.get('label')) {
      this.drawLabels(group);
    }
    if (this.get('tickLine')) {
      this.drawTickLines(group);
    }
    var ticks = this.get('ticks');
    (0, _util.each)(ticks, function (tick) {
      _this.applyTickStates(tick, group);
    });
  };
    AxisBase.prototype.optimizeTicks = function () {
    var optimize = this.get('optimize');
    var ticks = this.get('ticks');
    if (optimize && optimize.enable && optimize.threshold > 0) {
      var len = (0, _util.size)(ticks);
      if (len > optimize.threshold) {
        var page_1 = Math.ceil(len / optimize.threshold);
        var optimizedTicks = ticks.filter(function (tick, idx) {
          return idx % page_1 === 0;
        });
        this.set('ticks', optimizedTicks);
        this.set('originalTicks', ticks);
      }
    }
  };
  
  AxisBase.prototype.getLabelAttrs = function (tick, index, ticks) {
    var labelCfg = this.get('label');
    var offset = labelCfg.offset,
      offsetX = labelCfg.offsetX,
      offsetY = labelCfg.offsetY,
      rotate = labelCfg.rotate,
      formatter = labelCfg.formatter;
    var point = this.getSidePoint(tick.point, offset);
    var vector = this.getSideVector(offset, point);
    var text = formatter ? formatter(tick.name, tick, index) : tick.name;
    var style = labelCfg.style;
    style = (0, _util.isFunction)(style) ? (0, _util.get)(this.get('theme'), ['label', 'style'], {}) : style;
    var attrs = (0, _util.mix)({
      x: point.x + offsetX,
      y: point.y + offsetY,
      text: text,
      textAlign: this.getTextAnchor(vector),
      textBaseline: this.getTextBaseline(vector)
    }, style);
    if (rotate) {
      attrs.matrix = (0, _matrix.getMatrixByAngle)(point, rotate);
    }
    return attrs;
  };
  
  AxisBase.prototype.drawLabels = function (group) {
    var _this = this;
    var ticks = this.get('ticks');
    var labelGroup = this.addGroup(group, {
      name: 'axis-label-group',
      id: this.getElementId('label-group')
    });
    (0, _util.each)(ticks, function (tick, index) {
      _this.addShape(labelGroup, {
        type: 'text',
        name: 'axis-label',
        id: _this.getElementId("label-" + tick.id),
        attrs: _this.getLabelAttrs(tick, index, ticks),
        delegateObject: {
          tick: tick,
          item: tick,
          index: index
        }
      });
    });
    this.processOverlap(labelGroup);
    
    var labels = labelGroup.getChildren();
    var defaultLabelStyle = (0, _util.get)(this.get('theme'), ['label', 'style'], {});
    var _a = this.get('label'),
      style = _a.style,
      formatter = _a.formatter;
    if ((0, _util.isFunction)(style)) {
      var afterProcessTicks_1 = labels.map(function (label) {
        return (0, _util.get)(label.get('delegateObject'), 'tick');
      });
      (0, _util.each)(labels, function (label, index) {
        var tick = label.get('delegateObject').tick;
        var text = formatter ? formatter(tick.name, tick, index) : tick.name;
        var newStyle = (0, _util.mix)({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
        label.attr(newStyle);
      });
    }
  };
  
  AxisBase.prototype.getTitleAttrs = function () {
    var titleCfg = this.get('title');
    var style = titleCfg.style,
      position = titleCfg.position,
      offset = titleCfg.offset,
      _a = titleCfg.spacing,
      spacing = _a === void 0 ? 0 : _a,
      autoRotate = titleCfg.autoRotate;
    var titleHeight = style.fontSize;
    var percent = 0.5;
    if (position === 'start') {
      percent = 0;
    } else if (position === 'end') {
      percent = 1;
    }
    var point = this.getTickPoint(percent); 
    
    var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2); 
    var attrs = (0, _util.mix)({
      x: titlePoint.x,
      y: titlePoint.y,
      text: titleCfg.text
    }, style);
    var rotate = titleCfg.rotate; 
    var angle = rotate;
    if ((0, _util.isNil)(rotate) && autoRotate) {
      
      var vector = this.getAxisVector(point);
      var v1 = [1, 0]; 
      angle = _matrixUtil.ext.angleTo(vector, v1, true);
    }
    if (angle) {
      var matrix = (0, _matrix.getMatrixByAngle)(titlePoint, angle);
      attrs.matrix = matrix;
    }
    return attrs;
  };
  
  AxisBase.prototype.drawTitle = function (group) {
    var _a;
    var titleAttrs = this.getTitleAttrs();
    var titleShape = this.addShape(group, {
      type: 'text',
      id: this.getElementId('title'),
      name: 'axis-title',
      attrs: titleAttrs
    });
    
    if ((_a = this.get('title')) === null || _a === void 0 ? void 0 : _a.description) {
      this.drawDescriptionIcon(group, titleShape, titleAttrs.matrix);
    }
  };
  AxisBase.prototype.drawDescriptionIcon = function (group, titleShape, matrix) {
    var descriptionShape = this.addGroup(group, {
      name: 'axis-description',
      id: this.getElementById('description')
    });
    var _a = titleShape.getBBox(),
      maxX = _a.maxX,
      maxY = _a.maxY,
      height = _a.height;
    var iconStyle = this.get('title').iconStyle;
    var spacing = 4; 
    var r = height / 2;
    var lineWidth = r / 6;
    var startX = maxX + spacing;
    var startY = maxY - height / 2;
    
    
    var _b = [startX + r, startY - r],
      x0 = _b[0],
      y0 = _b[1];
    var _c = [x0 + r, y0 + r],
      x1 = _c[0],
      y1 = _c[1];
    var _d = [x0, y1 + r],
      x2 = _d[0],
      y2 = _d[1];
    var _e = [startX, y0 + r],
      x3 = _e[0],
      y3 = _e[1];
    
    var _f = [startX + r, startY - height / 4],
      x4 = _f[0],
      y4 = _f[1];
    var _g = [x4, y4 + lineWidth],
      x5 = _g[0],
      y5 = _g[1];
    var _h = [x5, y5 + lineWidth],
      x6 = _h[0],
      y6 = _h[1];
    var _j = [x6, y6 + r * 3 / 4],
      x7 = _j[0],
      y7 = _j[1];
    this.addShape(descriptionShape, {
      type: 'path',
      id: this.getElementId('title-description-icon'),
      name: 'axis-title-description-icon',
      attrs: (0, _tslib.__assign)({
        path: [['M', x0, y0], ['A', r, r, 0, 0, 1, x1, y1], ['A', r, r, 0, 0, 1, x2, y2], ['A', r, r, 0, 0, 1, x3, y3], ['A', r, r, 0, 0, 1, x0, y0], ['M', x4, y4], ['L', x5, y5], ['M', x6, y6], ['L', x7, y7]],
        lineWidth: lineWidth,
        matrix: matrix
      }, iconStyle)
    });
    
    this.addShape(descriptionShape, {
      type: 'rect',
      id: this.getElementId('title-description-rect'),
      name: 'axis-title-description-rect',
      attrs: {
        x: startX,
        y: startY - height / 2,
        width: height,
        height: height,
        stroke: '#000',
        fill: '#000',
        opacity: 0,
        matrix: matrix,
        cursor: 'pointer'
      }
    });
  };
  AxisBase.prototype.applyTickStates = function (tick, group) {
    var states = this.getItemStates(tick);
    if (states.length) {
      var tickStates = this.get('tickStates');
      
      var labelId = this.getElementId("label-" + tick.id);
      var labelShape = group.findById(labelId);
      if (labelShape) {
        var labelStateStyle = (0, _state.getStatesStyle)(tick, 'label', tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      var tickLineId = this.getElementId("tickline-" + tick.id);
      var tickLineShape = group.findById(tickLineId);
      if (tickLineShape) {
        var tickLineStateStyle = (0, _state.getStatesStyle)(tick, 'tickLine', tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    }
  };
  AxisBase.prototype.updateTickStates = function (tick) {
    var states = this.getItemStates(tick);
    var tickStates = this.get('tickStates');
    var labelCfg = this.get('label');
    var labelShape = this.getElementByLocalId("label-" + tick.id);
    var tickLineCfg = this.get('tickLine');
    var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
    if (states.length) {
      if (labelShape) {
        var labelStateStyle = (0, _state.getStatesStyle)(tick, 'label', tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      if (tickLineShape) {
        var tickLineStateStyle = (0, _state.getStatesStyle)(tick, 'tickLine', tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    } else {
      if (labelShape) {
        labelShape.attr(labelCfg.style);
      }
      if (tickLineShape) {
        tickLineShape.attr(tickLineCfg.style);
      }
    }
  };
  return AxisBase;
}(_groupComponent.default);
var _default = AxisBase;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _groupComponent = _interopRequireDefault(__webpack_require__(41));
var _matrix = __webpack_require__(90);
var _theme = _interopRequireDefault(__webpack_require__(58));
var _util2 = __webpack_require__(42);
var CrosshairBase = function (_super) {
  (0, _tslib.__extends)(CrosshairBase, _super);
  function CrosshairBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CrosshairBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'crosshair',
      type: 'base',
      line: {},
      text: null,
      textBackground: {},
      capture: false,
      defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          }
        },
        text: {
          position: 'start',
          offset: 10,
          autoRotate: false,
          content: null,
          style: {
            fill: _theme.default.textColor,
            textAlign: 'center',
            textBaseline: 'middle',
            fontFamily: _theme.default.fontFamily
          }
        },
        textBackground: {
          padding: 5,
          style: {
            stroke: _theme.default.lineColor
          }
        }
      }
    });
  };
  CrosshairBase.prototype.renderInner = function (group) {
    if (this.get('line')) {
      this.renderLine(group);
    }
    if (this.get('text')) {
      this.renderText(group);
      this.renderBackground(group);
    }
  };
  CrosshairBase.prototype.renderText = function (group) {
    var text = this.get('text');
    var style = text.style,
      autoRotate = text.autoRotate,
      content = text.content;
    if (!(0, _util.isNil)(content)) {
      var textPoint = this.getTextPoint();
      var matrix = null;
      if (autoRotate) {
        var angle = this.getRotateAngle();
        matrix = (0, _matrix.getMatrixByAngle)(textPoint, angle);
      }
      this.addShape(group, {
        type: 'text',
        name: 'crosshair-text',
        id: this.getElementId('text'),
        attrs: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, textPoint), {
          text: content,
          matrix: matrix
        }), style)
      });
    }
  };
  CrosshairBase.prototype.renderLine = function (group) {
    var path = this.getLinePath();
    var line = this.get('line');
    var style = line.style;
    this.addShape(group, {
      type: 'path',
      name: 'crosshair-line',
      id: this.getElementId('line'),
      attrs: (0, _tslib.__assign)({
        path: path
      }, style)
    });
  };
  
  CrosshairBase.prototype.renderBackground = function (group) {
    var textId = this.getElementId('text');
    var textShape = group.findById(textId); 
    var textBackground = this.get('textBackground');
    if (textBackground && textShape) {
      var textBBox = textShape.getBBox();
      var padding = (0, _util2.formatPadding)(textBackground.padding); 
      var style = textBackground.style;
      var backgroundShape = this.addShape(group, {
        type: 'rect',
        name: 'crosshair-text-background',
        id: this.getElementId('text-background'),
        attrs: (0, _tslib.__assign)({
          x: textBBox.x - padding[3],
          y: textBBox.y - padding[0],
          width: textBBox.width + padding[1] + padding[3],
          height: textBBox.height + padding[0] + padding[2],
          matrix: textShape.attr('matrix')
        }, style)
      });
      backgroundShape.toBack();
    }
  };
  return CrosshairBase;
}(_groupComponent.default);
var _default = CrosshairBase;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _groupComponent = _interopRequireDefault(__webpack_require__(41));
var _theme = _interopRequireDefault(__webpack_require__(58));
var GridBase = function (_super) {
  (0, _tslib.__extends)(GridBase, _super);
  function GridBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'grid',
      line: {},
      alternateColor: null,
      capture: false,
      items: [],
      closed: false,
      defaultCfg: {
        line: {
          type: 'line',
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          }
        }
      }
    });
  };
    GridBase.prototype.getLineType = function () {
    var line = this.get('line') || this.get('defaultCfg').line;
    return line.type;
  };
  GridBase.prototype.renderInner = function (group) {
    this.drawGrid(group);
  };
  GridBase.prototype.getAlternatePath = function (prePoints, points) {
    var regionPath = this.getGridPath(prePoints);
    var reversePoints = points.slice(0).reverse();
    var nextPath = this.getGridPath(reversePoints, true);
    var closed = this.get('closed');
    if (closed) {
      regionPath = regionPath.concat(nextPath);
    } else {
      nextPath[0][0] = 'L'; 
      regionPath = regionPath.concat(nextPath);
      regionPath.push(['Z']);
    }
    return regionPath;
  };
  
  GridBase.prototype.getPathStyle = function () {
    return this.get('line').style;
  };
  
  GridBase.prototype.drawGrid = function (group) {
    var _this = this;
    var line = this.get('line');
    var items = this.get('items');
    var alternateColor = this.get('alternateColor');
    var preItem = null;
    (0, _util.each)(items, function (item, index) {
      var id = item.id || index;
      
      if (line) {
        var style = _this.getPathStyle();
        style = (0, _util.isFunction)(style) ? style(item, index, items) : style;
        var lineId = _this.getElementId("line-" + id);
        var gridPath = _this.getGridPath(item.points);
        _this.addShape(group, {
          type: 'path',
          name: 'grid-line',
          id: lineId,
          attrs: (0, _util.mix)({
            path: gridPath
          }, style)
        });
      }
      
      
      if (alternateColor && index > 0) {
        var regionId = _this.getElementId("region-" + id);
        var isEven = index % 2 === 0;
        if ((0, _util.isString)(alternateColor)) {
          
          if (isEven) {
            _this.drawAlternateRegion(regionId, group, preItem.points, item.points, alternateColor);
          }
        } else {
          var color = isEven ? alternateColor[1] : alternateColor[0];
          _this.drawAlternateRegion(regionId, group, preItem.points, item.points, color);
        }
      }
      preItem = item;
    });
  };
  
  GridBase.prototype.drawAlternateRegion = function (id, group, prePoints, points, color) {
    var regionPath = this.getAlternatePath(prePoints, points);
    this.addShape(group, {
      type: 'path',
      id: id,
      name: 'grid-region',
      attrs: {
        path: regionPath,
        fill: color
      }
    });
  };
  return GridBase;
}(_groupComponent.default);
var _default = GridBase;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _groupComponent = _interopRequireDefault(__webpack_require__(41));
var _util = __webpack_require__(42);
var LegendBase = function (_super) {
  (0, _tslib.__extends)(LegendBase, _super);
  function LegendBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LegendBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'legend',
            layout: 'horizontal',
      locationType: 'point',
      x: 0,
      y: 0,
      offsetX: 0,
      offsetY: 0,
      title: null,
      background: null
    });
  };
  LegendBase.prototype.getLayoutBBox = function () {
    var bbox = _super.prototype.getLayoutBBox.call(this);
    var maxWidth = this.get('maxWidth');
    var maxHeight = this.get('maxHeight');
    var width = bbox.width,
      height = bbox.height;
    if (maxWidth) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight) {
      height = Math.min(height, maxHeight);
    }
    return (0, _util.createBBox)(bbox.minX, bbox.minY, width, height);
  };
  LegendBase.prototype.setLocation = function (cfg) {
    this.set('x', cfg.x);
    this.set('y', cfg.y);
    this.resetLocation();
  };
  LegendBase.prototype.resetLocation = function () {
    var x = this.get('x');
    var y = this.get('y');
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');
    this.moveElementTo(this.get('group'), {
      x: x + offsetX,
      y: y + offsetY
    });
  };
  LegendBase.prototype.applyOffset = function () {
    this.resetLocation();
  };
  
  LegendBase.prototype.getDrawPoint = function () {
    return this.get('currentPoint');
  };
  LegendBase.prototype.setDrawPoint = function (point) {
    return this.set('currentPoint', point);
  };
  
  LegendBase.prototype.renderInner = function (group) {
    this.resetDraw();
    if (this.get('title')) {
      this.drawTitle(group);
    }
    this.drawLegendContent(group);
    if (this.get('background')) {
      this.drawBackground(group);
    }
    
  };
  
  LegendBase.prototype.drawBackground = function (group) {
    var background = this.get('background');
    var bbox = group.getBBox();
    var padding = (0, _util.formatPadding)(background.padding);
    var attrs = (0, _tslib.__assign)({
      
      x: 0,
      y: 0,
      width: bbox.width + padding[1] + padding[3],
      height: bbox.height + padding[0] + padding[2]
    }, background.style);
    var backgroundShape = this.addShape(group, {
      type: 'rect',
      id: this.getElementId('background'),
      name: 'legend-background',
      attrs: attrs
    });
    backgroundShape.toBack();
  };
  
  LegendBase.prototype.drawTitle = function (group) {
    var currentPoint = this.get('currentPoint');
    var titleCfg = this.get('title');
    var spacing = titleCfg.spacing,
      style = titleCfg.style,
      text = titleCfg.text;
    var shape = this.addShape(group, {
      type: 'text',
      id: this.getElementId('title'),
      name: 'legend-title',
      attrs: (0, _tslib.__assign)({
        text: text,
        x: currentPoint.x,
        y: currentPoint.y
      }, style)
    });
    var bbox = shape.getBBox();
    
    this.set('currentPoint', {
      x: currentPoint.x,
      y: bbox.maxY + spacing
    });
  };
  
  LegendBase.prototype.resetDraw = function () {
    var background = this.get('background');
    var currentPoint = {
      x: 0,
      y: 0
    };
    if (background) {
      var padding = (0, _util.formatPadding)(background.padding);
      currentPoint.x = padding[3]; 
      currentPoint.y = padding[0]; 
    }

    this.set('currentPoint', currentPoint); 
  };

  return LegendBase;
}(_groupComponent.default);
var _default = LegendBase;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VALUE_CLASS = exports.TITLE_CLASS = exports.NAME_CLASS = exports.MARKER_CLASS = exports.LIST_ITEM_CLASS = exports.LIST_CLASS = exports.CROSSHAIR_Y = exports.CROSSHAIR_X = exports.CONTAINER_CLASS = void 0;
var CONTAINER_CLASS = 'g2-tooltip';
exports.CONTAINER_CLASS = CONTAINER_CLASS;
var TITLE_CLASS = 'g2-tooltip-title';
exports.TITLE_CLASS = TITLE_CLASS;
var LIST_CLASS = 'g2-tooltip-list';
exports.LIST_CLASS = LIST_CLASS;
var LIST_ITEM_CLASS = 'g2-tooltip-list-item';
exports.LIST_ITEM_CLASS = LIST_ITEM_CLASS;
var MARKER_CLASS = 'g2-tooltip-marker';
exports.MARKER_CLASS = MARKER_CLASS;
var VALUE_CLASS = 'g2-tooltip-value';
exports.VALUE_CLASS = VALUE_CLASS;
var NAME_CLASS = 'g2-tooltip-name';
exports.NAME_CLASS = NAME_CLASS;
var CROSSHAIR_X = 'g2-tooltip-crosshair-x';
exports.CROSSHAIR_X = CROSSHAIR_X;
var CROSSHAIR_Y = 'g2-tooltip-crosshair-y';
exports.CROSSHAIR_Y = CROSSHAIR_Y;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var g_base_1 = __webpack_require__(26);
var Shape = __webpack_require__(143);
var draw_1 = __webpack_require__(144);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(51);
var Group = function (_super) {
  tslib_1.__extends(Group, _super);
  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
    Group.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };
  Group.prototype.getShapeBase = function () {
    return Shape;
  };
  Group.prototype.getGroupBase = function () {
    return Group;
  };
  
  Group.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save();
      
      draw_1.applyAttrsToContext(context, clip);
      
      clip.createPath(context);
      context.restore();
      
      context.clip();
      clip._afterDraw();
    }
  };
  
  
  Group.prototype.cacheCanvasBBox = function () {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    util_1.each(children, function (child) {
      var bbox = child.cfg.cacheCanvasBBox;
      
      
      if (bbox && child.cfg.isInView) {
        xArr.push(bbox.minX, bbox.maxX);
        yArr.push(bbox.minY, bbox.maxY);
      }
    });
    var bbox = null;
    if (xArr.length) {
      var minX = util_1.min(xArr);
      var maxX = util_1.max(xArr);
      var minY = util_1.min(yArr);
      var maxY = util_1.max(yArr);
      bbox = {
        minX: minX,
        minY: minY,
        x: minX,
        y: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;
      if (canvas) {
        var viewRange = canvas.getViewRange();
        
        
        this.set('isInView', util_2.intersectRect(bbox, viewRange));
      }
    } else {
      this.set('isInView', false);
    }
    this.set('cacheCanvasBBox', bbox);
  };
  Group.prototype.draw = function (context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true; 
    
    
    
    if (children.length && allowDraw) {
      context.save();
      
      
      draw_1.applyAttrsToContext(context, this);
      this._applyClip(context, this.getClip());
      draw_1.drawChildren(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    }
    
    
    this.cfg.refresh = null;
    
    this.set('hasChanged', false);
  };
  
  Group.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('hasChanged', false);
  };
  return Group;
}(g_base_1.AbstractGroup);
exports.default = Group;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refreshElement = exports.drawChildren = void 0;
var svg_1 = __webpack_require__(145);
var dom_1 = __webpack_require__(72);
function drawChildren(context, children) {
  children.forEach(function (child) {
    child.draw(context);
  });
}
exports.drawChildren = drawChildren;
function refreshElement(element, changeType) {
  
  var canvas = element.get('canvas');
  
  if (canvas && canvas.get('autoDraw')) {
    var context = canvas.get('context');
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get('el');
    if (changeType === 'remove') {
      var isClipShape = element.get('isClipShape');
      
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === 'show') {
      el.setAttribute('visibility', 'visible');
    } else if (changeType === 'hide') {
      el.setAttribute('visibility', 'hidden');
    } else if (changeType === 'zIndex') {
      dom_1.moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === 'sort') {
      var children_1 = element.get('children');
      if (children_1 && children_1.length) {
        dom_1.sortDom(element, function (a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === 'clear') {
      
      if (el) {
        el.innerHTML = '';
      }
    } else if (changeType === 'matrix') {
      svg_1.setTransform(element);
    } else if (changeType === 'clip') {
      svg_1.setClip(element, context);
    } else if (changeType === 'attr') {
      
    } else if (changeType === 'add') {
      element.draw(context);
    }
  }
}
exports.refreshElement = refreshElement;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var g_base_1 = __webpack_require__(26);
var util_1 = __webpack_require__(0);
var Shape = __webpack_require__(184);
var draw_1 = __webpack_require__(261);
var svg_1 = __webpack_require__(145);
var constant_1 = __webpack_require__(52);
var dom_1 = __webpack_require__(72);
var Group = function (_super) {
  tslib_1.__extends(Group, _super);
  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  
  Group.prototype.isEntityGroup = function () {
    return true;
  };
  Group.prototype.createDom = function () {
    var element = dom_1.createSVGElement('g');
    this.set('el', element);
    var parent = this.getParent();
    if (parent) {
      var parentNode = parent.get('el');
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        
        parentNode = parent.createDom();
        parent.set('el', parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  };
  
  Group.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get('canvas');
    
    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.createPath(context, targetAttrs);
    }
  };
    Group.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };
  Group.prototype.getShapeBase = function () {
    return Shape;
  };
  Group.prototype.getGroupBase = function () {
    return Group;
  };
  Group.prototype.draw = function (context) {
    var children = this.getChildren();
    var el = this.get('el');
    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }
      svg_1.setClip(this, context);
      this.createPath(context);
      if (children.length) {
        draw_1.drawChildren(context, children);
      }
    }
  };
    Group.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
    svg_1.setTransform(this);
  };
  return Group;
}(g_base_1.AbstractGroup);
exports.default = Group;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var event_emitter_1 = (0, tslib_1.__importDefault)(__webpack_require__(126));
var Base = function (_super) {
  (0, tslib_1.__extends)(Base, _super);
  function Base(cfg) {
    var _this = _super.call(this) || this;
        _this.destroyed = false;
    var _a = cfg.visible,
      visible = _a === void 0 ? true : _a;
    _this.visible = visible;
    return _this;
  }
    Base.prototype.show = function () {
    var visible = this.visible;
    if (!visible) {
      this.changeVisible(true);
    }
  };
    Base.prototype.hide = function () {
    var visible = this.visible;
    if (visible) {
      this.changeVisible(false);
    }
  };
    Base.prototype.destroy = function () {
    this.off();
    this.destroyed = true;
  };
    Base.prototype.changeVisible = function (visible) {
    if (this.visible === visible) {
      return;
    }
    this.visible = visible;
  };
  return Base;
}(event_emitter_1.default);
exports.default = Base;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerFacet = exports.getFacet = exports.Facet = void 0;
var util_1 = __webpack_require__(0);
var facet_1 = __webpack_require__(105);
Object.defineProperty(exports, "Facet", {
  enumerable: true,
  get: function get() {
    return facet_1.Facet;
  }
});
var Facets = {};
var getFacet = function getFacet(type) {
  return Facets[(0, util_1.lowerCase)(type)];
};
exports.getFacet = getFacet;
var registerFacet = function registerFacet(type, ctor) {
  Facets[(0, util_1.lowerCase)(type)] = ctor;
};
exports.registerFacet = registerFacet;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAxisTitleText = exports.getAxisDirection = exports.getAxisOption = exports.getCircleAxisCenterRadius = exports.getAxisTitleOptions = exports.getAxisThemeCfg = exports.getAxisFactorByRegion = exports.isVertical = exports.getAxisFactor = exports.getAxisRegion = exports.getCircleAxisRelativeRegion = exports.getLineAxisRelativeRegion = void 0;
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var scale_1 = __webpack_require__(111);
var matrix_util_1 = __webpack_require__(32);
function getLineAxisRelativeRegion(direction) {
  var start;
  var end;
  switch (direction) {
    case constant_1.DIRECTION.TOP:
      start = {
        x: 0,
        y: 1
      };
      end = {
        x: 1,
        y: 1
      };
      break;
    case constant_1.DIRECTION.RIGHT:
      start = {
        x: 1,
        y: 0
      };
      end = {
        x: 1,
        y: 1
      };
      break;
    case constant_1.DIRECTION.BOTTOM:
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 0
      };
      break;
    case constant_1.DIRECTION.LEFT:
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
      break;
    default:
      start = end = {
        x: 0,
        y: 0
      };
  }
  return {
    start: start,
    end: end
  };
}
exports.getLineAxisRelativeRegion = getLineAxisRelativeRegion;
function getCircleAxisRelativeRegion(coordinate) {
  var start;
  var end;
  if (coordinate.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }
  return {
    start: start,
    end: end
  };
}
exports.getCircleAxisRelativeRegion = getCircleAxisRelativeRegion;
function getAxisRegion(coordinate, direction) {
  var region = {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 0
    }
  };
  if (coordinate.isRect) {
    region = getLineAxisRelativeRegion(direction);
  } else if (coordinate.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate);
  }
  var start = region.start,
    end = region.end;
  return {
    start: coordinate.convert(start),
    end: coordinate.convert(end)
  };
}
exports.getAxisRegion = getAxisRegion;
function getAxisFactor(coordinate, direction) {
  
  if (coordinate.isRect) {
    return coordinate.isTransposed ? [constant_1.DIRECTION.RIGHT, constant_1.DIRECTION.BOTTOM].includes(direction) ? 1 : -1 : [constant_1.DIRECTION.BOTTOM, constant_1.DIRECTION.RIGHT].includes(direction) ? -1 : 1;
  }
  
  if (coordinate.isPolar) {
    var startAngle = coordinate.x.start;
    return startAngle < 0 ? -1 : 1;
  }
  return 1;
}
exports.getAxisFactor = getAxisFactor;
function isVertical(region) {
  var start = region.start,
    end = region.end;
  return start.x === end.x;
}
exports.isVertical = isVertical;
function getAxisFactorByRegion(region, center) {
  var start = region.start,
    end = region.end;
  var isAxisVertical = isVertical(region);
  
  if (isAxisVertical) {
    
    if ((start.y - end.y) * (center.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    
    if ((end.x - start.x) * (start.y - center.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}
exports.getAxisFactorByRegion = getAxisFactorByRegion;
function getAxisThemeCfg(theme, direction) {
  var axisTheme = (0, util_1.get)(theme, ['components', 'axis'], {});
  return (0, util_1.deepMix)({}, (0, util_1.get)(axisTheme, ['common'], {}), (0, util_1.deepMix)({}, (0, util_1.get)(axisTheme, [direction], {})));
}
exports.getAxisThemeCfg = getAxisThemeCfg;
function getAxisTitleOptions(theme, direction, axisOptions) {
  var axisTheme = (0, util_1.get)(theme, ['components', 'axis'], {});
  return (0, util_1.deepMix)({}, (0, util_1.get)(axisTheme, ['common', 'title'], {}), (0, util_1.deepMix)({}, (0, util_1.get)(axisTheme, [direction, 'title'], {})), axisOptions);
}
exports.getAxisTitleOptions = getAxisTitleOptions;
function getCircleAxisCenterRadius(coordinate) {
  
  var x = coordinate.x,
    y = coordinate.y,
    center = coordinate.circleCenter;
  var isReflectY = y.start > y.end;
  var start = coordinate.isTransposed ? coordinate.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center.x, start.y - center.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center.y ? matrix_util_1.vec2.angle(startVector, normalVector) : matrix_util_1.vec2.angle(startVector, normalVector) * -1;
  var endAngle = startAngle + (x.end - x.start);
  var radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
  return {
    center: center,
    radius: radius,
    startAngle: startAngle,
    endAngle: endAngle
  };
}
exports.getCircleAxisCenterRadius = getCircleAxisCenterRadius;
function getAxisOption(axes, field) {
  if ((0, util_1.isBoolean)(axes)) {
    return axes === false ? false : {};
  }
  return (0, util_1.get)(axes, [field]);
}
exports.getAxisOption = getAxisOption;
function getAxisDirection(axisOption, def) {
  return (0, util_1.get)(axisOption, 'position', def);
}
exports.getAxisDirection = getAxisDirection;
function getAxisTitleText(scale, axisOption) {
  return (0, util_1.get)(axisOption, ['title', 'text'], (0, scale_1.getName)(scale));
}
exports.getAxisTitleText = getAxisTitleText;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActionClass = exports.registerAction = exports.Action = exports.Interaction = exports.createInteraction = exports.registerInteraction = exports.getInteraction = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var grammar_interaction_1 = (0, tslib_1.__importDefault)(__webpack_require__(936));
var Interactions = {};
function getInteraction(name) {
  return Interactions[(0, util_1.lowerCase)(name)];
}
exports.getInteraction = getInteraction;
function registerInteraction(name, interaction) {
  Interactions[(0, util_1.lowerCase)(name)] = interaction;
}
exports.registerInteraction = registerInteraction;
function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);
  if (!interaciton) {
    return null;
  }
  if ((0, util_1.isPlainObject)(interaciton)) {
    
    var steps = (0, util_1.mix)((0, util_1.clone)(interaciton), cfg);
    return new grammar_interaction_1.default(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}
exports.createInteraction = createInteraction;
var interaction_1 = __webpack_require__(445);
Object.defineProperty(exports, "Interaction", {
  enumerable: true,
  get: function get() {
    return (0, tslib_1.__importDefault)(interaction_1).default;
  }
});
var action_1 = __webpack_require__(185);
Object.defineProperty(exports, "Action", {
  enumerable: true,
  get: function get() {
    return action_1.Action;
  }
});
Object.defineProperty(exports, "registerAction", {
  enumerable: true,
  get: function get() {
    return action_1.registerAction;
  }
});
Object.defineProperty(exports, "getActionClass", {
  enumerable: true,
  get: function get() {
    return action_1.getActionClass;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePadding = exports.isAutoPadding = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
function isAutoPadding(padding) {
  return !(0, util_1.isNumber)(padding) && !(0, util_1.isArray)(padding);
}
exports.isAutoPadding = isAutoPadding;
function parsePadding(padding) {
  if (padding === void 0) {
    padding = 0;
  }
  var paddingArray = (0, util_1.isArray)(padding) ? padding : [padding];
  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;
    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;
    case 2:
      paddingArray = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], paddingArray, true), paddingArray, true);
      break;
    case 3:
      paddingArray = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], paddingArray, true), [paddingArray[1]], false);
      break;
    default:
      
      paddingArray = paddingArray.slice(0, 4);
      break;
  }
  return paddingArray;
}
exports.parsePadding = parsePadding;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var dependents_1 = __webpack_require__(69);
var Event = function () {
  function Event(view, gEvent, data) {
    this.view = view;
    this.gEvent = gEvent;
    this.data = data;
    this.type = gEvent.type;
  }
    Event.fromData = function (view, type, data) {
    return new Event(view, new dependents_1.Event(type, {}), data);
  };
  Object.defineProperty(Event.prototype, "target", {
    
        get: function get() {
      
      
      return this.gEvent.target;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "event", {
        get: function get() {
      return this.gEvent.originalEvent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "x", {
        get: function get() {
      return this.gEvent.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "y", {
        get: function get() {
      return this.gEvent.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "clientX", {
        get: function get() {
      return this.gEvent.clientX;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "clientY", {
        get: function get() {
      return this.gEvent.clientY;
    },
    enumerable: false,
    configurable: true
  });
  
    Event.prototype.toString = function () {
    return "[Event (type=" + this.type + ")]";
  };
    Event.prototype.clone = function () {
    return new Event(this.view, this.gEvent, this.data);
  };
  return Event;
}();
exports.default = Event;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);


var component_1 = __webpack_require__(179);
var animate_1 = __webpack_require__(97);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(263));
var graphics_1 = __webpack_require__(46);
var constant_1 = __webpack_require__(21);
var constant_2 = __webpack_require__(270);
var Element = function (_super) {
  (0, tslib_1.__extends)(Element, _super);
  function Element(cfg) {
    var _this = _super.call(this, cfg) || this;
    
    _this.states = [];
    var shapeFactory = cfg.shapeFactory,
      container = cfg.container,
      offscreenGroup = cfg.offscreenGroup,
      elementIndex = cfg.elementIndex,
      _a = cfg.visible,
      visible = _a === void 0 ? true : _a;
    _this.shapeFactory = shapeFactory;
    _this.container = container;
    _this.offscreenGroup = offscreenGroup;
    _this.visible = visible;
    _this.elementIndex = elementIndex;
    return _this;
  }
    Element.prototype.draw = function (model, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.model = model;
    this.data = model.data; 
    this.shapeType = this.getShapeType(model);
    
    this.drawShape(model, isUpdate);
    if (this.visible === false) {
      
      this.changeVisible(false);
    }
  };
    Element.prototype.update = function (model) {
    var _a = this,
      shapeFactory = _a.shapeFactory,
      shape = _a.shape;
    if (!shape) {
      return;
    }
    
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    
    this.setShapeInfo(shape, model);
    
    var offscreenGroup = this.getOffscreenGroup();
    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
    
    newShape.cfg.data = this.data;
    
    newShape.cfg.origin = model;
    
    newShape.cfg.element = this;
    
    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));
  };
    Element.prototype.destroy = function () {
    var _a = this,
      shapeFactory = _a.shapeFactory,
      shape = _a.shape;
    if (shape) {
      var animateCfg = this.getAnimateCfg('leave');
      if (animateCfg) {
        
        (0, animate_1.doAnimate)(shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: (0, tslib_1.__assign)({}, shape.attr())
        });
      } else {
        
        shape.remove(true);
      }
    }
    
    this.states = [];
    this.shapeFactory = undefined;
    this.container = undefined;
    this.shape = undefined;
    this.animate = undefined;
    this.geometry = undefined;
    this.labelShape = undefined;
    this.model = undefined;
    this.data = undefined;
    this.offscreenGroup = undefined;
    this.statesStyle = undefined;
    _super.prototype.destroy.call(this);
  };
    Element.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible);
    if (visible) {
      if (this.shape) {
        this.shape.show();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function (label) {
          label.show();
        });
      }
    } else {
      if (this.shape) {
        this.shape.hide();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function (label) {
          label.hide();
        });
      }
    }
  };
    Element.prototype.setState = function (stateName, stateStatus) {
    var _a = this,
      states = _a.states,
      shapeFactory = _a.shapeFactory,
      model = _a.model,
      shape = _a.shape,
      shapeType = _a.shapeType;
    var index = states.indexOf(stateName);
    if (stateStatus) {
      
      if (index > -1) {
        
        return;
      }
      states.push(stateName);
      if (stateName === 'active' || stateName === 'selected') {
        shape === null || shape === void 0 ? void 0 : shape.toFront();
      }
    } else {
      if (index === -1) {
        
        return;
      }
      states.splice(index, 1);
      if (stateName === 'active' || stateName === 'selected') {
        if (this.geometry.zIndexReversed) {
          shape.setZIndex(this.geometry.elements.length - this.elementIndex);
        } else {
          shape.setZIndex(this.elementIndex);
        }
      }
    }
    
    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
    if (states.length) {
      
      this.syncShapeStyle(shape, offscreenShape, states, null);
    } else {
      
      this.syncShapeStyle(shape, offscreenShape, ['reset'], null);
    }
    offscreenShape.remove(true); 
    var eventObject = {
      state: stateName,
      stateStatus: stateStatus,
      element: this,
      target: this.container
    };
    this.container.emit('statechange', eventObject);
    
    (0, component_1.propagationDelegate)(this.shape, 'statechange', eventObject);
  };
    Element.prototype.clearStates = function () {
    var _this = this;
    var states = this.states;
    (0, util_1.each)(states, function (state) {
      _this.setState(state, false);
    });
    this.states = [];
  };
    Element.prototype.hasState = function (stateName) {
    return this.states.includes(stateName);
  };
    Element.prototype.getStates = function () {
    return this.states;
  };
    Element.prototype.getData = function () {
    return this.data;
  };
    Element.prototype.getModel = function () {
    return this.model;
  };
    Element.prototype.getBBox = function () {
    var _a = this,
      shape = _a.shape,
      labelShape = _a.labelShape;
    var bbox = {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
    if (shape) {
      bbox = shape.getCanvasBBox();
    }
    if (labelShape) {
      labelShape.forEach(function (label) {
        var labelBBox = label.getCanvasBBox();
        bbox.x = Math.min(labelBBox.x, bbox.x);
        bbox.y = Math.min(labelBBox.y, bbox.y);
        bbox.minX = Math.min(labelBBox.minX, bbox.minX);
        bbox.minY = Math.min(labelBBox.minY, bbox.minY);
        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
      });
    }
    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    return bbox;
  };
  Element.prototype.getStatesStyle = function () {
    if (!this.statesStyle) {
      var _a = this,
        shapeType = _a.shapeType,
        geometry = _a.geometry,
        shapeFactory = _a.shapeFactory;
      var stateOption = geometry.stateOption;
      var defaultShapeType = shapeFactory.defaultShapeType;
      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
      this.statesStyle = (0, util_1.deepMix)({}, stateTheme, stateOption);
    }
    return this.statesStyle;
  };
  
  Element.prototype.getStateStyle = function (stateName, shapeKey) {
    var statesStyle = this.getStatesStyle();
    var stateCfg = (0, util_1.get)(statesStyle, [stateName, 'style'], {});
    var shapeStyle = stateCfg[shapeKey] || stateCfg;
    if ((0, util_1.isFunction)(shapeStyle)) {
      return shapeStyle(this);
    }
    return shapeStyle;
  };
  
  Element.prototype.getAnimateCfg = function (animateType) {
    var _this = this;
    var animate = this.animate;
    if (animate) {
      var cfg_1 = animate[animateType];
      if (cfg_1) {
        
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cfg_1), {
          callback: function callback() {
            var _a;
            (0, util_1.isFunction)(cfg_1.callback) && cfg_1.callback();
            (_a = _this.geometry) === null || _a === void 0 ? void 0 : _a.emit(constant_1.GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
          }
        });
      }
      return cfg_1;
    }
    return null;
  };
  
  Element.prototype.drawShape = function (model, isUpdate) {
    var _a;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var _b = this,
      shapeFactory = _b.shapeFactory,
      container = _b.container,
      shapeType = _b.shapeType;
    
    this.shape = shapeFactory.drawShape(shapeType, model, container);
    if (this.shape) {
      this.setShapeInfo(this.shape, model); 
      
      var name_1 = this.shape.cfg.name;
      
      if (!name_1) {
        
        
        this.shape.cfg.name = ['element', this.shapeFactory.geometryType];
      } else if ((0, util_1.isString)(name_1)) {
        
        this.shape.cfg.name = ['element', name_1];
      }
      
      var animateType = isUpdate ? 'enter' : 'appear';
      var animateCfg = this.getAnimateCfg(animateType);
      if (animateCfg) {
        
        (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(constant_1.GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
        (0, animate_1.doAnimate)(this.shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: (0, tslib_1.__assign)({}, this.shape.attr())
        });
      }
    }
  };
  
  Element.prototype.getOffscreenGroup = function () {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase(); 
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  
  Element.prototype.setShapeInfo = function (shape, data) {
    var _this = this;
    
    shape.cfg.origin = data;
    
    shape.cfg.element = this;
    if (shape.isGroup()) {
      var children = shape.get('children');
      children.forEach(function (child) {
        _this.setShapeInfo(child, data);
      });
    }
  };
  
  Element.prototype.syncShapeStyle = function (sourceShape, targetShape, states, animateCfg, index) {
    var _this = this;
    var _a;
    if (states === void 0) {
      states = [];
    }
    if (index === void 0) {
      index = 0;
    }
    if (!sourceShape || !targetShape) {
      return;
    }
    
    var clip = sourceShape.get('clipShape');
    var newClip = targetShape.get('clipShape');
    this.syncShapeStyle(clip, newClip, states, animateCfg);
    if (sourceShape.isGroup()) {
      var children = sourceShape.get('children');
      var newChildren = targetShape.get('children');
      for (var i = 0; i < children.length; i++) {
        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
      }
    } else {
      if (!(0, util_1.isEmpty)(states) && !(0, util_1.isEqual)(states, ['reset'])) {
        var name_2 = sourceShape.get('name');
        if ((0, util_1.isArray)(name_2)) {
          
          name_2 = name_2[1];
        }
        (0, util_1.each)(states, function (state) {
          
          if (targetShape.get('name') !== constant_2.BACKGROUND_SHAPE) {
            var style = _this.getStateStyle(state, name_2 || index); 
            targetShape.attr(style);
          }
        });
      }
      var newAttrs = (0, graphics_1.getReplaceAttrs)(sourceShape, targetShape);
      if (this.animate) {
        if (animateCfg) {
          (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(constant_1.GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          
          (0, animate_1.doAnimate)(sourceShape, animateCfg, {
            coordinate: this.shapeFactory.coordinate,
            toAttrs: newAttrs,
            shapeModel: this.model
          });
        } else if (!(0, util_1.isEmpty)(states)) {
          sourceShape.stopAnimate();
          sourceShape.animate(newAttrs, {
            duration: 300
          });
        } else {
          sourceShape.attr(newAttrs);
        }
      } else {
        sourceShape.attr(newAttrs);
      }
    }
  };
  Element.prototype.getShapeType = function (model) {
    var shape = (0, util_1.get)(model, 'shape');
    return (0, util_1.isArray)(shape) ? shape[0] : shape;
  };
  return Element;
}(base_1.default);
exports.default = Element;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BACKGROUND_SHAPE = void 0;
exports.BACKGROUND_SHAPE = 'element-background';

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerGeometryLabelLayout = exports.getGeometryLabelLayout = exports.registerGeometryLabel = exports.getGeometryLabel = void 0;
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
function getGeometryLabel(type) {
  return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
exports.getGeometryLabel = getGeometryLabel;
function registerGeometryLabel(type, ctor) {
  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
exports.registerGeometryLabel = registerGeometryLabel;
function getGeometryLabelLayout(type) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
exports.getGeometryLabelLayout = getGeometryLabelLayout;
function registerGeometryLabelLayout(type, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}
exports.registerGeometryLabelLayout = registerGeometryLabelLayout;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _gBase = __webpack_require__(26);
var Shape = _interopRequireWildcard(__webpack_require__(147));
var _draw = __webpack_require__(148);
var _util = __webpack_require__(0);
var _util2 = __webpack_require__(53);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var Group = function (_super) {
  (0, _tslib.__extends)(Group, _super);
  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
    Group.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };
  Group.prototype.getShapeBase = function () {
    return Shape;
  };
  Group.prototype.getGroupBase = function () {
    return Group;
  };
  
  Group.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save();
      
      (0, _draw.applyAttrsToContext)(context, clip);
      
      clip.createPath(context);
      context.restore();
      
      context.clip();
      clip._afterDraw();
    }
  };
  
  
  Group.prototype.cacheCanvasBBox = function () {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    (0, _util.each)(children, function (child) {
      var bbox = child.cfg.cacheCanvasBBox;
      
      
      if (bbox && child.cfg.isInView) {
        xArr.push(bbox.minX, bbox.maxX);
        yArr.push(bbox.minY, bbox.maxY);
      }
    });
    var bbox = null;
    if (xArr.length) {
      var minX = (0, _util.min)(xArr);
      var maxX = (0, _util.max)(xArr);
      var minY = (0, _util.min)(yArr);
      var maxY = (0, _util.max)(yArr);
      bbox = {
        minX: minX,
        minY: minY,
        x: minX,
        y: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;
      if (canvas) {
        var viewRange = canvas.getViewRange();
        
        
        this.set('isInView', (0, _util2.intersectRect)(bbox, viewRange));
      }
    } else {
      this.set('isInView', false);
    }
    this.set('cacheCanvasBBox', bbox);
  };
  Group.prototype.draw = function (context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true; 
    
    
    
    if (children.length && allowDraw) {
      context.save();
      
      
      (0, _draw.applyAttrsToContext)(context, this);
      this._applyClip(context, this.getClip());
      (0, _draw.drawChildren)(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    }
    
    
    this.cfg.refresh = null;
    
    this.set('hasChanged', false);
  };
  
  Group.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('hasChanged', false);
  };
  return Group;
}(_gBase.AbstractGroup);
var _default = Group;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawChildren = drawChildren;
exports.refreshElement = refreshElement;
var _svg = __webpack_require__(149);
var _dom = __webpack_require__(74);
function drawChildren(context, children) {
  children.forEach(function (child) {
    child.draw(context);
  });
}
function refreshElement(element, changeType) {
  
  var canvas = element.get('canvas');
  
  if (canvas && canvas.get('autoDraw')) {
    var context = canvas.get('context');
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get('el');
    if (changeType === 'remove') {
      var isClipShape = element.get('isClipShape');
      
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === 'show') {
      el.setAttribute('visibility', 'visible');
    } else if (changeType === 'hide') {
      el.setAttribute('visibility', 'hidden');
    } else if (changeType === 'zIndex') {
      (0, _dom.moveTo)(el, parentChildren.indexOf(element));
    } else if (changeType === 'sort') {
      var children_1 = element.get('children');
      if (children_1 && children_1.length) {
        (0, _dom.sortDom)(element, function (a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === 'clear') {
      
      if (el) {
        el.innerHTML = '';
      }
    } else if (changeType === 'matrix') {
      (0, _svg.setTransform)(element);
    } else if (changeType === 'clip') {
      (0, _svg.setClip)(element, context);
    } else if (changeType === 'attr') {
      
    } else if (changeType === 'add') {
      element.draw(context);
    }
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _gBase = __webpack_require__(26);
var _util = __webpack_require__(0);
var Shape = _interopRequireWildcard(__webpack_require__(190));
var _draw = __webpack_require__(274);
var _svg = __webpack_require__(149);
var _constant = __webpack_require__(54);
var _dom = __webpack_require__(74);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var Group = function (_super) {
  (0, _tslib.__extends)(Group, _super);
  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  
  Group.prototype.isEntityGroup = function () {
    return true;
  };
  Group.prototype.createDom = function () {
    var element = (0, _dom.createSVGElement)('g');
    this.set('el', element);
    var parent = this.getParent();
    if (parent) {
      var parentNode = parent.get('el');
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        
        parentNode = parent.createDom();
        parent.set('el', parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  };
  
  Group.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get('canvas');
    
    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.createPath(context, targetAttrs);
    }
  };
    Group.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };
  Group.prototype.getShapeBase = function () {
    return Shape;
  };
  Group.prototype.getGroupBase = function () {
    return Group;
  };
  Group.prototype.draw = function (context) {
    var children = this.getChildren();
    var el = this.get('el');
    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }
      (0, _svg.setClip)(this, context);
      this.createPath(context);
      if (children.length) {
        (0, _draw.drawChildren)(context, children);
      }
    }
  };
    Group.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
    (0, _svg.setTransform)(this);
  };
  return Group;
}(_gBase.AbstractGroup);
var _default = Group;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_path_points_1 = __webpack_require__(115);
var get_style_1 = __webpack_require__(33);
var path_1 = __webpack_require__(112);
var split_points_1 = __webpack_require__(277);
var util_2 = __webpack_require__(460);
function getShapeAttrs(cfg, smooth, constraint) {
  var isStack = cfg.isStack,
    connectNulls = cfg.connectNulls,
    isInCircle = cfg.isInCircle,
    showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = (0, get_style_1.getStyle)(cfg, true, false, 'lineWidth');
  var points = (0, get_path_points_1.getPathPoints)(cfg.points, connectNulls, showSinglePoint); 
  var path = [];
  for (var i = 0, len = points.length; i < len; i++) {
    var eachLinePoints = points[i];
    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }
  shapeAttrs.path = path;
  return shapeAttrs;
}

function getSinglePath(points, isInCircle, smooth, constraint, style) {
  if (points.length === 1) {
    
    return [['M', points[0].x, points[0].y - style.lineWidth / 2], ['L', points[0].x, points[0].y], ['L', points[0].x, points[0].y + style.lineWidth / 2]];
  }
  var path;
  if (!smooth) {
    path = (0, path_1.getLinePath)(points, false);
    if (isInCircle) {
      path.push(['Z']);
    }
  } else {
    
    if (isInCircle && points.length) {
      points.push({
        x: points[0].x,
        y: points[0].y
      });
    }
    path = (0, path_1.getSplinePath)(points, false, constraint);
  }
  return path;
}
function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
  var topPoints = [];
  var bottomPoints = [];
  (0, util_1.each)(points, function (point) {
    var result = (0, split_points_1.splitPoints)(point);
    topPoints.push(result[1]); 
    bottomPoints.push(result[0]); 
  });

  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
  if (isStack) {
    return topPath;
  }
  return topPath.concat(bottomPath);
}
function getPath(points, isInCircle, isStack, smooth, constraint, style) {
  if (points.length) {
    var first = points[0];
    return (0, util_1.isArray)(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
  }
  return [];
}
var LineShapeFactory = (0, base_1.registerShapeFactory)('line', {
  defaultShapeType: 'line'
});


(0, util_1.each)(['line', 'dot', 'dash', 'smooth'], function (shapeType) {
  (0, base_1.registerShape)('line', shapeType, {
    draw: function draw(cfg, container) {
      var smooth = shapeType === 'smooth';
      var constraint;
      if (smooth) {
        var _a = this.coordinate,
          start = _a.start,
          end = _a.end;
        constraint = [[start.x, end.y], [end.x, start.y]];
      }
      var attrs = getShapeAttrs(cfg, smooth, constraint);
      var shape = container.addShape({
        type: 'path',
        attrs: attrs,
        name: 'line',
        capture: !smooth
      });
      return shape;
    },
    getMarker: function getMarker(markerCfg) {
      return (0, util_2.getLineMarker)(markerCfg, shapeType);
    }
  });
});
exports.default = LineShapeFactory;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitPoints = void 0;
var util_1 = __webpack_require__(0);
function splitPoints(obj) {
  
  var x = obj.x;
  var y = (0, util_1.isArray)(obj.y) ? obj.y : [obj.y];
  return y.map(function (eachY, index) {
    return {
      x: (0, util_1.isArray)(x) ? x[index] : x,
      y: eachY
    };
  });
}
exports.splitPoints = splitPoints;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var util_2 = __webpack_require__(101);
var AreaShapeFactory = (0, base_1.registerShapeFactory)('area', {
  defaultShapeType: 'area',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    
    var x = pointInfo.x,
      y0 = pointInfo.y0;
    var y = (0, util_1.isArray)(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y.map(function (yItem) {
      return {
        x: x,
        y: yItem
      };
    });
  }
});

(0, base_1.registerShape)('area', 'area', {
  draw: function draw(cfg, container) {
    var attrs = (0, util_2.getShapeAttrs)(cfg, false, false, this);
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
      },
      style: {
        r: 5,
        fill: color
      }
    };
  }
});
exports.default = AreaShapeFactory;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultSize = void 0;
var util_1 = __webpack_require__(0);
var coordinate_1 = __webpack_require__(48);

function findMinDistance(arr, scale) {
  var count = arr.length;
  var sourceArr = arr;
  if ((0, util_1.isString)(sourceArr[0])) {
    
    sourceArr = arr.map(function (v) {
      return scale.translate(v);
    });
  }
  var distance = sourceArr[1] - sourceArr[0];
  for (var i = 2; i < count; i++) {
    var tmp = sourceArr[i] - sourceArr[i - 1];
    if (distance > tmp) {
      distance = tmp;
    }
  }
  return distance;
}
function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData = (0, util_1.flatten)(dataArray);
    var values = (0, util_1.valuesOfKey)(mergeData, dodgeBy);
    return values.length;
  }
  return dataArray.length;
}
function getDefaultSize(geometry) {
  var theme = geometry.theme;
  var coordinate = geometry.coordinate;
  var xScale = geometry.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry.beforeMappingData;
  var count = xValues.length;
  var xDimensionLength = (0, coordinate_1.getXDimensionLength)(geometry.coordinate);
  
  var intervalPadding = geometry.intervalPadding,
    dodgePadding = geometry.dodgePadding;
  
  var maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;
  var minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;
  var columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;
  var multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;
  var roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio;
  
  if (xScale.isLinear && xValues.length > 1) {
    
    xValues.sort();
    var interval = findMinDistance(xValues, xScale);
    count = (xScale.max - xScale.min) / interval;
    if (xValues.length > count) {
      count = xValues.length;
    }
  }
  var range = xScale.range;
  var normalizedSize = 1 / count;
  var wr = 1;
  if (coordinate.isPolar) {
    
    if (coordinate.isTransposed && count > 1) {
      
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    
    if (xScale.isLinear) {
      normalizedSize *= range[1] - range[0];
    }
    wr = columnWidthRatio;
  }
  
  if (!(0, util_1.isNil)(intervalPadding) && intervalPadding >= 0) {
    
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;
  } else {
    
    normalizedSize *= wr;
  }
  
  if (geometry.getAdjust('dodge')) {
    var dodgeAdjust = geometry.getAdjust('dodge');
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);
    if (!(0, util_1.isNil)(dodgePadding) && dodgePadding >= 0) {
      
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!(0, util_1.isNil)(intervalPadding) && intervalPadding >= 0) {
      
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      
      normalizedSize = normalizedSize / dodgeCount;
    }
    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  }
  
  if (!(0, util_1.isNil)(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  }
  
  if (!(0, util_1.isNil)(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }
  return normalizedSize;
}
exports.getDefaultSize = getDefaultSize;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawPoints = exports.HOLLOW_SHAPES = exports.SHAPES = void 0;
var tslib_1 = __webpack_require__(1);
var marker_1 = __webpack_require__(146);
var get_style_1 = __webpack_require__(33);
exports.SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];
exports.HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line'];
function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var style = (0, get_style_1.getStyle)(cfg, isStroke, !isStroke, 'r');
  var points = shape.parsePoints(cfg.points);
  var pointPosition = points[0];
  if (cfg.isStack) {
    pointPosition = points[1];
  } else if (points.length > 1) {
    var group = container.addGroup();
    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
      var point = points_1[_i];
      group.addShape({
        type: 'marker',
        attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
          symbol: marker_1.MarkerSymbols[shapeName] || shapeName
        }), point)
      });
    }
    return group;
  }
  return container.addShape({
    type: 'marker',
    attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
      symbol: marker_1.MarkerSymbols[shapeName] || shapeName
    }), pointPosition)
  });
}
exports.drawPoints = drawPoints;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_path_points_1 = __webpack_require__(115);
var get_style_1 = __webpack_require__(33);
var util_2 = __webpack_require__(460);
var interpolateCallback = function interpolateCallback(point, nextPoint, shapeType) {
  var x = point.x;
  var y = point.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result;
  switch (shapeType) {
    case 'hv':
      result = [{
        x: nextX,
        y: y
      }];
      break;
    case 'vh':
      result = [{
        x: x,
        y: nextY
      }];
      break;
    case 'hvh':
      var middleX = (nextX + x) / 2;
      result = [{
        x: middleX,
        y: y
      }, {
        x: middleX,
        y: nextY
      }];
      break;
    case 'vhv':
      var middleY = (y + nextY) / 2;
      result = [{
        x: x,
        y: middleY
      }, {
        x: nextX,
        y: middleY
      }];
      break;
    default:
      break;
  }
  return result;
};
function getInterpolatePoints(points, shapeType) {
  var result = [];
  (0, util_1.each)(points, function (point, index) {
    var nextPoint = points[index + 1];
    result.push(point);
    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);
      result = result.concat(interpolatePoint);
    }
  });
  return result;
}

function getInterpolatePath(points) {
  return points.map(function (point, index) {
    return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];
  });
}

function getInterpolateShapeAttrs(cfg, shapeType) {
  var points = (0, get_path_points_1.getPathPoints)(cfg.points, cfg.connectNulls, cfg.showSinglePoint); 
  var path = [];
  (0, util_1.each)(points, function (eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path = path.concat(getInterpolatePath(interpolatePoints));
  });
  return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, (0, get_style_1.getStyle)(cfg, true, false, 'lineWidth')), {
    path: path
  });
}

(0, util_1.each)(['hv', 'vh', 'hvh', 'vhv'], function (shapeType) {
  (0, base_1.registerShape)('line', shapeType, {
    draw: function draw(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: 'path',
        attrs: attrs,
        name: 'line'
      });
      return shape;
    },
    getMarker: function getMarker(markerCfg) {
      return (0, util_2.getLineMarker)(markerCfg, shapeType);
    }
  });
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTranslateDirection = exports.directionToPosition = void 0;
var constant_1 = __webpack_require__(21);
function directionToPosition(parentBBox, bbox, direction) {
  if (direction === constant_1.DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }
  if (direction === constant_1.DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }
  if (direction === constant_1.DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction === constant_1.DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction === constant_1.DIRECTION.TOP_LEFT || direction === constant_1.DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }
  if (direction === constant_1.DIRECTION.TOP_RIGHT || direction === constant_1.DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }
  if (direction === constant_1.DIRECTION.BOTTOM_LEFT || direction === constant_1.DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }
  if (direction === constant_1.DIRECTION.BOTTOM_RIGHT || direction === constant_1.DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }
  return [0, 0];
}
exports.directionToPosition = directionToPosition;
function getTransposedDirection(direction, coordinate) {
  if (coordinate.isTransposed) {
    switch (direction) {
      case constant_1.DIRECTION.BOTTOM:
        return constant_1.DIRECTION.LEFT;
      case constant_1.DIRECTION.LEFT:
        return constant_1.DIRECTION.BOTTOM;
      case constant_1.DIRECTION.RIGHT:
        return constant_1.DIRECTION.TOP;
      case constant_1.DIRECTION.TOP:
        return constant_1.DIRECTION.RIGHT;
    }
  }
  return direction;
}
function reflectX(direct) {
  if (direct === constant_1.DIRECTION.LEFT) {
    return constant_1.DIRECTION.RIGHT;
  }
  if (direct === constant_1.DIRECTION.RIGHT) {
    return constant_1.DIRECTION.LEFT;
  }
  return direct;
}
function reflectY(direct) {
  if (direct === constant_1.DIRECTION.TOP) {
    return constant_1.DIRECTION.BOTTOM;
  }
  if (direct === constant_1.DIRECTION.BOTTOM) {
    return constant_1.DIRECTION.TOP;
  }
  return direct;
}
function getScaleDirection(direction, coordinate) {
  var x = coordinate.matrix[0];
  var y = coordinate.matrix[4];
  var d = direction;
  if (x < 0) {
    d = reflectX(d);
  }
  if (y < 0) {
    d = reflectY(d);
  }
  return d;
}
function getReflectDirection(direction, coordinate) {
  var d = direction;
  if (coordinate.isReflect('x')) {
    d = reflectX(d);
  }
  if (coordinate.isReflect('y')) {
    d = reflectY(d);
  }
  return d;
}
function getTranslateDirection(direction, coordinate) {
  var d = direction;
  d = getTransposedDirection(d, coordinate);
  d = getScaleDirection(d, coordinate);
  d = getReflectDirection(d, coordinate);
  return d;
}
exports.getTranslateDirection = getTranslateDirection;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(31);
var state_base_1 = (0, tslib_1.__importDefault)(__webpack_require__(284));
function getItem(shape) {
  return (0, util_1.get)(shape.get('delegateObject'), 'item');
}
var ElementState = function (_super) {
  (0, tslib_1.__extends)(ElementState, _super);
  function ElementState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreListItemStates = ['unchecked'];
    return _this;
  }
  
  ElementState.prototype.isItemIgnore = function (item, list) {
    var states = this.ignoreListItemStates;
    var filtered = states.filter(function (state) {
      return list.hasState(item, state);
    });
    return !!filtered.length;
  };
  
  ElementState.prototype.setStateByComponent = function (component, item, enable) {
    var view = this.context.view;
    var field = component.get('field');
    var elements = (0, util_2.getElements)(view);
    this.setElementsStateByItem(elements, field, item, enable);
  };
  
  ElementState.prototype.setStateByElement = function (element, enable) {
    this.setElementState(element, enable);
  };
    ElementState.prototype.isMathItem = function (element, field, item) {
    var view = this.context.view;
    var scale = (0, util_2.getScaleByField)(view, field);
    var value = (0, util_2.getElementValue)(element, field);
    return !(0, util_1.isNil)(value) && item.name === scale.getText(value);
  };
  ElementState.prototype.setElementsStateByItem = function (elements, field, item, enable) {
    var _this = this;
    (0, util_1.each)(elements, function (el) {
      if (_this.isMathItem(el, field, item)) {
        el.setState(_this.stateName, enable);
      }
    });
  };
    ElementState.prototype.setStateEnable = function (enable) {
    var element = (0, util_2.getCurrentElement)(this.context);
    if (element) {
      
      if ((0, util_2.isElementChange)(this.context)) {
        this.setStateByElement(element, enable);
      }
    } else {
      
      var delegateObject = (0, util_2.getDelegationObject)(this.context);
      
      if ((0, util_2.isList)(delegateObject)) {
        var item = delegateObject.item,
          component = delegateObject.component;
        if (item && component && !this.isItemIgnore(item, component)) {
          var event_1 = this.context.event.gEvent;
          
          if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
            return;
          }
          this.setStateByComponent(component, item, enable);
        }
      }
    }
  };
    ElementState.prototype.toggle = function () {
    var element = (0, util_2.getCurrentElement)(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setElementState(element, !hasState);
    }
  };
    ElementState.prototype.reset = function () {
    this.setStateEnable(false);
  };
  return ElementState;
}(state_base_1.default);
exports.default = ElementState;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var util_2 = __webpack_require__(31);
var StateBase = function (_super) {
  (0, tslib_1.__extends)(StateBase, _super);
  function StateBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = '';
    return _this;
  }
  /**
   * 是否具有某个状态
   * @param element 图表 Element 元素
   */
  StateBase.prototype.hasState = function (element) {
    return element.hasState(this.stateName);
  };
  /**
   * 设置状态激活
   * @param enable 状态值
   */
  StateBase.prototype.setElementState = function (element, enable) {
    // 防止闪烁
    element.setState(this.stateName, enable);
  };
  /**
   * 设置状态
   */
  StateBase.prototype.setState = function () {
    this.setStateEnable(true);
  };
  /**
   * 清除所有 Element 的状态
   */
  StateBase.prototype.clear = function () {
    var view = this.context.view;
    this.clearViewState(view);
  };
  StateBase.prototype.clearViewState = function (view) {
    var _this = this;
    var elements = (0, util_2.getElementsByState)(view, this.stateName);
    (0, util_1.each)(elements, function (el) {
      _this.setElementState(el, false);
    });
  };
  return StateBase;
}(base_1.default);
exports.default = StateBase;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(31);
var state_base_1 = (0, tslib_1.__importDefault)(__webpack_require__(284));
/**
 * @ignore
 * 区域设置状态的基础 Action
 */
var ElementRangeState = /** @class */function (_super) {
  (0, tslib_1.__extends)(ElementRangeState, _super);
  function ElementRangeState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.endPoint = null;
    _this.isStarted = false;
    /**
     * 是否作用于当前 view 的 siblings，默认是 false 仅作用于自己
     */
    _this.effectSiblings = false;
    /**
     * 是否受 element 的数据影响，还是受包围盒的影响
     */
    _this.effectByRecord = false;
    return _this;
  }
  // 获取当前的位置
  ElementRangeState.prototype.getCurrentPoint = function () {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  /**
   * 开始，记录开始选中的位置
   */
  ElementRangeState.prototype.start = function () {
    this.clear(); // 开始的时候清理之前的状态
    this.startPoint = this.getCurrentPoint();
    this.isStarted = true;
  };
  ElementRangeState.prototype.getIntersectElements = function () {
    var elements = null;
    if ((0, util_2.isMask)(this.context)) {
      elements = (0, util_2.getMaskedElements)(this.context, 10);
    } else {
      var startPoint = this.startPoint;
      var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
      // 如果没有开始，则不允许范围设置状态，保护性质
      if (!startPoint || !endPoint) {
        return;
      }
      // 计算框选区域
      var box = {
        minX: Math.min(startPoint.x, endPoint.x),
        minY: Math.min(startPoint.y, endPoint.y),
        maxX: Math.max(startPoint.x, endPoint.x),
        maxY: Math.max(startPoint.y, endPoint.y)
      };
      // this.clear(); // 不全部清理，会导致闪烁
      var view = this.context.view;
      elements = (0, util_2.getIntersectElements)(view, box);
    }
    return elements;
  };
  /**
   * 选中
   */
  ElementRangeState.prototype.setStateEnable = function (enable) {
    if (this.effectSiblings && !this.effectByRecord) {
      this.setSiblingsState(enable);
    } else {
      var allElements = (0, util_2.getElements)(this.context.view);
      var elements = this.getIntersectElements();
      if (elements && elements.length) {
        if (this.effectByRecord) {
          this.setSiblingsStateByRecord(elements, enable);
        } else {
          this.setElementsState(elements, enable, allElements);
        }
      } else {
        this.clear();
      }
    }
  };
  // 根据选中的 element 的数据进行设置状态
  ElementRangeState.prototype.setSiblingsStateByRecord = function (elements, enable) {
    var _this = this;
    var view = this.context.view;
    var siblings = (0, util_2.getSilbings)(view);
    var records = elements.map(function (el) {
      return el.getModel().data;
    });
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    (0, util_1.each)(siblings, function (sibling) {
      var allElements = (0, util_2.getElements)(sibling);
      var effectElements = allElements.filter(function (el) {
        var record = el.getModel().data;
        return (0, util_2.isInRecords)(records, record, xFiled, yField);
      });
      _this.setElementsState(effectElements, enable, allElements);
    });
  };
  // 设置兄弟 view 的状态
  ElementRangeState.prototype.setSiblingsState = function (enable) {
    var _this = this;
    var view = this.context.view;
    var siblings = (0, util_2.getSilbings)(view);
    if ((0, util_2.isMask)(this.context)) {
      // 受 mask 影响
      (0, util_1.each)(siblings, function (sibling) {
        var allElements = (0, util_2.getElements)(sibling);
        var effectElements = (0, util_2.getSiblingMaskElements)(_this.context, sibling, 10);
        if (effectElements && effectElements.length) {
          _this.setElementsState(effectElements, enable, allElements);
        } else {
          _this.clearViewState(sibling);
        }
      });
    }
  };
  ElementRangeState.prototype.setElementsState = function (elements, enable, allElements) {
    var _this = this;
    (0, util_1.each)(allElements, function (el) {
      if (!elements.includes(el)) {
        _this.setElementState(el, false);
      } else {
        _this.setElementState(el, enable);
      }
    });
  };
  /**
   * 结束
   */
  ElementRangeState.prototype.end = function () {
    this.isStarted = false;
    this.endPoint = this.getCurrentPoint();
  };
  // 复写 clear
  ElementRangeState.prototype.clear = function () {
    var _this = this;
    var view = this.context.view;
    // 判断是否影响 siblings
    if (this.effectSiblings) {
      var siblings = (0, util_2.getSilbings)(view);
      (0, util_1.each)(siblings, function (sibling) {
        _this.clearViewState(sibling);
      });
    } else {
      this.clearViewState(view);
    }
  };
  return ElementRangeState;
}(state_base_1.default);
exports.default = ElementRangeState;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(31);
var state_base_1 = (0, tslib_1.__importDefault)(__webpack_require__(284));
/**
 * 单状态量的 Action 基类
 * @class
 * @ignore
 */
var ElementSingleState = /** @class */function (_super) {
  (0, tslib_1.__extends)(ElementSingleState, _super);
  function ElementSingleState() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementSingleState.prototype.setStateEnable = function (enable) {
    var element = (0, util_1.getCurrentElement)(this.context);
    if (element) {
      // 在同一个 element 内部移动，忽视 label 和 shape 之间
      if (!(0, util_1.isElementChange)(this.context)) {
        return;
      }
      // 仅支持单个状态量的元素，只能由 element 触发
      if (enable) {
        this.clear();
        this.setElementState(element, true);
      } else if (this.hasState(element)) {
        this.setElementState(element, false);
      }
    }
  };
  /**
   * 切换选中，只允许选中一个
   */
  ElementSingleState.prototype.toggle = function () {
    var element = (0, util_1.getCurrentElement)(this.context);
    if (element) {
      var hasState = this.hasState(element); // 提前获取状态
      if (!hasState) {
        this.clear();
      }
      this.setElementState(element, !hasState);
    }
  };
  /**
   * 取消当前时间影响的状态
   */
  ElementSingleState.prototype.reset = function () {
    this.setStateEnable(false);
  };
  return ElementSingleState;
}(state_base_1.default);
exports.default = ElementSingleState;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setHighlightBy = exports.clearHighlight = void 0;
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(31);
var STATUS_UNACTIVE = 'inactive';
var STATUS_ACTIVE = 'active';
function clearHighlight(view) {
  var elements = (0, util_2.getElements)(view);
  (0, util_1.each)(elements, function (el) {
    if (el.hasState(STATUS_ACTIVE)) {
      el.setState(STATUS_ACTIVE, false);
    }
    if (el.hasState(STATUS_UNACTIVE)) {
      el.setState(STATUS_UNACTIVE, false);
    }
  });
}
exports.clearHighlight = clearHighlight;
function setHighlightBy(elements, callback, enable) {
  (0, util_1.each)(elements, function (el) {
    
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE)) {
        el.setState(STATUS_UNACTIVE, false);
      }
      el.setState(STATUS_ACTIVE, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE)) {
        el.setState(STATUS_ACTIVE, false);
      }
      el.setState(STATUS_UNACTIVE, enable);
    }
  });
}
exports.setHighlightBy = setHighlightBy;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var MaskBase = function (_super) {
  (0, tslib_1.__extends)(MaskBase, _super);
  function MaskBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    
    _this.maskShape = null;
    
    _this.points = [];
    
    _this.starting = false;
    
    _this.moving = false;
    _this.preMovePoint = null;
    _this.shapeType = 'path';
    return _this;
  }
  
  MaskBase.prototype.getCurrentPoint = function () {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  
  MaskBase.prototype.emitEvent = function (type) {
    var eventName = "mask:" + type;
    var view = this.context.view;
    var event = this.context.event;
    view.emit(eventName, {
      target: this.maskShape,
      shape: this.maskShape,
      points: this.points,
      x: event.x,
      y: event.y
    });
  };
  
  MaskBase.prototype.createMask = function () {
    var view = this.context.view;
    var maskAttrs = this.getMaskAttrs();
    var maskShape = view.foregroundGroup.addShape({
      type: this.shapeType,
      name: 'mask',
      draggable: true,
      attrs: (0, tslib_1.__assign)({
        fill: '#C5D4EB',
        opacity: 0.3
      }, maskAttrs)
    });
    return maskShape;
  };
  
  MaskBase.prototype.getMaskPath = function () {
    return [];
  };
    MaskBase.prototype.show = function () {
    if (this.maskShape) {
      this.maskShape.show();
      this.emitEvent('show');
    }
  };
    MaskBase.prototype.start = function (arg) {
    this.starting = true;
    
    this.moving = false;
    this.points = [this.getCurrentPoint()];
    if (!this.maskShape) {
      this.maskShape = this.createMask();
      
      this.maskShape.set('capture', false);
    }
    this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
    this.emitEvent('start');
  };
    MaskBase.prototype.moveStart = function () {
    this.moving = true;
    this.preMovePoint = this.getCurrentPoint();
  };
    MaskBase.prototype.move = function () {
    if (!this.moving || !this.maskShape) {
      return;
    }
    var currentPoint = this.getCurrentPoint();
    var preMovePoint = this.preMovePoint;
    var dx = currentPoint.x - preMovePoint.x;
    var dy = currentPoint.y - preMovePoint.y;
    var points = this.points;
    (0, util_1.each)(points, function (point) {
      point.x += dx;
      point.y += dy;
    });
    this.updateMask();
    this.emitEvent('change');
    this.preMovePoint = currentPoint;
  };
  MaskBase.prototype.updateMask = function (maskStyle) {
    var attrs = (0, util_1.deepMix)({}, this.getMaskAttrs(), maskStyle);
    this.maskShape.attr(attrs);
  };
    MaskBase.prototype.moveEnd = function () {
    this.moving = false;
    this.preMovePoint = null;
  };
    MaskBase.prototype.end = function () {
    this.starting = false;
    this.emitEvent('end');
    if (this.maskShape) {
      this.maskShape.set('capture', true);
    }
  };
    MaskBase.prototype.hide = function () {
    if (this.maskShape) {
      this.maskShape.hide();
      this.emitEvent('hide');
    }
  };
    MaskBase.prototype.resize = function () {
    
    if (this.starting && this.maskShape) {
      this.points.push(this.getCurrentPoint());
      this.updateMask();
      this.emitEvent('change');
    }
  };
    MaskBase.prototype.destroy = function () {
    this.points = [];
    if (this.maskShape) {
      this.maskShape.remove();
    }
    this.maskShape = null;
    this.preMovePoint = null;
    _super.prototype.destroy.call(this);
  };
  return MaskBase;
}(base_1.default);
exports.default = MaskBase;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateBoxSizes = exports.calculateBoxSize = void 0;
var _ResizeObserverBoxOptions = __webpack_require__(484);
var _ResizeObserverSize = __webpack_require__(485);
var _DOMRectReadOnly = __webpack_require__(1047);
var _element = __webpack_require__(192);
var _freeze = __webpack_require__(191);
var _global = __webpack_require__(486);
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(_global.global.navigator && _global.global.navigator.userAgent);
var parseDimension = function parseDimension(pixel) {
  return parseFloat(pixel || '0');
};
var size = function size(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new _ResizeObserverSize.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = (0, _freeze.freeze)({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new _DOMRectReadOnly.DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function calculateBoxSizes(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if ((0, _element.isHidden)(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = (0, _element.isSVG)(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '');
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = (0, _freeze.freeze)({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new _DOMRectReadOnly.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
exports.calculateBoxSizes = calculateBoxSizes;
var calculateBoxSize = function calculateBoxSize(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation),
    borderBoxSize = _a.borderBoxSize,
    contentBoxSize = _a.contentBoxSize,
    devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case _ResizeObserverBoxOptions.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case _ResizeObserverBoxOptions.ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
exports.calculateBoxSize = calculateBoxSize;

/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Label; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var _antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(163);
/* harmony import */ var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(164);
/* harmony import */ var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(214);
/* harmony import */ var _antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(333);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(334);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(335);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(225);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_10__);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

// 注册 Geometry 内置的 label




// 注册 Geometry label 内置的布局函数






Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('base', _antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('interval', _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('pie', _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('polar', _antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('overlap', _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__["overlap"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('distribute', _antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5__["distribute"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('fixed-overlap', _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__["fixedOverlap"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('limit-in-shape', _antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7__["limitInShape"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('limit-in-canvas', _antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6__["limitInCanvas"]);
function Label(props) {
  var parentInstance = props.parentInstance,
    content = props.content,
    cfg = __rest(props, ["parentInstance", "content"]);
  warning__WEBPACK_IMPORTED_MODULE_10___default()(false, 'Label组件即将被取消，请使用图形组件的label属性进行配置');
  parentInstance.label(false);
  parentInstance.label(content, cfg);
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBetween = exports.isRealNumber = void 0;
function isRealNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}
exports.isRealNumber = isRealNumber;
function isBetween(value, start, end) {
  var min = Math.min(start, end);
  var max = Math.max(start, end);
  return value >= min && value <= max;
}
exports.isBetween = isBetween;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processIllegalData = exports.transformDataToNodeLinkData = exports.adjustYMetaByZero = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var invariant_1 = __webpack_require__(500);
var pick_1 = __webpack_require__(499);
function adjustYMetaByZero(data, field) {
  
  var numberData = data.filter(function (datum) {
    var v = util_1.get(datum, [field]);
    return util_1.isNumber(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function (datum) {
    return util_1.get(datum, [field]) >= 0;
  });
  var ltZero = numberData.every(function (datum) {
    return util_1.get(datum, [field]) <= 0;
  });
  
  if (gtZero) {
    return {
      min: 0
    };
  }
  if (ltZero) {
    return {
      max: 0
    };
  }
  return {};
}
exports.adjustYMetaByZero = adjustYMetaByZero;
function transformDataToNodeLinkData(data, sourceField, targetField, weightField, rawFields) {
  if (rawFields === void 0) {
    rawFields = [];
  }
  if (!Array.isArray(data)) {
    return {
      nodes: [],
      links: []
    };
  }
  
  var links = [];
  
  var nodesMap = {};
  var nodesIndex = -1;
  
  data.forEach(function (datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField];
    var rawData = pick_1.pick(datum, rawFields);
    
    if (!nodesMap[source]) {
      nodesMap[source] = tslib_1.__assign({
        id: ++nodesIndex,
        name: source
      }, rawData);
    }
    if (!nodesMap[target]) {
      nodesMap[target] = tslib_1.__assign({
        id: ++nodesIndex,
        name: target
      }, rawData);
    }
    
    links.push(tslib_1.__assign({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      
      
      value: weight
    }, rawData));
  });
  return {
    
    nodes: Object.values(nodesMap).sort(function (a, b) {
      return a.id - b.id;
    }),
    links: links
  };
}
exports.transformDataToNodeLinkData = transformDataToNodeLinkData;
function processIllegalData(data, field) {
  var processData = util_1.filter(data, function (d) {
    var v = d[field];
    return v === null || typeof v === 'number' && !isNaN(v);
  });
  
  invariant_1.log(invariant_1.LEVEL.WARN, processData.length === data.length, 'illegal data existed in chart data.');
  return processData;
}
exports.processIllegalData = processIllegalData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveAllPadding = exports.getAdjustAppendPadding = exports.normalPadding = void 0;
var util_1 = __webpack_require__(0);
function normalPadding(padding) {
  if (util_1.isNumber(padding)) {
    return [padding, padding, padding, padding];
  }
  if (util_1.isArray(padding)) {
    var length_1 = padding.length;
    if (length_1 === 1) {
      return [padding[0], padding[0], padding[0], padding[0]];
    }
    if (length_1 === 2) {
      return [padding[0], padding[1], padding[0], padding[1]];
    }
    if (length_1 === 3) {
      return [padding[0], padding[1], padding[2], padding[1]];
    }
    if (length_1 === 4) {
      return padding;
    }
  }
  return [0, 0, 0, 0];
}
exports.normalPadding = normalPadding;
function getAdjustAppendPadding(padding, position, append) {
  if (position === void 0) {
    position = 'bottom';
  }
  if (append === void 0) {
    append = 25;
  }
  var currentAppendPadding = normalPadding(padding);
  var PADDING = [position.startsWith('top') ? append : 0, position.startsWith('right') ? append : 0, position.startsWith('bottom') ? append : 0, position.startsWith('left') ? append : 0];
  return [currentAppendPadding[0] + PADDING[0], currentAppendPadding[1] + PADDING[1], currentAppendPadding[2] + PADDING[2], currentAppendPadding[3] + PADDING[3]];
}
exports.getAdjustAppendPadding = getAdjustAppendPadding;
function resolveAllPadding(paddings) {
  
  var normalPaddings = paddings.map(function (item) {
    return normalPadding(item);
  });
  var finalPadding = [0, 0, 0, 0];
  if (normalPaddings.length > 0) {
    finalPadding = finalPadding.map(function (item, index) {
      
      normalPaddings.forEach(function (d, i) {
        item += normalPaddings[i][index];
      });
      return item;
    });
  }
  return finalPadding;
}
exports.resolveAllPadding = resolveAllPadding;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformMatrix = exports.getSymbolsPosition = exports.getUnitPatternSize = exports.drawBackground = exports.initCanvas = exports.getPixelRatio = void 0;
function getPixelRatio() {
  return (typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) === 'object' ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
exports.getPixelRatio = getPixelRatio;
function initCanvas(width, height) {
  if (height === void 0) {
    height = width;
  }
  var canvas = document.createElement('canvas');
  var pixelRatio = getPixelRatio();
  
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  var ctx = canvas.getContext('2d');
  ctx.scale(pixelRatio, pixelRatio);
  return canvas;
}
exports.initCanvas = initCanvas;
function drawBackground(context, cfg, width, height) {
  if (height === void 0) {
    height = width;
  }
  var backgroundColor = cfg.backgroundColor,
    opacity = cfg.opacity;
  context.globalAlpha = opacity;
  context.fillStyle = backgroundColor;
  context.beginPath();
  context.fillRect(0, 0, width, height);
  context.closePath();
}
exports.drawBackground = drawBackground;
function getUnitPatternSize(size, padding, isStagger) {
  
  var unitSize = size + padding;
  return isStagger ? unitSize * 2 : unitSize;
}
exports.getUnitPatternSize = getUnitPatternSize;
function getSymbolsPosition(unitSize, isStagger) {
  
  var symbolsPos = isStagger ? [[unitSize * (1 / 4), unitSize * (1 / 4)], [unitSize * (3 / 4), unitSize * (3 / 4)]] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
  return symbolsPos;
}
exports.getSymbolsPosition = getSymbolsPosition;
function transformMatrix(dpr, rotation) {
  var radian = rotation * Math.PI / 180;
  var matrix = {
    a: Math.cos(radian) * (1 / dpr),
    b: Math.sin(radian) * (1 / dpr),
    c: -Math.sin(radian) * (1 / dpr),
    d: Math.cos(radian) * (1 / dpr),
    e: 0,
    f: 0
  };
  return matrix;
}
exports.transformMatrix = transformMatrix;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProgressData = void 0;
var util_1 = __webpack_require__(0);
var number_1 = __webpack_require__(291);
function getProgressData(percent) {
  var clampPercent = util_1.clamp(number_1.isRealNumber(percent) ? percent : 0, 0, 1);
  return [{
    type: 'current',
    percent: clampPercent
  }, {
    type: 'target',
    percent: 1 - clampPercent
  }];
}
exports.getProgressData = getProgressData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.meta = void 0;
var common_1 = __webpack_require__(34);
var utils_1 = __webpack_require__(15);
var geometries_1 = __webpack_require__(43);
var constants_1 = __webpack_require__(154);
var utils_2 = __webpack_require__(118);
var data_1 = __webpack_require__(292);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    color = options.color,
    areaStyle = options.areaStyle,
    pointOptions = options.point,
    lineOptions = options.line;
  var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
  var seriesData = utils_2.getTinyData(data);
  chart.data(seriesData);
  var primary = utils_1.deepAssign({}, params, {
    options: {
      xField: constants_1.X_FIELD,
      yField: constants_1.Y_FIELD,
      area: {
        color: color,
        style: areaStyle
      },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  var pointParams = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  
  geometries_1.area(primary);
  geometries_1.line(second);
  geometries_1.point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function meta(params) {
  var _a, _b;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    data = options.data;
  var seriesData = utils_2.getTinyData(data);
  return utils_1.flow(common_1.scale((_a = {}, _a[constants_1.X_FIELD] = xAxis, _a[constants_1.Y_FIELD] = yAxis, _a), (_b = {}, _b[constants_1.X_FIELD] = {
    type: 'cat'
  }, _b[constants_1.Y_FIELD] = data_1.adjustYMetaByZero(seriesData, constants_1.Y_FIELD), _b)))(params);
}
exports.meta = meta;
function adaptor(params) {
  return utils_1.flow(common_1.pattern('areaStyle'), geometry, meta, common_1.tooltip, common_1.theme, common_1.animation, common_1.annotation())(params);
}
exports.adaptor = adaptor;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Node = Node;
exports.computeHeight = computeHeight;
exports.default = hierarchy;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(229));
var _count = _interopRequireDefault(__webpack_require__(1093));
var _each = _interopRequireDefault(__webpack_require__(1094));
var _eachBefore = _interopRequireDefault(__webpack_require__(1095));
var _eachAfter = _interopRequireDefault(__webpack_require__(1096));
var _find = _interopRequireDefault(__webpack_require__(1097));
var _sum = _interopRequireDefault(__webpack_require__(1098));
var _sort = _interopRequireDefault(__webpack_require__(1099));
var _path = _interopRequireDefault(__webpack_require__(1100));
var _ancestors = _interopRequireDefault(__webpack_require__(1101));
var _descendants = _interopRequireDefault(__webpack_require__(1102));
var _leaves = _interopRequireDefault(__webpack_require__(1103));
var _links = _interopRequireDefault(__webpack_require__(1104));
var _iterator = _interopRequireDefault(__webpack_require__(1105));
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }
  var root = new Node(data),
    node,
    nodes = [root],
    child,
    childs,
    i,
    n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do {
    node.height = height;
  } while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = (0, _defineProperty2.default)({
  constructor: Node,
  count: _count.default,
  each: _each.default,
  eachAfter: _eachAfter.default,
  eachBefore: _eachBefore.default,
  find: _find.default,
  sum: _sum.default,
  sort: _sort.default,
  path: _path.default,
  ancestors: _ancestors.default,
  descendants: _descendants.default,
  leaves: _leaves.default,
  links: _links.default,
  copy: node_copy
}, Symbol.iterator, _iterator.default);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optional = optional;
exports.required = required;
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phi = exports.default = void 0;
exports.squarifyRatio = squarifyRatio;
var _dice = _interopRequireDefault(__webpack_require__(155));
var _slice = _interopRequireDefault(__webpack_require__(194));
var phi = (1 + Math.sqrt(5)) / 2;
exports.phi = phi;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
    nodes = parent.children,
    row,
    nodeValue,
    i0 = 0,
    i1 = 0,
    n = nodes.length,
    dx,
    dy,
    value = parent.value,
    sumValue,
    minValue,
    maxValue,
    newRatio,
    minRatio,
    alpha,
    beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    
    do {
      sumValue = nodes[i1++].value;
    } while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }

    
    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) (0, _dice.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else (0, _slice.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var _default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };
  return squarify;
}(phi);
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagComponent = exports.transformData = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(120);
function transformData(data, originData, options) {
  var formatData = [];
  var yField = options.yField,
    maxSize = options.maxSize,
    minSize = options.minSize;
  var maxYFieldValue = util_1.get(util_1.maxBy(originData, yField), [yField]);
  var max = util_1.isNumber(maxSize) ? maxSize : 1;
  var min = util_1.isNumber(minSize) ? minSize : 0;
  
  formatData = util_1.map(data, function (row, index) {
    var percent = (row[yField] || 0) / maxYFieldValue;
    row[constant_1.FUNNEL_PERCENT] = percent;
    row[constant_1.FUNNEL_MAPPING_VALUE] = (max - min) * percent + min;
    
    row[constant_1.FUNNEL_CONVERSATION] = [util_1.get(data, [index - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
exports.transformData = transformData;
function conversionTagComponent(getLineCoordinate) {
  return function (params) {
    var chart = params.chart,
      options = params.options;
    var conversionTag = options.conversionTag;
    var data = chart.getOptions().data;
    if (conversionTag) {
      var formatter_1 = conversionTag.formatter;
      data.forEach(function (obj, index) {
        if (index <= 0 || Number.isNaN(obj[constant_1.FUNNEL_MAPPING_VALUE])) return;
        var lineOption = getLineCoordinate(obj, index, data, {
          top: true,
          text: {
            content: util_1.isFunction(formatter_1) ? formatter_1(obj, data) : formatter_1,
            offsetX: conversionTag.offsetX,
            offsetY: conversionTag.offsetY,
            position: 'end',
            autoRotate: false,
            style: tslib_1.__assign({
              textAlign: 'start',
              textBaseline: 'middle'
            }, conversionTag.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }
    return params;
  };
}
exports.conversionTagComponent = conversionTagComponent;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.IS_TOTAL = exports.ABSOLUTE_FIELD = exports.DIFF_FIELD = exports.Y_FIELD = void 0;
exports.Y_FIELD = '$$yField$$';
exports.DIFF_FIELD = '$$diffField$$';
exports.ABSOLUTE_FIELD = '$$absoluteField$$';
exports.IS_TOTAL = '$$isTotal$$';
exports.DEFAULT_OPTIONS = {
    label: {},
    leaderLine: {
    style: {
      lineWidth: 1,
      stroke: '#8c8c8c',
      lineDash: [4, 2]
    }
  },
    total: {
    style: {
      fill: 'rgba(0, 0, 0, 0.25)'
    }
  },
  interactions: [{
    type: 'element-active'
  }],
  risingFill: '#f4664a',
  fallingFill: '#30bf78',
  waterfallStyle: {
    fill: 'rgba(0, 0, 0, 0.25)'
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineDash: [4, 2]
        }
      }
    }
  }
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBetween = isBetween;
exports.isRealNumber = isRealNumber;
function isRealNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}
function isBetween(value, start, end) {
  var min = Math.min(start, end);
  var max = Math.max(start, end);
  return value >= min && value <= max;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.adjust = adjust;
exports.axis = axis;
exports.legend = legend;
exports.meta = meta;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _common = __webpack_require__(22);
var _utils = __webpack_require__(7);
var _geometries = __webpack_require__(30);
var _data = __webpack_require__(197);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    color = options.color,
    lineStyle = options.lineStyle,
    lineShape = options.lineShape,
    pointMapping = options.point,
    areaMapping = options.area,
    seriesField = options.seriesField;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  chart.data(data);
  
  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color,
        style: lineStyle,
        shape: lineShape
      },
      
      
      point: pointMapping && (0, _tslib.__assign)({
        color: color,
        shape: 'circle'
      }, pointMapping),
      
      area: areaMapping && (0, _tslib.__assign)({
        color: color
      }, areaMapping),
      
      label: undefined
    }
  });
  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  var areaParams = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  (0, _geometries.line)(primary);
  (0, _geometries.point)(second);
  (0, _geometries.area)(areaParams);
  return params;
}
function meta(params) {
  var _a, _b;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField,
    data = options.data;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = (0, _data.adjustYMetaByZero)(data, yField), _b)))(params);
}
function coordinate(params) {
  var chart = params.chart,
    options = params.options;
  var reflect = options.reflect;
  if (reflect) {
    var p = reflect;
    if (!(0, _util.isArray)(p)) {
      p = [p];
    }
    var actions = p.map(function (d) {
      return ['reflect', d];
    });
    chart.coordinate({
      type: 'rect',
      actions: actions
    });
  }
  return params;
}
function axis(params) {
  var chart = params.chart,
    options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField;
  
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    seriesField = options.seriesField;
  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }
  return params;
}
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    yField = options.yField;
  var lineGeometry = (0, _utils.findGeometry)(chart, 'line');
  
  if (!label) {
    lineGeometry.label(false);
  } else {
    var callback = label.callback,
      cfg = (0, _tslib.__rest)(label, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _tslib.__assign)({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, (0, _utils.transformLabel)(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart,
    options = params.options;
  var isStack = options.isStack;
  if (isStack) {
    (0, _util.each)(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }
  return params;
}
function adaptor(params) {
  
  return (0, _utils.flow)(geometry, meta, adjust, _common.theme, coordinate, axis, legend, _common.tooltip, label, _common.slider, _common.interaction, _common.animation, (0, _common.annotation)(), _common.limitInPlot)(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawBackground = drawBackground;
exports.getPixelRatio = getPixelRatio;
exports.getSymbolsPosition = getSymbolsPosition;
exports.getUnitPatternSize = getUnitPatternSize;
exports.initCanvas = initCanvas;
exports.transformMatrix = transformMatrix;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
function getPixelRatio() {
  return (typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) === 'object' ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
function initCanvas(width, height) {
  if (height === void 0) {
    height = width;
  }
  var canvas = document.createElement('canvas');
  var pixelRatio = getPixelRatio();
  
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  var ctx = canvas.getContext('2d');
  ctx.scale(pixelRatio, pixelRatio);
  return canvas;
}
function drawBackground(context, cfg, width, height) {
  if (height === void 0) {
    height = width;
  }
  var backgroundColor = cfg.backgroundColor,
    opacity = cfg.opacity;
  context.globalAlpha = opacity;
  context.fillStyle = backgroundColor;
  context.beginPath();
  context.fillRect(0, 0, width, height);
  context.closePath();
}
function getUnitPatternSize(size, padding, isStagger) {
  
  var unitSize = size + padding;
  return isStagger ? unitSize * 2 : unitSize;
}
function getSymbolsPosition(unitSize, isStagger) {
  
  var symbolsPos = isStagger ? [[unitSize * (1 / 4), unitSize * (1 / 4)], [unitSize * (3 / 4), unitSize * (3 / 4)]] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
  return symbolsPos;
}
function transformMatrix(dpr, rotation) {
  var radian = rotation * Math.PI / 180;
  var matrix = {
    a: Math.cos(radian) * (1 / dpr),
    b: Math.sin(radian) * (1 / dpr),
    c: -Math.sin(radian) * (1 / dpr),
    d: Math.cos(radian) * (1 / dpr),
    e: 0,
    f: 0
  };
  return matrix;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeometryOption = getGeometryOption;
exports.getYAxisWithDefault = getYAxisWithDefault;
exports.isColumn = isColumn;
exports.isLine = isLine;
exports.transformObjectToArray = transformObjectToArray;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
var _types = __webpack_require__(567);
var _constant = __webpack_require__(568);
function isLine(geometryOption) {
  return (0, _util.get)(geometryOption, 'geometry') === _types.DualAxesGeometry.Line;
}
function isColumn(geometryOption) {
  return (0, _util.get)(geometryOption, 'geometry') === _types.DualAxesGeometry.Column;
}
function getGeometryOption(xField, yField, geometryOption) {
  
  return isColumn(geometryOption) ? (0, _utils.deepAssign)({}, {
    geometry: _types.DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function content(item) {
        var _a;
        return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
      }
    } : undefined
  }, geometryOption) : (0, _tslib.__assign)({
    geometry: _types.DualAxesGeometry.Line
  }, geometryOption);
}
function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0],
    y2 = yField[1];
  if ((0, _util.isArray)(transformAttribute)) {
    
    var a1_1 = transformAttribute[0],
      a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }
  var a1 = (0, _util.get)(transformAttribute, y1);
  var a2 = (0, _util.get)(transformAttribute, y2);
  return [a1, a2];
}
function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === _types.AxisType.Left) {
    return yAxis === false ? false : (0, _utils.deepAssign)({}, _constant.DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === _types.AxisType.Right) {
    return yAxis === false ? false : (0, _utils.deepAssign)({}, _constant.DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }
  return yAxis;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.geometry = geometry;
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
var _common = __webpack_require__(22);
var _geometries = __webpack_require__(30);
var _constants = __webpack_require__(579);
var _utils2 = __webpack_require__(307);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var percent = options.percent,
    progressStyle = options.progressStyle,
    color = options.color,
    barWidthRatio = options.barWidthRatio;
  chart.data((0, _utils2.getProgressData)(percent));
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: '1',
      yField: 'percent',
      seriesField: 'type',
      isStack: true,
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: (0, _util.isString)(color) ? [color, _constants.DEFAULT_COLOR[1]] : color
      },
      args: {
        zIndexReversed: true
      }
    }
  });
  (0, _geometries.interval)(p);
  
  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function coordinate(params) {
  var chart = params.chart;
  chart.coordinate('rect').transpose();
  return params;
}
function adaptor(params) {
  
  return (0, _utils.flow)(geometry, (0, _common.scale)({}), coordinate, _common.animation, _common.theme, (0, _common.annotation)())(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProgressData = getProgressData;
var _util = __webpack_require__(0);
var _number = __webpack_require__(302);
function getProgressData(percent) {
  var clampPercent = (0, _util.clamp)((0, _number.isRealNumber)(percent) ? percent : 0, 0, 1);
  return [{
    type: 'current',
    percent: clampPercent
  }, {
    type: 'target',
    percent: 1 - clampPercent
  }];
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OUTLIERS_VIEW_ID = exports.DEFAULT_OPTIONS = exports.BOX_SYNC_NAME = exports.BOX_RANGE_ALIAS = exports.BOX_RANGE = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var _a;
var BOX_RANGE = '$$range$$';
exports.BOX_RANGE = BOX_RANGE;
var BOX_RANGE_ALIAS = 'low-q1-median-q3-high';
exports.BOX_RANGE_ALIAS = BOX_RANGE_ALIAS;
var BOX_SYNC_NAME = '$$y_outliers$$';
exports.BOX_SYNC_NAME = BOX_SYNC_NAME;
var OUTLIERS_VIEW_ID = 'outliers_view';
exports.OUTLIERS_VIEW_ID = OUTLIERS_VIEW_ID;
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  meta: (_a = {}, _a[BOX_RANGE] = {
    min: 0,
    alias: BOX_RANGE_ALIAS
  }, _a),
  
  interactions: [{
    type: 'active-region'
  }],
  
  tooltip: {
    showMarkers: false,
    shared: true
  },
  boxStyle: {
    lineWidth: 1
  }
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.placeElementsOrdered = placeElementsOrdered;
function placeElementsOrdered(view) {
  if (!view) {
    return;
  }
  var elements = view.geometries[0].elements;
  elements.forEach(function (elem) {
    elem.shape.toFront();
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Y_FIELD = exports.TREND_UP = exports.TREND_FIELD = exports.TREND_DOWN = exports.DEFAULT_TOOLTIP_OPTIONS = exports.DEFAULT_OPTIONS = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var Y_FIELD = '$$stock-range$$';
exports.Y_FIELD = Y_FIELD;
var TREND_FIELD = 'trend';
exports.TREND_FIELD = TREND_FIELD;
var TREND_UP = 'up';
exports.TREND_UP = TREND_UP;
var TREND_DOWN = 'down';
exports.TREND_DOWN = TREND_DOWN;
var DEFAULT_TOOLTIP_OPTIONS = {
  showMarkers: false,
  showCrosshairs: true,
  shared: true,
  crosshairs: {
    type: 'xy',
    follow: true,
    text: function text(type, defaultContent, items) {
      var textContent;
      if (type === 'x') {
        var item = items[0];
        textContent = item ? item.title : defaultContent;
      } else {
        textContent = defaultContent;
      }
      return {
        position: type === 'y' ? 'start' : 'end',
        content: textContent,
        style: {
          fill: '#dfdfdf'
        }
      };
    },
    
    textBackground: {
      padding: [2, 4],
      style: {
        fill: '#666'
      }
    }
  }
};
exports.DEFAULT_TOOLTIP_OPTIONS = DEFAULT_TOOLTIP_OPTIONS;
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  
  tooltip: DEFAULT_TOOLTIP_OPTIONS,
  interactions: [{
    type: 'tooltip'
  }],
  legend: {
    position: 'top-left'
  },
  risingFill: '#ef5350',
  fallingFill: '#26a69a'
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagComponent = conversionTagComponent;
exports.transformData = transformData;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _constant = __webpack_require__(125);
function transformData(data, originData, options) {
  var formatData = [];
  var yField = options.yField,
    maxSize = options.maxSize,
    minSize = options.minSize;
  var maxYFieldValue = (0, _util.get)((0, _util.maxBy)(originData, yField), [yField]);
  var max = (0, _util.isNumber)(maxSize) ? maxSize : 1;
  var min = (0, _util.isNumber)(minSize) ? minSize : 0;
  
  formatData = (0, _util.map)(data, function (row, index) {
    var percent = (row[yField] || 0) / maxYFieldValue;
    row[_constant.FUNNEL_PERCENT] = percent;
    row[_constant.FUNNEL_MAPPING_VALUE] = (max - min) * percent + min;
    
    row[_constant.FUNNEL_CONVERSATION] = [(0, _util.get)(data, [index - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
function conversionTagComponent(getLineCoordinate) {
  return function (params) {
    var chart = params.chart,
      options = params.options;
    var conversionTag = options.conversionTag;
    var data = chart.getOptions().data;
    if (conversionTag) {
      var formatter_1 = conversionTag.formatter;
      data.forEach(function (obj, index) {
        if (index <= 0 || Number.isNaN(obj[_constant.FUNNEL_MAPPING_VALUE])) return;
        var lineOption = getLineCoordinate(obj, index, data, {
          top: true,
          text: {
            content: (0, _util.isFunction)(formatter_1) ? formatter_1(obj, data) : formatter_1,
            offsetX: conversionTag.offsetX,
            offsetY: conversionTag.offsetY,
            position: 'end',
            autoRotate: false,
            style: (0, _tslib.__assign)({
              textAlign: 'start',
              textBaseline: 'middle'
            }, conversionTag.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }
    return params;
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SUNBURST_Y_FIELD = exports.SUNBURST_PATH_FIELD = exports.SUNBURST_ANCESTOR_FIELD = exports.RAW_FIELDS = exports.DEFAULT_OPTIONS = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var _util = __webpack_require__(157);
var SUNBURST_ANCESTOR_FIELD = 'ancestor-node';
exports.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
var SUNBURST_Y_FIELD = 'value';
exports.SUNBURST_Y_FIELD = SUNBURST_Y_FIELD;
var SUNBURST_PATH_FIELD = 'path';
exports.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
var RAW_FIELDS = [SUNBURST_PATH_FIELD, _util.NODE_INDEX_FIELD, _util.NODE_ANCESTORS_FIELD, _util.CHILD_NODE_COUNT, 'name', 'depth', 'height'];
exports.RAW_FIELDS = RAW_FIELDS;
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  innerRadius: 0,
  radius: 0.85,
  
  hierarchyConfig: {
    
    field: 'value'
  },
  
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20,
    showTitle: false
  },
  
  sunburstStyle: {
    lineWidth: 0.5,
    stroke: '#FFF'
  },
  
  drilldown: {
    enabled: true
  }
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isParentNode = isParentNode;
var _g = __webpack_require__(14);
var _util = __webpack_require__(0);
var _drillDown = __webpack_require__(201);
function isParentNode(context) {
  var data = (0, _util.get)(context, ['event', 'data', 'data'], {});
  return (0, _util.isArray)(data.children) && data.children.length > 0;
}
function inCenter(context) {
  var coordinate = context.view.getCoordinate();
  var innerRadius = coordinate.innerRadius;
  if (innerRadius) {
    var _a = context.event,
      x = _a.x,
      y = _a.y;
    var _b = coordinate.center,
      centerX = _b.x,
      centerY = _b.y;
    var r = coordinate.getRadius() * innerRadius;
    var distance = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
    return distance < r;
  }
  return false;
}
(0, _g.registerAction)('drill-down-action', _drillDown.DrillDownAction);
(0, _g.registerInteraction)('drill-down', {
  showEnable: [{
    trigger: 'element:mouseenter',
    action: 'cursor:pointer',
    isEnable: isParentNode
  }, {
    trigger: 'element:mouseleave',
    action: 'cursor:default'
  },
  
  {
    trigger: 'element:mouseleave',
    action: 'cursor:pointer',
    isEnable: inCenter
  }],
  start: [{
    trigger: 'element:click',
    isEnable: isParentNode,
    action: ['drill-down-action:click']
  }, {
    trigger: 'afterchangesize',
    action: ['drill-down-action:resetPosition']
  }, {
    
    trigger: 'click',
    isEnable: inCenter,
    action: ['drill-down-action:back']
  }]
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANGE_VIEW_ID = exports.RANGE_VALUE = exports.RANGE_TYPE = exports.PERCENT = exports.INDICATEOR_VIEW_ID = exports.DEFAULT_OPTIONS = exports.DEFAULT_COLOR = void 0;
var _a;
var RANGE_VALUE = 'range';
exports.RANGE_VALUE = RANGE_VALUE;
var RANGE_TYPE = 'type';
exports.RANGE_TYPE = RANGE_TYPE;
var PERCENT = 'percent';
exports.PERCENT = PERCENT;
var DEFAULT_COLOR = '#f0f0f0';
exports.DEFAULT_COLOR = DEFAULT_COLOR;
var INDICATEOR_VIEW_ID = 'indicator-view';
exports.INDICATEOR_VIEW_ID = INDICATEOR_VIEW_ID;
var RANGE_VIEW_ID = 'range-view';
exports.RANGE_VIEW_ID = RANGE_VIEW_ID;
var DEFAULT_OPTIONS = {
  percent: 0,
  range: {
    ticks: []
  },
  innerRadius: 0.9,
  radius: 0.95,
  startAngle: -7 / 6 * Math.PI,
  endAngle: 1 / 6 * Math.PI,
  syncViewPadding: true,
  axis: {
    line: null,
    label: {
      offset: -24,
      style: {
        textAlign: 'center',
        textBaseline: 'middle'
      }
    },
    subTickLine: {
      length: -8
    },
    tickLine: {
      length: -12
    },
    grid: null
  },
  indicator: {
    pointer: {
      style: {
        lineWidth: 5,
        lineCap: 'round'
      }
    },
    pin: {
      style: {
        r: 9.75,
        lineWidth: 4.5,
        fill: '#fff'
      }
    }
  },
  statistic: {
    title: false
  },
  meta: (_a = {},
  
  _a[RANGE_VALUE] = {
    sync: 'v'
  }, _a[PERCENT] = {
    sync: 'v',
    tickCount: 5,
    tickInterval: 0.2
  }, _a),
  animation: false
};
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Y_FIELD = exports.IS_TOTAL = exports.DIFF_FIELD = exports.DEFAULT_OPTIONS = exports.ABSOLUTE_FIELD = void 0;
var Y_FIELD = '$$yField$$';
exports.Y_FIELD = Y_FIELD;
var DIFF_FIELD = '$$diffField$$';
exports.DIFF_FIELD = DIFF_FIELD;
var ABSOLUTE_FIELD = '$$absoluteField$$';
exports.ABSOLUTE_FIELD = ABSOLUTE_FIELD;
var IS_TOTAL = '$$isTotal$$';
exports.IS_TOTAL = IS_TOTAL;
var DEFAULT_OPTIONS = {
    label: {},
    leaderLine: {
    style: {
      lineWidth: 1,
      stroke: '#8c8c8c',
      lineDash: [4, 2]
    }
  },
    total: {
    style: {
      fill: 'rgba(0, 0, 0, 0.25)'
    }
  },
  interactions: [{
    type: 'element-active'
  }],
  risingFill: '#f4664a',
  fallingFill: '#30bf78',
  waterfallStyle: {
    fill: 'rgba(0, 0, 0, 0.25)'
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineDash: [4, 2]
        }
      }
    }
  }
};
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Y_FIELD = exports.X_FIELD = exports.NODES_VIEW_ID = exports.EDGES_VIEW_ID = exports.COLOR_FIELD = void 0;
var X_FIELD = 'x';
exports.X_FIELD = X_FIELD;
var Y_FIELD = 'y';
exports.Y_FIELD = Y_FIELD;
var COLOR_FIELD = 'name';
exports.COLOR_FIELD = COLOR_FIELD;
var NODES_VIEW_ID = 'nodes';
exports.NODES_VIEW_ID = NODES_VIEW_ID;
var EDGES_VIEW_ID = 'edges';
exports.EDGES_VIEW_ID = EDGES_VIEW_ID;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _a;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.RANGE_VIEW_ID = exports.INDICATEOR_VIEW_ID = exports.DEFAULT_COLOR = exports.PERCENT = exports.RANGE_TYPE = exports.RANGE_VALUE = void 0;
exports.RANGE_VALUE = 'range';
exports.RANGE_TYPE = 'type';
exports.PERCENT = 'percent';
exports.DEFAULT_COLOR = '#f0f0f0';
exports.INDICATEOR_VIEW_ID = 'indicator-view';
exports.RANGE_VIEW_ID = 'range-view';
exports.DEFAULT_OPTIONS = {
  percent: 0,
  range: {
    ticks: []
  },
  innerRadius: 0.9,
  radius: 0.95,
  startAngle: -7 / 6 * Math.PI,
  endAngle: 1 / 6 * Math.PI,
  syncViewPadding: true,
  axis: {
    line: null,
    label: {
      offset: -24,
      style: {
        textAlign: 'center',
        textBaseline: 'middle'
      }
    },
    subTickLine: {
      length: -8
    },
    tickLine: {
      length: -12
    },
    grid: null
  },
  indicator: {
    pointer: {
      style: {
        lineWidth: 5,
        lineCap: 'round'
      }
    },
    pin: {
      style: {
        r: 9.75,
        lineWidth: 4.5,
        fill: '#fff'
      }
    }
  },
  statistic: {
    title: false
  },
  meta: (_a = {},
  
  _a[exports.RANGE_VALUE] = {
    sync: 'v'
  }, _a[exports.PERCENT] = {
    sync: 'v',
    tickCount: 5,
    tickInterval: 0.2
  }, _a),
  animation: false
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getYAxisWithDefault = exports.transformObjectToArray = exports.getGeometryOption = exports.isColumn = exports.isLine = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
var types_1 = __webpack_require__(608);
var constant_1 = __webpack_require__(609);
function isLine(geometryOption) {
  return util_1.get(geometryOption, 'geometry') === types_1.DualAxesGeometry.Line;
}
exports.isLine = isLine;
function isColumn(geometryOption) {
  return util_1.get(geometryOption, 'geometry') === types_1.DualAxesGeometry.Column;
}
exports.isColumn = isColumn;
function getGeometryOption(xField, yField, geometryOption) {
  
  return isColumn(geometryOption) ? utils_1.deepAssign({}, {
    geometry: types_1.DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function content(item) {
        var _a;
        return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
      }
    } : undefined
  }, geometryOption) : tslib_1.__assign({
    geometry: types_1.DualAxesGeometry.Line
  }, geometryOption);
}
exports.getGeometryOption = getGeometryOption;
function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0],
    y2 = yField[1];
  if (util_1.isArray(transformAttribute)) {
    
    var a1_1 = transformAttribute[0],
      a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }
  var a1 = util_1.get(transformAttribute, y1);
  var a2 = util_1.get(transformAttribute, y2);
  return [a1, a2];
}
exports.transformObjectToArray = transformObjectToArray;
function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === types_1.AxisType.Left) {
    return yAxis === false ? false : utils_1.deepAssign({}, constant_1.DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === types_1.AxisType.Right) {
    return yAxis === false ? false : utils_1.deepAssign({}, constant_1.DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }
  return yAxis;
}
exports.getYAxisWithDefault = getYAxisWithDefault;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var dependents_1 = __webpack_require__(69);
var animate_1 = __webpack_require__(97);
var constant_1 = __webpack_require__(21);
var coordinate_1 = __webpack_require__(48);
var helper_1 = __webpack_require__(70);
var annotation_1 = __webpack_require__(898);
var base_1 = __webpack_require__(104);
var ANNOTATIONS_AFTER_RENDER = ['regionFilter', 'shape'];
var Annotation = function (_super) {
  (0, tslib_1.__extends)(Annotation, _super);
  function Annotation(view) {
    var _this = _super.call(this, view) || this;
        _this.cache = new Map();
    _this.foregroundContainer = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    _this.backgroundContainer = _this.view.getLayer(constant_1.LAYER.BG).addGroup();
    _this.option = [];
    return _this;
  }
  Object.defineProperty(Annotation.prototype, "name", {
    get: function get() {
      return 'annotation';
    },
    enumerable: false,
    configurable: true
  });
  Annotation.prototype.init = function () {};
    Annotation.prototype.layout = function () {
    this.update();
  };
  
  Annotation.prototype.render = function () {};
    Annotation.prototype.update = function () {
    var _this = this;
    
    this.onAfterRender(function () {
      var updated = new Map();
      
      (0, util_1.each)(_this.option, function (option) {
        if ((0, util_1.includes)(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          
          if (co) {
            updated.set(_this.getCacheKey(option), co);
          }
        }
      });
      
      
      _this.cache = _this.syncCache(updated);
    });
    
    var updateCache = new Map();
    (0, util_1.each)(this.option, function (option) {
      if (!(0, util_1.includes)(ANNOTATIONS_AFTER_RENDER, option.type)) {
        var co = _this.updateOrCreate(option);
        
        if (co) {
          updateCache.set(_this.getCacheKey(option), co);
        }
      }
    });
    this.cache = this.syncCache(updateCache);
  };
    Annotation.prototype.clear = function (includeOption) {
    if (includeOption === void 0) {
      includeOption = false;
    }
    _super.prototype.clear.call(this);
    this.clearComponents();
    this.foregroundContainer.clear();
    this.backgroundContainer.clear();
    
    if (includeOption) {
      this.option = [];
    }
  };
  Annotation.prototype.destroy = function () {
    this.clear(true);
    this.foregroundContainer.remove(true);
    this.backgroundContainer.remove(true);
  };
    Annotation.prototype.getComponents = function () {
    var co = [];
    this.cache.forEach(function (value) {
      co.push(value);
    });
    return co;
  };
    Annotation.prototype.clearComponents = function () {
    this.getComponents().forEach(function (co) {
      co.component.destroy();
    });
    this.cache.clear();
  };
    Annotation.prototype.onAfterRender = function (doWhat) {
    if (this.view.getOptions().animate) {
      this.view.geometries.forEach(function (g) {
        
        if (g.animateOption) {
          g.once(constant_1.GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function () {
            doWhat();
          });
        }
      });
    } else {
      this.view.getRootView().once(constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER, function () {
        doWhat();
      });
    }
  };
  Annotation.prototype.createAnnotation = function (option) {
    var type = option.type;
    var Ctor = dependents_1.Annotation[(0, util_1.upperFirst)(type)];
    if (Ctor) {
      var theme = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme);
      var annotation = new Ctor(cfg);
      return {
        component: annotation,
        layer: this.isTop(cfg) ? constant_1.LAYER.FORE : constant_1.LAYER.BG,
        direction: constant_1.DIRECTION.NONE,
        type: constant_1.COMPONENT_TYPE.ANNOTATION,
        extra: option
      };
    }
  };
  
  Annotation.prototype.annotation = function (option) {
    this.option.push(option);
  };
    Annotation.prototype.arc = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'arc'
    }, option));
    return this;
  };
    Annotation.prototype.image = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'image'
    }, option));
    return this;
  };
    Annotation.prototype.line = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'line'
    }, option));
    return this;
  };
    Annotation.prototype.region = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'region'
    }, option));
    return this;
  };
    Annotation.prototype.text = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'text'
    }, option));
    return this;
  };
    Annotation.prototype.dataMarker = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'dataMarker'
    }, option));
    return this;
  };
    Annotation.prototype.dataRegion = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'dataRegion'
    }, option));
  };
    Annotation.prototype.regionFilter = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'regionFilter'
    }, option));
  };
    Annotation.prototype.shape = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'shape'
    }, option));
  };
    Annotation.prototype.html = function (option) {
    this.annotation((0, tslib_1.__assign)({
      type: 'html'
    }, option));
  };
  
    Annotation.prototype.parsePosition = function (p) {
    var xScale = this.view.getXScale();
    
    var yScales = this.view.getScalesByDim('y');
    var position = (0, util_1.isFunction)(p) ? p.call(null, xScale, yScales) : p;
    var x = 0;
    var y = 0;
    
    if ((0, util_1.isArray)(position)) {
      var xPos = position[0],
        yPos = position[1];
      
      
      
      if ((0, util_1.isString)(xPos) && xPos.indexOf('%') !== -1 && !isNaN(xPos.slice(0, -1))) {
        return this.parsePercentPosition(position);
      }
      x = (0, annotation_1.getNormalizedValue)(xPos, xScale);
      y = (0, annotation_1.getNormalizedValue)(yPos, Object.values(yScales)[0]);
    } else if (!(0, util_1.isNil)(position)) {
      
      for (var _i = 0, _a = (0, util_1.keys)(position); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = position[key];
        if (key === xScale.field) {
          x = (0, annotation_1.getNormalizedValue)(value, xScale);
        }
        if (yScales[key]) {
          y = (0, annotation_1.getNormalizedValue)(value, yScales[key]);
        }
      }
    }
    return this.view.getCoordinate().convert({
      x: x,
      y: y
    });
  };
    Annotation.prototype.getRegionPoints = function (start, end) {
    var _this = this;
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim('y');
    var yScale = Object.values(yScales)[0];
    var xField = xScale.field;
    var viewData = this.view.getData();
    var startXValue = (0, util_1.isArray)(start) ? start[0] : start[xField];
    var endXValue = (0, util_1.isArray)(end) ? end[0] : end[xField];
    var arr = [];
    var startIndex;
    (0, util_1.each)(viewData, function (item, idx) {
      if (item[xField] === startXValue) {
        startIndex = idx;
      }
      if (idx >= startIndex) {
        var point = _this.parsePosition([item[xField], item[yScale.field]]);
        if (point) {
          arr.push(point);
        }
      }
      if (item[xField] === endXValue) {
        return false;
      }
    });
    return arr;
  };
    Annotation.prototype.parsePercentPosition = function (position) {
    var xPercent = parseFloat(position[0]) / 100;
    var yPercent = parseFloat(position[1]) / 100;
    var coordinate = this.view.getCoordinate();
    var start = coordinate.start,
      end = coordinate.end;
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    var x = coordinate.getWidth() * xPercent + topLeft.x;
    var y = coordinate.getHeight() * yPercent + topLeft.y;
    return {
      x: x,
      y: y
    };
  };
    Annotation.prototype.getCoordinateBBox = function () {
    var coordinate = this.view.getCoordinate();
    var start = coordinate.start,
      end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    return {
      x: topLeft.x,
      y: topLeft.y,
      minX: topLeft.x,
      minY: topLeft.y,
      maxX: topLeft.x + width,
      maxY: topLeft.y + height,
      width: width,
      height: height
    };
  };
    Annotation.prototype.getAnnotationCfg = function (type, option, theme) {
    var _this = this;
    var coordinate = this.view.getCoordinate();
    var canvas = this.view.getCanvas();
    var o = {};
    if ((0, util_1.isNil)(option)) {
      return null;
    }
    if (type === 'arc') {
      var _a = option,
        start = _a.start,
        end = _a.end,
        rest = (0, tslib_1.__rest)(_a, ["start", "end"]);
      var sp = this.parsePosition(start);
      var ep = this.parsePosition(end);
      var startAngle = (0, coordinate_1.getAngleByPoint)(coordinate, sp);
      var endAngle = (0, coordinate_1.getAngleByPoint)(coordinate, ep);
      if (startAngle > endAngle) {
        endAngle = Math.PI * 2 + endAngle;
      }
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), {
        center: coordinate.getCenter(),
        radius: (0, coordinate_1.getDistanceToCenter)(coordinate, sp),
        startAngle: startAngle,
        endAngle: endAngle
      });
    } else if (type === 'image') {
      var _b = option,
        start = _b.start,
        end = _b.end,
        rest = (0, tslib_1.__rest)(_b, ["start", "end"]);
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), {
        start: this.parsePosition(start),
        end: this.parsePosition(end),
        src: option.src
      });
    } else if (type === 'line') {
      var _c = option,
        start = _c.start,
        end = _c.end,
        rest = (0, tslib_1.__rest)(_c, ["start", "end"]);
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), {
        start: this.parsePosition(start),
        end: this.parsePosition(end),
        text: (0, util_1.get)(option, 'text', null)
      });
    } else if (type === 'region') {
      var _d = option,
        start = _d.start,
        end = _d.end,
        rest = (0, tslib_1.__rest)(_d, ["start", "end"]);
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), {
        start: this.parsePosition(start),
        end: this.parsePosition(end)
      });
    } else if (type === 'text') {
      var filteredData = this.view.getData();
      var _e = option,
        position = _e.position,
        content = _e.content,
        rest = (0, tslib_1.__rest)(_e, ["position", "content"]);
      var textContent = content;
      if ((0, util_1.isFunction)(content)) {
        textContent = content(filteredData);
      }
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, this.parsePosition(position)), rest), {
        content: textContent
      });
    } else if (type === 'dataMarker') {
      var _f = option,
        position = _f.position,
        point = _f.point,
        line = _f.line,
        text = _f.text,
        autoAdjust = _f.autoAdjust,
        direction = _f.direction,
        rest = (0, tslib_1.__rest)(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), this.parsePosition(position)), {
        coordinateBBox: this.getCoordinateBBox(),
        point: point,
        line: line,
        text: text,
        autoAdjust: autoAdjust,
        direction: direction
      });
    } else if (type === 'dataRegion') {
      var _g = option,
        start = _g.start,
        end = _g.end,
        region = _g.region,
        text = _g.text,
        lineLength = _g.lineLength,
        rest = (0, tslib_1.__rest)(_g, ["start", "end", "region", "text", "lineLength"]);
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), {
        points: this.getRegionPoints(start, end),
        region: region,
        text: text,
        lineLength: lineLength
      });
    } else if (type === 'regionFilter') {
      var _h = option,
        start = _h.start,
        end = _h.end,
        apply_1 = _h.apply,
        color = _h.color,
        rest = (0, tslib_1.__rest)(_h, ["start", "end", "apply", "color"]);
      var geometries = this.view.geometries;
      var shapes_1 = [];
      var addShapes_1 = function addShapes_1(item) {
        if (!item) {
          return;
        }
        if (item.isGroup()) {
          item.getChildren().forEach(function (child) {
            return addShapes_1(child);
          });
        } else {
          shapes_1.push(item);
        }
      };
      (0, util_1.each)(geometries, function (geom) {
        if (apply_1) {
          if ((0, util_1.contains)(apply_1, geom.type)) {
            (0, util_1.each)(geom.elements, function (elem) {
              addShapes_1(elem.shape);
            });
          }
        } else {
          (0, util_1.each)(geom.elements, function (elem) {
            addShapes_1(elem.shape);
          });
        }
      });
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), {
        color: color,
        shapes: shapes_1,
        start: this.parsePosition(start),
        end: this.parsePosition(end)
      });
    } else if (type === 'shape') {
      var _j = option,
        render_1 = _j.render,
        restOptions = (0, tslib_1.__rest)(_j, ["render"]);
      var wrappedRender = function wrappedRender(container) {
        if ((0, util_1.isFunction)(option.render)) {
          return render_1(container, _this.view, {
            parsePosition: _this.parsePosition.bind(_this)
          });
        }
      };
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, restOptions), {
        render: wrappedRender
      });
    } else if (type === 'html') {
      var _k = option,
        html_1 = _k.html,
        position = _k.position,
        restOptions = (0, tslib_1.__rest)(_k, ["html", "position"]);
      var wrappedHtml = function wrappedHtml(container) {
        if ((0, util_1.isFunction)(html_1)) {
          return html_1(container, _this.view);
        }
        return html_1;
      };
      o = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, restOptions), this.parsePosition(position)), {
        
        parent: canvas.get('el').parentNode,
        html: wrappedHtml
      });
    }
    
    var cfg = (0, util_1.deepMix)({}, theme, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, o), {
      top: option.top,
      style: option.style,
      offsetX: option.offsetX,
      offsetY: option.offsetY
    }));
    if (type !== 'html') {
      
      cfg.container = this.getComponentContainer(cfg);
    }
    cfg.animate = this.view.getOptions().animate && cfg.animate && (0, util_1.get)(option, 'animate', cfg.animate); 
    cfg.animateOption = (0, util_1.deepMix)({}, animate_1.DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
    return cfg;
  };
    Annotation.prototype.isTop = function (option) {
    return (0, util_1.get)(option, 'top', true);
  };
    Annotation.prototype.getComponentContainer = function (option) {
    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
  };
  Annotation.prototype.getAnnotationTheme = function (type) {
    return (0, util_1.get)(this.view.getTheme(), ['components', 'annotation', type], {});
  };
    Annotation.prototype.updateOrCreate = function (option) {
    
    var co = this.cache.get(this.getCacheKey(option));
    
    if (co) {
      var type = option.type;
      var theme = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme);
      
      (0, helper_1.omit)(cfg, ['container']);
      co.component.update(cfg);
      
      if ((0, util_1.includes)(ANNOTATIONS_AFTER_RENDER, option.type)) {
        co.component.render();
      }
    } else {
      
      co = this.createAnnotation(option);
      if (co) {
        co.component.init();
        
        
        if ((0, util_1.includes)(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      }
    }
    return co;
  };
    Annotation.prototype.syncCache = function (updated) {
    var _this = this;
    var newCache = new Map(this.cache); 
    
    updated.forEach(function (co, key) {
      newCache.set(key, co);
    });
    
    newCache.forEach(function (co, key) {
      
      if (!(0, util_1.find)(_this.option, function (option) {
        return key === _this.getCacheKey(option);
      })) {
        co.component.destroy();
        newCache.delete(key);
      }
    });
    return newCache;
  };
    Annotation.prototype.getCacheKey = function (option) {
    
    return option;
    
    
    
  };

  return Annotation;
}(base_1.Controller);
exports.default = Annotation;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionUpdate = void 0;
function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs;
  
  var x = toAttrs.x;
  
  var y = toAttrs.y;
  
  delete toAttrs.x;
  
  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x: x,
    y: y
  }, animateCfg);
}
exports.positionUpdate = positionUpdate;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sectorPathUpdate = void 0;
var tslib_1 = __webpack_require__(1);
var g_canvas_1 = __webpack_require__(205);
var util_1 = __webpack_require__(0);
var graphics_1 = __webpack_require__(46);
function getAngle(startPoint, arcPath) {
  var _a;
  var _b = (0, g_canvas_1.getArcParams)(startPoint, arcPath),
    startAngle = _b.startAngle,
    endAngle = _b.endAngle;
  if (!(0, util_1.isNumberEqual)(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }
  if (!(0, util_1.isNumberEqual)(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }
  if (arcPath[5] === 0) {
    
    _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];
  }
  if ((0, util_1.isNumberEqual)(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }
  if ((0, util_1.isNumberEqual)(endAngle, Math.PI * -0.5)) {
    endAngle = Math.PI * 1.5;
  }
  return {
    startAngle: startAngle,
    endAngle: endAngle
  };
}
function getArcStartPoint(path) {
  var startPoint;
  if (path[0] === 'M' || path[0] === 'L') {
    startPoint = [path[1], path[2]];
  } else if (path[0] === 'a' || path[0] === 'A' || path[0] === 'C') {
    startPoint = [path[path.length - 2], path[path.length - 1]];
  }
  return startPoint;
}
function getArcInfo(path) {
  var _a;
  var startAngle;
  var endAngle;
  var arcPaths = path.filter(function (command) {
    return command[0] === 'A' || command[0] === 'a';
  });
  if (arcPaths.length === 0) {
    return {
      startAngle: 0,
      endAngle: 0,
      radius: 0,
      innerRadius: 0
    };
  }
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path.indexOf(firstArcPathCommand);
  var lastIndex = path.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
  var _b = getAngle(firstStartPoint, firstArcPathCommand),
    firstStartAngle = _b.startAngle,
    firstEndAngle = _b.endAngle;
  var _c = getAngle(lastStartPoint, lastArcPathCommand),
    lastStartAngle = _c.startAngle,
    lastEndAngle = _c.endAngle;
  if ((0, util_1.isNumberEqual)(firstStartAngle, lastStartAngle) && (0, util_1.isNumberEqual)(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }
  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];
  if (radius < innerRadius) {
    _a = [innerRadius, radius], radius = _a[0], innerRadius = _a[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }
  return {
    startAngle: startAngle,
    endAngle: endAngle,
    radius: radius,
    innerRadius: innerRadius
  };
}
function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs,
    coordinate = cfg.coordinate;
  var path = toAttrs.path || [];
  var pathCommands = path.map(function (command) {
    return command[0];
  });
  if (path.length < 1) return;
  var _a = getArcInfo(path),
    curStartAngle = _a.startAngle,
    curEndAngle = _a.endAngle,
    radius = _a.radius,
    innerRadius = _a.innerRadius;
  var _b = getArcInfo(shape.attr('path')),
    preStartAngle = _b.startAngle,
    preEndAngle = _b.endAngle;
  var center = coordinate.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  
  if (diffStartAngle === 0 && diffEndAngle === 0) {
    shape.attr('path', path);
    return;
  }
  shape.animate(function (ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, toAttrs), {
      path:
      
      (0, util_1.isEqual)(pathCommands, ['M', 'A', 'A', 'Z']) ? (0, graphics_1.getArcPath)(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : (0, graphics_1.getSectorPath)(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)
    });
  }, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, animateCfg), {
    callback: function callback() {
      
      shape.attr('path', path);
    }
  }));
}
exports.sectorPathUpdate = sectorPathUpdate;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waveIn = void 0;
var tslib_1 = __webpack_require__(1);
var coordinate_1 = __webpack_require__(48);
function waveIn(element, animateCfg, cfg) {
  var _a = (0, coordinate_1.getCoordinateClipCfg)(cfg.coordinate, 20),
    type = _a.type,
    startState = _a.startState,
    endState = _a.endState; 
  var clipShape = element.setClip({
    type: type,
    attrs: startState
  }); 
  
  clipShape.animate(endState, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, animateCfg), {
    callback: function callback() {
      if (element && !element.get('destroyed')) {
        element.set('clipShape', null);
      }
      clipShape.remove(true); 
    }
  }));
}

exports.waveIn = waveIn;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
 var _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
 var _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__);
 for(var __WEBPACK_IMPORT_KEY__ in _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  Shape: true,
  Canvas: true,
  Group: true
};
Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return _canvas.default;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
exports.version = exports.Shape = void 0;
var Shape = _interopRequireWildcard(__webpack_require__(190));
exports.Shape = Shape;
var _gBase = __webpack_require__(26);
Object.keys(_gBase).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _gBase[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _gBase[key];
    }
  });
});
var _canvas = _interopRequireDefault(__webpack_require__(980));
var _group = _interopRequireDefault(__webpack_require__(275));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var version = '0.5.6';
exports.version = version;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var constant_1 = __webpack_require__(21);
var path_1 = (0, tslib_1.__importDefault)(__webpack_require__(158));
__webpack_require__(278);
var Area = function (_super) {
  (0, tslib_1.__extends)(Area, _super);
  function Area(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = 'area';
    _this.shapeType = 'area';
        _this.generatePoints = true;
        _this.startOnZero = true;
    var _a = cfg.startOnZero,
      startOnZero = _a === void 0 ? true : _a,
      _b = cfg.sortable,
      sortable = _b === void 0 ? false : _b,
      _c = cfg.showSinglePoint,
      showSinglePoint = _c === void 0 ? false : _c;
    _this.startOnZero = startOnZero; 
    _this.sortable = sortable; 
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
    Area.prototype.getPointsAndData = function (mappingData) {
    var points = [];
    var data = [];
    for (var i = 0, len = mappingData.length; i < len; i++) {
      var obj = mappingData[i];
      points.push(obj.points);
      data.push(obj[constant_1.FIELD_ORIGIN]);
    }
    return {
      points: points,
      data: data
    };
  };
    Area.prototype.getYMinValue = function () {
    if (this.startOnZero) {
      return _super.prototype.getYMinValue.call(this);
    }
    var yScale = this.getYScale();
    return yScale.min;
  };
  return Area;
}(path_1.default);
exports.default = Area;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
__webpack_require__(461);
var Edge = function (_super) {
  (0, tslib_1.__extends)(Edge, _super);
  function Edge() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'edge';
    _this.shapeType = 'edge';
    _this.generatePoints = true;
    return _this;
  }
  return Edge;
}(base_1.default);
exports.default = Edge;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var color_util_1 = (0, tslib_1.__importDefault)(__webpack_require__(140));
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
var Heatmap = function (_super) {
  (0, tslib_1.__extends)(Heatmap, _super);
  function Heatmap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'heatmap';
    _this.paletteCache = {};
    return _this;
  }
  Heatmap.prototype.updateElements = function (mappingDataArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      var range = this.prepareRange(mappingData);
      var radius = this.prepareSize();
      var blur_1 = (0, util_1.get)(this.styleOption, ['cfg', 'shadowBlur']);
      if (!(0, util_1.isNumber)(blur_1)) {
        blur_1 = radius / 2;
      }
      this.prepareGreyScaleBlurredCircle(radius, blur_1);
      this.drawWithRange(mappingData, range, radius, blur_1);
    }
  };
    Heatmap.prototype.color = function (field, cfg) {
    this.createAttrOption('color', field, typeof cfg !== 'function' ? cfg : '');
    return this;
  };
  /**
   * clear
   */
  Heatmap.prototype.clear = function () {
    _super.prototype.clear.call(this);
    this.clearShadowCanvasCtx();
    this.paletteCache = {};
  };
  Heatmap.prototype.prepareRange = function (data) {
    var colorAttr = this.getAttribute('color');
    var colorField = colorAttr.getFields()[0];
    var min = Infinity;
    var max = -Infinity;
    data.forEach(function (row) {
      var value = row[constant_1.FIELD_ORIGIN][colorField];
      if (value > max) {
        max = value;
      }
      if (value < min) {
        min = value;
      }
    });
    if (min === max) {
      min = max - 1;
    }
    return [min, max];
  };
  Heatmap.prototype.prepareSize = function () {
    var radius = this.getDefaultValue('size');
    if (!(0, util_1.isNumber)(radius)) {
      radius = this.getDefaultSize();
    }
    return radius;
  };
  Heatmap.prototype.prepareGreyScaleBlurredCircle = function (radius, blur) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    var r2 = radius + blur;
    var ctx = grayScaleBlurredCanvas.getContext('2d');
    grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
    ctx.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
    ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
    ctx.shadowBlur = blur;
    ctx.shadowColor = 'black';
    ctx.beginPath();
    ctx.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
  };
  Heatmap.prototype.drawWithRange = function (data, range, radius, blur) {
    
    var _a = this.coordinate,
      start = _a.start,
      end = _a.end;
    var width = this.coordinate.getWidth();
    var height = this.coordinate.getHeight();
    
    var colorAttr = this.getAttribute('color');
    var valueField = colorAttr.getFields()[0];
    
    this.clearShadowCanvasCtx();
    var ctx = this.getShadowCanvasCtx();
    
    if (range) {
      data = data.filter(function (row) {
        return row[constant_1.FIELD_ORIGIN][valueField] <= range[1] && row[constant_1.FIELD_ORIGIN][valueField] >= range[0];
      });
    }
    
    var scale = this.scales[valueField];
    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
      var obj = data_1[_i];
      var _b = this.getDrawCfg(obj),
        x = _b.x,
        y = _b.y;
      var alpha = scale.scale(obj[constant_1.FIELD_ORIGIN][valueField]);
      this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx);
    }
    
    var colored = ctx.getImageData(0, 0, width, height);
    this.clearShadowCanvasCtx();
    this.colorize(colored);
    ctx.putImageData(colored, 0, 0);
    var imageShape = this.getImageShape();
    imageShape.attr('x', start.x);
    imageShape.attr('y', end.y);
    imageShape.attr('width', width);
    imageShape.attr('height', height);
    imageShape.attr('img', ctx.canvas);
    imageShape.set('origin', this.getShapeInfo(data)); 
  };

  Heatmap.prototype.getDefaultSize = function () {
    var position = this.getAttribute('position');
    var coordinate = this.coordinate;
    return Math.min(coordinate.getWidth() / (position.scales[0].ticks.length * 4), coordinate.getHeight() / (position.scales[1].ticks.length * 4));
  };
  Heatmap.prototype.clearShadowCanvasCtx = function () {
    var ctx = this.getShadowCanvasCtx();
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  };
  Heatmap.prototype.getShadowCanvasCtx = function () {
    var canvas = this.shadowCanvas;
    if (!canvas) {
      canvas = document.createElement('canvas');
      this.shadowCanvas = canvas;
    }
    canvas.width = this.coordinate.getWidth();
    canvas.height = this.coordinate.getHeight();
    return canvas.getContext('2d');
  };
  Heatmap.prototype.getGrayScaleBlurredCanvas = function () {
    if (!this.grayScaleBlurredCanvas) {
      this.grayScaleBlurredCanvas = document.createElement('canvas');
    }
    return this.grayScaleBlurredCanvas;
  };
  Heatmap.prototype.drawGrayScaleBlurredCircle = function (x, y, r, alpha, ctx) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    ctx.globalAlpha = alpha;
    ctx.drawImage(grayScaleBlurredCanvas, x - r, y - r);
  };
  Heatmap.prototype.colorize = function (img) {
    var colorAttr = this.getAttribute('color');
    var pixels = img.data;
    var paletteCache = this.paletteCache;
    for (var i = 3; i < pixels.length; i += 4) {
      var alpha = pixels[i]; 
      if ((0, util_1.isNumber)(alpha)) {
        var palette = paletteCache[alpha] ? paletteCache[alpha] : color_util_1.default.rgb2arr(colorAttr.gradient(alpha / 256));
        pixels[i - 3] = palette[0];
        pixels[i - 2] = palette[1];
        pixels[i - 1] = palette[2];
        pixels[i] = alpha;
      }
    }
  };
  Heatmap.prototype.getImageShape = function () {
    var imageShape = this.imageShape;
    if (imageShape) {
      return imageShape;
    }
    var container = this.container;
    imageShape = container.addShape({
      type: 'image',
      attrs: {}
    });
    this.imageShape = imageShape;
    return imageShape;
  };
  Heatmap.prototype.getShapeInfo = function (mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var data = mappingData.map(function (obj) {
      return obj[constant_1.FIELD_ORIGIN];
    });
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeCfg), {
      mappingData: mappingData,
      data: data
    });
  };
  return Heatmap;
}(base_1.default);
exports.default = Heatmap;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var coordinate_1 = __webpack_require__(48);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
__webpack_require__(987);
var shape_size_1 = __webpack_require__(279);
var scale_1 = __webpack_require__(111);
var Interval = function (_super) {
  (0, tslib_1.__extends)(Interval, _super);
  function Interval(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = 'interval';
    _this.shapeType = 'interval';
    _this.generatePoints = true;
    var background = cfg.background;
    _this.background = background;
    return _this;
  }
    Interval.prototype.createShapePointsCfg = function (obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    
    var size;
    var sizeAttr = this.getAttribute('size');
    if (sizeAttr) {
      size = this.getAttributeValues(sizeAttr, obj)[0];
      
      var coordinate = this.coordinate;
      var coordinateWidth = (0, coordinate_1.getXDimensionLength)(coordinate);
      size = size / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = (0, shape_size_1.getDefaultSize)(this);
      }
      size = this.defaultSize;
    }
    cfg.size = size;
    return cfg;
  };
    Interval.prototype.adjustScale = function () {
    _super.prototype.adjustScale.call(this);
    var yScale = this.getYScale();
    
    if (this.coordinate.type === 'theta') {
      yScale.change({
        nice: false,
        min: 0,
        
        max: (0, scale_1.getMaxScale)(yScale)
      });
    } else {
      
      var scaleDefs = this.scaleDefs;
      var field = yScale.field,
        min = yScale.min,
        max = yScale.max,
        type = yScale.type;
      if (type !== 'time') {
        
        
        if (min > 0 && !(0, util_1.get)(scaleDefs, [field, 'min'])) {
          yScale.change({
            min: 0
          });
        }
        
        if (max <= 0 && !(0, util_1.get)(scaleDefs, [field, 'max'])) {
          yScale.change({
            max: 0
          });
        }
      }
    }
  };
    Interval.prototype.getDrawCfg = function (mappingData) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
    shapeCfg.background = this.background;
    return shapeCfg;
  };
  return Interval;
}(base_1.default);
exports.default = Interval;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var path_1 = (0, tslib_1.__importDefault)(__webpack_require__(158));
__webpack_require__(276);
var Line = function (_super) {
  (0, tslib_1.__extends)(Line, _super);
  function Line(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = 'line';
    var _a = cfg.sortable,
      sortable = _a === void 0 ? false : _a; 
    _this.sortable = sortable;
    return _this;
  }
  return Line;
}(path_1.default);
exports.default = Line;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
__webpack_require__(988);
var Point = function (_super) {
  (0, tslib_1.__extends)(Point, _super);
  function Point() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'point';
    _this.shapeType = 'point';
    _this.generatePoints = true;
    return _this;
  }
    Point.prototype.getDrawCfg = function (mappingDatum) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeCfg), {
      isStack: !!this.getAdjust('stack')
    });
  };
  return Point;
}(base_1.default);
exports.default = Point;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
__webpack_require__(462);
var Polygon = function (_super) {
  (0, tslib_1.__extends)(Polygon, _super);
  function Polygon() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'polygon';
    _this.shapeType = 'polygon';
    _this.generatePoints = true;
    return _this;
  }
    Polygon.prototype.createShapePointsCfg = function (obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var x = cfg.x;
    var y = cfg.y;
    var temp;
    
    if (!((0, util_1.isArray)(x) && (0, util_1.isArray)(y))) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xCount = xScale.values.length;
      var yCount = yScale.values.length;
      var xOffset = 0.5 * 1 / xCount;
      var yOffset = 0.5 * 1 / yCount;
      if (xScale.isCategory && yScale.isCategory) {
        
        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
      } else if ((0, util_1.isArray)(x)) {
        
        temp = x;
        x = [temp[0], temp[0], temp[1], temp[1]];
        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
      } else if ((0, util_1.isArray)(y)) {
        
        temp = y;
        y = [temp[0], temp[1], temp[1], temp[0]];
        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
      }
      cfg.x = x;
      cfg.y = y;
    }
    return cfg;
  };
  return Polygon;
}(base_1.default);
exports.default = Polygon;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var coordinate_1 = __webpack_require__(48);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(91));
__webpack_require__(463);
var shape_size_1 = __webpack_require__(279);
var Schema = function (_super) {
  (0, tslib_1.__extends)(Schema, _super);
  function Schema() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'schema';
    _this.shapeType = 'schema';
    _this.generatePoints = true;
    return _this;
  }
    Schema.prototype.createShapePointsCfg = function (record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    
    var size;
    var sizeAttr = this.getAttribute('size');
    if (sizeAttr) {
      size = this.getAttributeValues(sizeAttr, record)[0];
      
      var coordinate = this.coordinate;
      var coordinateWidth = (0, coordinate_1.getXDimensionLength)(coordinate);
      size = size / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = (0, shape_size_1.getDefaultSize)(this);
      }
      size = this.defaultSize;
    }
    cfg.size = size;
    return cfg;
  };
  return Schema;
}(base_1.default);
exports.default = Schema;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distribute = void 0;
var util_1 = __webpack_require__(0);
var graphics_1 = __webpack_require__(46);
var MARGIN = 4;
function antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {
  
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function (label) {
    if (label.y > maxY) {
      maxY = label.y;
    }
    if (label.y < minY) {
      minY = label.y;
    }
    return {
      size: lineHeight,
      targets: [label.y - startY]
    };
  });
  minY -= startY;
  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }
  while (overlapping) {
        boxes.forEach(function (box) {
      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
      
    });
    
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box = boxes[i];
        if (previousBox.pos + previousBox.size > box.pos) {
          
          previousBox.size += box.size;
          previousBox.targets = previousBox.targets.concat(box.targets);
          
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1); 
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  
  boxes.forEach(function (b) {
    var posInCompositeBox = startY + lineHeight / 2; 
    b.targets.forEach(function () {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  });
  var labelsMap = {};
  for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {
    var labelShape = labelShapes_1[_i];
    labelsMap[labelShape.get('id')] = labelShape;
  }
  
  labels.forEach(function (label) {
    var rPow2 = label.r * label.r;
    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
    if (rPow2 < dyPow2) {
      label.x = center.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);
      if (!isRight) {
        
        label.x = center.x - dx;
      } else {
        
        label.x = center.x + dx;
      }
    }
    
    var labelShape = labelsMap[label.id];
    labelShape.attr('x', label.x);
    labelShape.attr('y', label.y);
    
    var textShape = (0, util_1.find)(labelShape.getChildren(), function (ele) {
      return ele.get('type') === 'text';
    });
    
    if (textShape) {
      textShape.attr('y', label.y);
      textShape.attr('x', label.x);
    }
  });
}
function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }
  var offset = items[0] ? items[0].offset : 0;
  var coordinate = labels[0].get('coordinate');
  var radius = coordinate.getRadius();
  var center = coordinate.getCenter();
  if (offset > 0) {
    
    var lineHeight_1 = 14; 
    var totalR = radius + offset;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate.start,
      end: coordinate.end
    };
    
    var halves_1 = [[], [] 
    ];

    items.forEach(function (labelItem) {
      if (!labelItem) {
        return;
      }
      if (labelItem.textAlign === 'right') {
        
        halves_1[0].push(labelItem);
      } else {
        
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function (half, index) {
      
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function (a, b) {
          
          return b['..percent'] - a['..percent'];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      }
      
      half.sort(function (a, b) {
        
        return a.y - b.y;
      });
      antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);
    });
  }
  
  (0, util_1.each)(items, function (item) {
    if (item && item.labelLine) {
      var distance = item.offset;
      var angle = item.angle;
      
      var startPoint = (0, graphics_1.polarToCartesian)(center.x, center.y, radius, angle);
      var innerPoint = (0, graphics_1.polarToCartesian)(center.x, center.y, radius + distance / 2, angle);
      var itemX = item.x + (0, util_1.get)(item, 'offsetX', 0);
      var itemY = item.y + (0, util_1.get)(item, 'offsetY', 0);
      var endPoint = {
        x: itemX - Math.cos(angle) * MARGIN,
        y: itemY - Math.sin(angle) * MARGIN
      };
      if (!(0, util_1.isObject)(item.labelLine)) {
        
        item.labelLine = {};
      }
      item.labelLine.path = ["M " + startPoint.x, startPoint.y + " Q" + innerPoint.x, innerPoint.y + " " + endPoint.x, endPoint.y].join(',');
    }
  });
}
exports.distribute = distribute;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInCanvas = void 0;
var util_1 = __webpack_require__(0);
var transform_1 = __webpack_require__(114);
function limitInCanvas(items, labels, shapes, region) {
  (0, util_1.each)(labels, function (label) {
    var regionMinX = region.minX,
      regionMinY = region.minY,
      regionMaxX = region.maxX,
      regionMaxY = region.maxY;
    var _a = label.getCanvasBBox(),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY,
      x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height;
    var finalX = x;
    var finalY = y;
    if (minX < regionMinX || maxX < regionMinX) {
      
      finalX = regionMinX;
    }
    if (minY < regionMinY || maxY < regionMinY) {
      
      finalY = regionMinY;
    }
    if (minX > regionMaxX) {
      
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      
      finalX = finalX - (maxX - regionMaxX);
    }
    if (minY > regionMaxY) {
      
      finalY = regionMaxY - height;
    } else if (maxY > regionMaxY) {
      
      finalY = finalY - (maxY - regionMaxY);
    }
    if (finalX !== x || finalY !== y) {
      (0, transform_1.translate)(label, finalX - x, finalY - y);
    }
  });
}
exports.limitInCanvas = limitInCanvas;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInShape = void 0;
var util_1 = __webpack_require__(0);
function limitInShape(items, labels, shapes, region) {
  (0, util_1.each)(labels, function (label, index) {
    var labelBBox = label.getCanvasBBox(); 
    var shapeBBox = shapes[index].getBBox();
    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label.remove(true); 
    }
  });
}

exports.limitInShape = limitInShape;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var facet_1 = __webpack_require__(116);
var facet_2 = __webpack_require__(105);
var Circle = function (_super) {
  (0, tslib_1.__extends)(Circle, _super);
  function Circle() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle.prototype.getDefaultCfg = function () {
    return (0, util_1.deepMix)({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'circle',
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Circle.prototype.render = function () {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
    Circle.prototype.getRegion = function (count, index) {
    var r = 1 / 2; 
    
    var center = {
      x: 0.5,
      y: 0.5
    };
    
    var avgAngle = Math.PI * 2 / count;
    
    var angle = -1 * Math.PI / 2 + avgAngle * index;
    
    var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
    
    var middle = (0, facet_1.getAnglePoint)(center, r - facetR, angle);
    var startAngle = Math.PI * 5 / 4; 
    var endAngle = Math.PI * 1 / 4; 
    return {
      start: (0, facet_1.getAnglePoint)(middle, facetR, startAngle),
      end: (0, facet_1.getAnglePoint)(middle, facetR, endAngle)
    };
  };
  Circle.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };
  Circle.prototype.beforeEachView = function (view, facet) {};
  Circle.prototype.generateFacets = function (data) {
    var _this = this;
    var _a = this.cfg,
      fields = _a.fields,
      type = _a.type;
    var field = fields[0];
    if (!field) {
      throw new Error('No `fields` specified!');
    }
    var values = this.getFieldValues(data, field);
    var count = values.length;
    var rst = [];
    values.forEach(function (value, index) {
      var conditions = [{
        field: field,
        value: value,
        values: values
      }];
      var facetData = (0, util_1.filter)(data, _this.getFacetDataFilter(conditions));
      var facet = {
        type: type,
        data: facetData,
        region: _this.getRegion(count, index),
        columnValue: value,
        columnField: field,
        columnIndex: index,
        columnValuesLength: count,
        rowValue: null,
        rowField: null,
        rowIndex: 0,
        rowValuesLength: 1
      };
      rst.push(facet);
    });
    return rst;
  };
  Circle.prototype.getXAxisOption = function (x, axes, option, facet) {
    
    return option;
  };
    Circle.prototype.getYAxisOption = function (y, axes, option, facet) {
    
    return option;
  };
    Circle.prototype.renderTitle = function () {
    var _this = this;
    (0, util_1.each)(this.facets, function (facet) {
      var columnValue = facet.columnValue,
        view = facet.view;
      var formatter = (0, util_1.get)(_this.cfg.title, 'formatter');
      var config = (0, util_1.deepMix)({
        position: ['50%', '0%'],
        content: formatter ? formatter(columnValue) : columnValue
      }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  return Circle;
}(facet_2.Facet);
exports.default = Circle;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var facet_1 = __webpack_require__(116);
var facet_2 = __webpack_require__(105);
var List = function (_super) {
  (0, tslib_1.__extends)(List, _super);
  function List() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  List.prototype.getDefaultCfg = function () {
    return (0, util_1.deepMix)({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'list',
      cols: null,
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  List.prototype.render = function () {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  List.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };
  List.prototype.beforeEachView = function (view, facet) {};
  List.prototype.generateFacets = function (data) {
    var _this = this;
    var fields = this.cfg.fields;
    var cols = this.cfg.cols;
    var columnField = fields[0];
    if (!columnField) {
      throw new Error('No `fields` specified!');
    }
    var colValues = this.getFieldValues(data, columnField);
    var count = colValues.length;
    cols = cols || count; 
    
    var rows = this.getPageCount(count, cols);
    var rst = [];
    colValues.forEach(function (val, index) {
      
      var _a = _this.getRowCol(index, cols),
        row = _a.row,
        col = _a.col;
      var conditions = [{
        field: columnField,
        value: val,
        values: colValues
      }];
      var facetData = (0, util_1.filter)(data, _this.getFacetDataFilter(conditions));
      var facet = {
        type: _this.cfg.type,
        data: facetData,
        region: _this.getRegion(rows, cols, col, row),
        columnValue: val,
        rowValue: val,
        columnField: columnField,
        rowField: null,
        columnIndex: col,
        rowIndex: row,
        columnValuesLength: cols,
        rowValuesLength: rows,
        total: count
      };
      rst.push(facet);
    });
    return rst;
  };
    List.prototype.getXAxisOption = function (x, axes, option, facet) {
    
    if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        label: null,
        title: null
      });
    }
    return option;
  };
    List.prototype.getYAxisOption = function (y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null,
        label: null
      });
    }
    return option;
  };
    List.prototype.renderTitle = function () {
    var _this = this;
    (0, util_1.each)(this.facets, function (facet) {
      var columnValue = facet.columnValue,
        view = facet.view;
      var formatter = (0, util_1.get)(_this.cfg.title, 'formatter');
      var config = (0, util_1.deepMix)({
        position: ['50%', '0%'],
        content: formatter ? formatter(columnValue) : columnValue
      }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
    List.prototype.getPageCount = function (total, pageSize) {
    return Math.floor((total + pageSize - 1) / pageSize);
  };
    List.prototype.getRowCol = function (index, pageSize) {
    var row = Math.floor(index / pageSize);
    var col = index % pageSize;
    return {
      row: row,
      col: col
    };
  };
  return List;
}(facet_2.Facet);
exports.default = List;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var facet_1 = __webpack_require__(116);
var facet_2 = __webpack_require__(105);
var Matrix = function (_super) {
  (0, tslib_1.__extends)(Matrix, _super);
  function Matrix() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Matrix.prototype.getDefaultCfg = function () {
    return (0, util_1.deepMix)({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'matrix',
      showTitle: false,
      columnTitle: (0, tslib_1.__assign)({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: (0, tslib_1.__assign)({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Matrix.prototype.render = function () {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Matrix.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };
  Matrix.prototype.beforeEachView = function (view, facet) {};
  Matrix.prototype.generateFacets = function (data) {
    var _a = this.cfg,
      fields = _a.fields,
      type = _a.type;
    
    var rowValuesLength = fields.length;
    var columnValuesLength = rowValuesLength;
    var rst = [];
    for (var i = 0; i < columnValuesLength; i++) {
      var columnField = fields[i];
      for (var j = 0; j < rowValuesLength; j++) {
        var rowField = fields[j];
        var facet = {
          type: type,
          data: data,
          region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
          columnValue: columnField,
          rowValue: rowField,
          columnField: columnField,
          rowField: rowField,
          columnIndex: i,
          rowIndex: j,
          columnValuesLength: columnValuesLength,
          rowValuesLength: rowValuesLength
        };
        rst.push(facet);
      }
    }
    return rst;
  };
    Matrix.prototype.getXAxisOption = function (x, axes, option, facet) {
    
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        label: null,
        title: null
      });
    }
    return option;
  };
    Matrix.prototype.getYAxisOption = function (y, axes, option, facet) {
    
    if (facet.columnIndex !== 0) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null,
        label: null
      });
    }
    return option;
  };
    Matrix.prototype.renderTitle = function () {
    var _this = this;
    (0, util_1.each)(this.facets, function (facet, facetIndex) {
      var columnIndex = facet.columnIndex,
        rowIndex = facet.rowIndex,
        columnValuesLength = facet.columnValuesLength,
        rowValuesLength = facet.rowValuesLength,
        columnValue = facet.columnValue,
        rowValue = facet.rowValue,
        view = facet.view;
      
      if (rowIndex === 0) {
        var formatter = (0, util_1.get)(_this.cfg.columnTitle, 'formatter');
        var config = (0, util_1.deepMix)({
          position: ['50%', '0%'],
          content: formatter ? formatter(columnValue) : columnValue
        }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      
      if (columnIndex === columnValuesLength - 1) {
        var formatter = (0, util_1.get)(_this.cfg.rowTitle, 'formatter');
        var config = (0, util_1.deepMix)({
          position: ['100%', '50%'],
          content: formatter ? formatter(rowValue) : rowValue
        }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  return Matrix;
}(facet_2.Facet);
exports.default = Matrix;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var facet_1 = __webpack_require__(116);
var facet_2 = __webpack_require__(105);
var Mirror = function (_super) {
  (0, tslib_1.__extends)(Mirror, _super);
  function Mirror() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Mirror.prototype.getDefaultCfg = function () {
    return (0, util_1.deepMix)({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'mirror',
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this),
      transpose: false
    });
  };
  Mirror.prototype.render = function () {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Mirror.prototype.beforeEachView = function (view, facet) {
    
    if (this.cfg.transpose) {
      if (facet.columnIndex % 2 === 0) {
        view.coordinate().transpose().reflect('x');
      } else {
        view.coordinate().transpose();
      }
    } else {
      if (facet.rowIndex % 2 !== 0) {
        view.coordinate().reflect('y');
      }
    }
  };
  Mirror.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };
  Mirror.prototype.generateFacets = function (data) {
    var _this = this;
    var f = this.cfg.fields[0];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [''];
    var rowValues = [''];
    var columnField;
    var rowField;
    if (this.cfg.transpose) {
      columnField = f;
      columnValues = this.getFieldValues(data, columnField).slice(0, 2); // 镜像最多两个
      columnValuesLength = columnValues.length;
    } else {
      rowField = f;
      rowValues = this.getFieldValues(data, rowField).slice(0, 2); // 镜像最多两个
      rowValuesLength = rowValues.length;
    }
    // 获取每个维度对应的数据配置片段
    columnValues.forEach(function (xVal, xIndex) {
      rowValues.forEach(function (yVal, yIndex) {
        var conditions = [{
          field: columnField,
          value: xVal,
          values: columnValues
        }, {
          field: rowField,
          value: yVal,
          values: rowValues
        }];
        var facetData = (0, util_1.filter)(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField: columnField,
          rowField: rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength: columnValuesLength,
          rowValuesLength: rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  /**
   * 设置 x 坐标轴的文本、title 是否显示
   * @param x
   * @param axes
   * @param option
   * @param facet
   */
  Mirror.prototype.getXAxisOption = function (x, axes, option, facet) {
    // 非最后一行
    // 当是最后一行或者下面没有 view 时文本不显示
    if (facet.columnIndex === 1 || facet.rowIndex === 1) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        label: null,
        title: null
      });
    }
    return option;
  };
  /**
   * 设置 y 坐标轴的文本、title 是否显示
   * @param y
   * @param axes
   * @param option
   * @param facet
   */
  Mirror.prototype.getYAxisOption = function (y, axes, option, facet) {
    // do nothing
    return option;
  };
  Mirror.prototype.renderTitle = function () {
    var _this = this;
    (0, util_1.each)(this.facets, function (facet, facetIndex) {
      var columnValue = facet.columnValue,
        rowValue = facet.rowValue,
        view = facet.view;
      var formatter = (0, util_1.get)(_this.cfg.title, 'formatter');
      if (_this.cfg.transpose) {
        var config = (0, util_1.deepMix)({
          position: ['50%', '0%'],
          content: formatter ? formatter(columnValue) : columnValue
        }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      } else {
        var config = (0, util_1.deepMix)({
          position: ['100%', '50%'],
          content: formatter ? formatter(rowValue) : rowValue
        }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.RIGHT), _this.cfg.title);
        view.annotation().text(config);
      }
    });
  };
  return Mirror;
}(facet_2.Facet);
exports.default = Mirror;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var facet_1 = __webpack_require__(116);
var facet_2 = __webpack_require__(105);
var Rect = function (_super) {
  (0, tslib_1.__extends)(Rect, _super);
  function Rect() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };
  Rect.prototype.beforeEachView = function (view, facet) {
    
  };
  Rect.prototype.getDefaultCfg = function () {
    return (0, util_1.deepMix)({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'rect',
      columnTitle: (0, tslib_1.__assign)({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: (0, tslib_1.__assign)({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Rect.prototype.render = function () {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
    Rect.prototype.generateFacets = function (data) {
    var _this = this;
    var _a = this.cfg.fields,
      columnField = _a[0],
      rowField = _a[1];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [''];
    var rowValues = [''];
    if (columnField) {
      columnValues = this.getFieldValues(data, columnField);
      columnValuesLength = columnValues.length;
    }
    if (rowField) {
      rowValues = this.getFieldValues(data, rowField);
      rowValuesLength = rowValues.length;
    }
    // 获取每个维度对应的数据配置片段
    columnValues.forEach(function (xVal, xIndex) {
      rowValues.forEach(function (yVal, yIndex) {
        var conditions = [{
          field: columnField,
          value: xVal,
          values: columnValues
        }, {
          field: rowField,
          value: yVal,
          values: rowValues
        }];
        var facetData = (0, util_1.filter)(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField: columnField,
          rowField: rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength: columnValuesLength,
          rowValuesLength: rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Rect.prototype.renderTitle = function () {
    var _this = this;
    (0, util_1.each)(this.facets, function (facet, facetIndex) {
      var columnIndex = facet.columnIndex,
        rowIndex = facet.rowIndex,
        columnValuesLength = facet.columnValuesLength,
        columnValue = facet.columnValue,
        rowValue = facet.rowValue,
        view = facet.view;
      // top
      if (rowIndex === 0) {
        var formatter = (0, util_1.get)(_this.cfg.columnTitle, 'formatter');
        var config = (0, util_1.deepMix)({
          position: ['50%', '0%'],
          content: formatter ? formatter(columnValue) : columnValue
        }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      
      if (columnIndex === columnValuesLength - 1) {
        var formatter = (0, util_1.get)(_this.cfg.rowTitle, 'formatter');
        var config = (0, util_1.deepMix)({
          position: ['100%', '50%'],
          content: formatter ? formatter(rowValue) : rowValue
        }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
    Rect.prototype.getXAxisOption = function (x, axes, option, facet) {
    
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null,
        label: null
      });
    } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
      
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null
      });
    }
    return option;
  };
    Rect.prototype.getYAxisOption = function (y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null,
        label: null
      });
    } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null
      });
    }
    return option;
  };
  return Rect;
}(facet_2.Facet);
exports.default = Rect;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var facet_1 = __webpack_require__(116);
var facet_2 = __webpack_require__(105);
var Tree = function (_super) {
  (0, tslib_1.__extends)(Tree, _super);
  function Tree() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.afterChartRender = function () {
      if (_this.facets && _this.cfg.line) {
        _this.container.clear();
        _this.drawLines(_this.facets);
      }
    };
    return _this;
  }
  Tree.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };
  Tree.prototype.beforeEachView = function (view, facet) {};
  Tree.prototype.init = function () {
    _super.prototype.init.call(this);
    this.view.on(constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
  };
  Tree.prototype.getDefaultCfg = function () {
    return (0, util_1.deepMix)({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'tree',
      line: {
        style: {
          lineWidth: 1,
          stroke: '#ddd'
        },
        smooth: false
      },
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Tree.prototype.generateFacets = function (data) {
    var fields = this.cfg.fields;
    if (!fields.length) {
      throw new Error('Please specify for the fields for rootFacet!');
    }
    var rst = [];
    var rootFacet = {
      type: this.cfg.type,
      data: data,
      region: null,
      rowValuesLength: this.getRows(),
      columnValuesLength: 1,
      rowIndex: 0,
      columnIndex: 0,
      rowField: '',
      columnField: '',
      rowValue: '',
      columnValue: ''
    };
    rst.push(rootFacet);
    rootFacet.children = this.getChildFacets(data, 1, rst);
    this.setRegion(rst);
    return rst;
  };
  Tree.prototype.setRegion = function (facets) {
    var _this = this;
    this.forceColIndex(facets);
    facets.forEach(function (facet) {
      // @ts-ignore 允许调整
      facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
    });
  };
  Tree.prototype.getRegion = function (rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols; // x轴方向的每个分面的偏移
    var yWidth = 1 / rows; // y轴方向的每个分面的偏移
    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth * 2 / 3 // 预留1/3的空隙，方便添加连接线
    };

    return {
      start: start,
      end: end
    };
  };
  Tree.prototype.forceColIndex = function (facets) {
    var _this = this;
    var leafs = [];
    var index = 0;
    facets.forEach(function (facet) {
      if (_this.isLeaf(facet)) {
        leafs.push(facet);
        // @ts-ignore 允许调整
        facet.columnIndex = index;
        index++;
      }
    });
    leafs.forEach(function (facet) {
      // @ts-ignore
      facet.columnValuesLength = leafs.length;
    });
    var maxLevel = this.cfg.fields.length;
    for (var i = maxLevel - 1; i >= 0; i--) {
      var levelFacets = this.getFacetsByLevel(facets, i);
      // var yIndex = maxLevel - i;
      for (var _i = 0, levelFacets_1 = levelFacets; _i < levelFacets_1.length; _i++) {
        var facet = levelFacets_1[_i];
        if (!this.isLeaf(facet)) {
          facet.originColIndex = facet.columnIndex;
          // @ts-ignore
          facet.columnIndex = this.getRegionIndex(facet.children);
          // @ts-ignore
          facet.columnValuesLength = leafs.length;
        }
      }
    }
  };
  // get facet use level
  Tree.prototype.getFacetsByLevel = function (facets, level) {
    var rst = [];
    facets.forEach(function (facet) {
      if (facet.rowIndex === level) {
        rst.push(facet);
      }
    });
    return rst;
  };
  // if the facet has children , make it's column index in the middle of it's children
  Tree.prototype.getRegionIndex = function (children) {
    var first = children[0];
    var last = children[children.length - 1];
    return (last.columnIndex - first.columnIndex) / 2 + first.columnIndex;
  };
  
  Tree.prototype.isLeaf = function (facet) {
    return !facet.children || !facet.children.length;
  };
  Tree.prototype.getRows = function () {
    return this.cfg.fields.length + 1;
  };
  
  Tree.prototype.getChildFacets = function (data, level, arr) {
    var _this = this;
    
    var fields = this.cfg.fields;
    var length = fields.length;
    if (length < level) {
      return;
    }
    var rst = [];
    
    var field = fields[level - 1];
    
    var values = this.getFieldValues(data, field);
    values.forEach(function (value, index) {
      var conditions = [{
        field: field,
        value: value,
        values: values
      }];
      var subData = data.filter(_this.getFacetDataFilter(conditions));
      if (subData.length) {
        var facet = {
          type: _this.cfg.type,
          data: subData,
          region: null,
          columnValue: value,
          rowValue: '',
          columnField: field,
          rowField: '',
          columnIndex: index,
          rowValuesLength: _this.getRows(),
          columnValuesLength: 1,
          rowIndex: level,
          children: _this.getChildFacets(subData, level + 1, arr)
        };
        rst.push(facet);
        arr.push(facet);
      }
    });
    return rst;
  };
  Tree.prototype.render = function () {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Tree.prototype.renderTitle = function () {
    var _this = this;
    (0, util_1.each)(this.facets, function (facet) {
      var columnValue = facet.columnValue,
        view = facet.view;
      var formatter = (0, util_1.get)(_this.cfg.title, 'formatter');
      var config = (0, util_1.deepMix)({
        position: ['50%', '0%'],
        content: formatter ? formatter(columnValue) : columnValue
      }, (0, facet_1.getFactTitleConfig)(constant_1.DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  Tree.prototype.drawLines = function (facets) {
    var _this = this;
    facets.forEach(function (facet) {
      if (!_this.isLeaf(facet)) {
        var children = facet.children;
        _this.addFacetLines(facet, children);
      }
    });
  };
  
  Tree.prototype.addFacetLines = function (facet, children) {
    var _this = this;
    var view = facet.view;
    var region = view.coordinateBBox;
    
    var start = {
      x: region.x + region.width / 2,
      y: region.y + region.height
    };
    children.forEach(function (subFacet) {
      var subRegion = subFacet.view.coordinateBBox;
      var end = {
        x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
        y: subRegion.tr.y
      };
      var middle1 = {
        x: start.x,
        y: start.y + (end.y - start.y) / 2
      };
      var middle2 = {
        x: end.x,
        y: middle1.y
      };
      _this.drawLine([start, middle1, middle2, end]);
    });
  };
  Tree.prototype.getPath = function (points) {
    var path = [];
    var smooth = this.cfg.line.smooth;
    if (smooth) {
      path.push(['M', points[0].x, points[0].y]);
      path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    } else {
      points.forEach(function (point, index) {
        if (index === 0) {
          path.push(['M', point.x, point.y]);
        } else {
          path.push(['L', point.x, point.y]);
        }
      });
    }
    return path;
  };
  
  Tree.prototype.drawLine = function (points) {
    var path = this.getPath(points);
    var line = this.cfg.line.style;
    this.container.addShape('path', {
      attrs: (0, util_1.assign)({
        
        path: path
      }, line)
    });
  };
  Tree.prototype.getXAxisOption = function (x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null,
        label: null
      });
    }
    return option;
  };
  Tree.prototype.getYAxisOption = function (y, axes, option, facet) {
    if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
      return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, option), {
        title: null,
        label: null
      });
    }
    return option;
  };
  return Tree;
}(facet_2.Facet);
exports.default = Tree;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var dependents_1 = __webpack_require__(69);
var animate_1 = __webpack_require__(97);
var axis_1 = __webpack_require__(265);
var axis_2 = __webpack_require__(265);
var grid_1 = __webpack_require__(1012);
var helper_1 = __webpack_require__(70);
var base_1 = __webpack_require__(104);

var OMIT_CFG = ['container'];

var AXIS_DEFAULT_ANIMATE_CFG = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, animate_1.DEFAULT_ANIMATE_CFG), {
  appear: null
});
var Axis = function (_super) {
  (0, tslib_1.__extends)(Axis, _super);
  function Axis(view) {
    var _this = _super.call(this, view) || this;
        _this.cache = new Map();
    
    _this.gridContainer = _this.view.getLayer(constant_1.LAYER.BG).addGroup();
    _this.gridForeContainer = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    _this.axisContainer = _this.view.getLayer(constant_1.LAYER.BG).addGroup();
    _this.axisForeContainer = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Axis.prototype, "name", {
    get: function get() {
      return 'axis';
    },
    enumerable: false,
    configurable: true
  });
  Axis.prototype.init = function () {};
  Axis.prototype.render = function () {
    this.update();
  };
    Axis.prototype.layout = function () {
    var _this = this;
    var coordinate = this.view.getCoordinate();
    (0, util_1.each)(this.getComponents(), function (co) {
      var component = co.component,
        direction = co.direction,
        type = co.type,
        extra = co.extra;
      var dim = extra.dim,
        scale = extra.scale,
        alignTick = extra.alignTick;
      var updated;
      if (type === constant_1.COMPONENT_TYPE.AXIS) {
        if (coordinate.isPolar) {
          if (dim === 'x') {
            updated = coordinate.isTransposed ? (0, axis_1.getAxisRegion)(coordinate, direction) : (0, axis_1.getCircleAxisCenterRadius)(coordinate);
          } else if (dim === 'y') {
            updated = coordinate.isTransposed ? (0, axis_1.getCircleAxisCenterRadius)(coordinate) : (0, axis_1.getAxisRegion)(coordinate, direction);
          }
        } else {
          updated = (0, axis_1.getAxisRegion)(coordinate, direction);
        }
      } else if (type === constant_1.COMPONENT_TYPE.GRID) {
        if (coordinate.isPolar) {
          var items = void 0;
          if (coordinate.isTransposed) {
            items = dim === 'x' ? (0, grid_1.getCircleGridItems)(coordinate, _this.view.getYScales()[0], scale, alignTick, dim) : (0, grid_1.getLineGridItems)(coordinate, scale, dim, alignTick);
          } else {
            items = dim === 'x' ? (0, grid_1.getLineGridItems)(coordinate, scale, dim, alignTick) : (0, grid_1.getCircleGridItems)(coordinate, _this.view.getXScale(), scale, alignTick, dim);
          }
          updated = {
            items: items,
            
            center: _this.view.getCoordinate().getCenter()
          };
        } else {
          updated = {
            items: (0, grid_1.getLineGridItems)(coordinate, scale, dim, alignTick)
          };
        }
      }
      component.update(updated);
    });
  };
    Axis.prototype.update = function () {
    this.option = this.view.getOptions().axes;
    var updatedCache = new Map();
    this.updateXAxes(updatedCache);
    this.updateYAxes(updatedCache);
    
    
    var newCache = new Map();
    this.cache.forEach(function (co, key) {
      if (updatedCache.has(key)) {
        newCache.set(key, co);
      } else {
        
        co.component.destroy();
      }
    });
    
    this.cache = newCache;
  };
  Axis.prototype.clear = function () {
    _super.prototype.clear.call(this);
    this.cache.clear();
    this.gridContainer.clear();
    this.gridForeContainer.clear();
    this.axisContainer.clear();
    this.axisForeContainer.clear();
  };
  Axis.prototype.destroy = function () {
    _super.prototype.destroy.call(this);
    this.gridContainer.remove(true);
    this.gridForeContainer.remove(true);
    this.axisContainer.remove(true);
    this.axisForeContainer.remove(true);
  };
    Axis.prototype.getComponents = function () {
    var co = [];
    this.cache.forEach(function (value) {
      co.push(value);
    });
    return co;
  };
    Axis.prototype.updateXAxes = function (updatedCache) {
    
    var scale = this.view.getXScale();
    if (!scale || scale.isIdentity) {
      return;
    }
    var xAxisOption = (0, axis_2.getAxisOption)(this.option, scale.field);
    if (xAxisOption === false) {
      return;
    }
    var direction = (0, axis_1.getAxisDirection)(xAxisOption, constant_1.DIRECTION.BOTTOM);
    var layer = constant_1.LAYER.BG;
    var dim = 'x';
    var coordinate = this.view.getCoordinate();
    var axisId = this.getId('axis', scale.field);
    var gridId = this.getId('grid', scale.field);
    if (coordinate.isRect) {
      
      var axis = this.cache.get(axisId);
      
      if (axis) {
        var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);
        (0, helper_1.omit)(cfg, OMIT_CFG);
        axis.component.update(cfg);
        updatedCache.set(axisId, axis);
      } else {
        
        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);
        this.cache.set(axisId, axis);
        updatedCache.set(axisId, axis);
      }
      
      var grid = this.cache.get(gridId);
      
      if (grid) {
        var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);
        (0, helper_1.omit)(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        
        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else if (coordinate.isPolar) {
      
      var axis = this.cache.get(axisId);
      
      if (axis) {
        var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale, xAxisOption, constant_1.DIRECTION.RADIUS) : this.getCircleAxisCfg(scale, xAxisOption, direction);
        (0, helper_1.omit)(cfg, OMIT_CFG);
        axis.component.update(cfg);
        updatedCache.set(axisId, axis);
      } else {
        
        if (coordinate.isTransposed) {
          if ((0, util_1.isUndefined)(xAxisOption)) {
            
            return;
          } else {
            
            
            axis = this.createLineAxis(scale, xAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
          }
        } else {
          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);
        }
        this.cache.set(axisId, axis);
        updatedCache.set(axisId, axis);
      }
      
      var grid = this.cache.get(gridId);
      
      if (grid) {
        var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale, xAxisOption, constant_1.DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale, xAxisOption, constant_1.DIRECTION.CIRCLE, dim);
        (0, helper_1.omit)(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        
        if (coordinate.isTransposed) {
          if ((0, util_1.isUndefined)(xAxisOption)) {
            return;
          } else {
            grid = this.createCircleGrid(scale, xAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
          }
        } else {
          
          grid = this.createLineGrid(scale, xAxisOption, layer, constant_1.DIRECTION.CIRCLE, dim);
        }
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else {
      
    }
  };
  Axis.prototype.updateYAxes = function (updatedCache) {
    var _this = this;
    
    var yScales = this.view.getYScales();
    (0, util_1.each)(yScales, function (scale, idx) {
      
      if (!scale || scale.isIdentity) {
        return;
      }
      var field = scale.field;
      var yAxisOption = (0, axis_2.getAxisOption)(_this.option, field);
      if (yAxisOption !== false) {
        var layer = constant_1.LAYER.BG;
        var dim = 'y';
        var axisId = _this.getId('axis', field);
        var gridId = _this.getId('grid', field);
        var coordinate = _this.view.getCoordinate();
        if (coordinate.isRect) {
          var direction = (0, axis_1.getAxisDirection)(yAxisOption, idx === 0 ? constant_1.DIRECTION.LEFT : constant_1.DIRECTION.RIGHT);
          
          var axis = _this.cache.get(axisId);
          
          if (axis) {
            var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);
            (0, helper_1.omit)(cfg, OMIT_CFG);
            axis.component.update(cfg);
            updatedCache.set(axisId, axis);
          } else {
            
            axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);
            _this.cache.set(axisId, axis);
            updatedCache.set(axisId, axis);
          }
          
          var grid = _this.cache.get(gridId);
          
          if (grid) {
            var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);
            (0, helper_1.omit)(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            
            grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else if (coordinate.isPolar) {
          
          var axis = _this.cache.get(axisId);
          
          if (axis) {
            var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale, yAxisOption, constant_1.DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale, yAxisOption, constant_1.DIRECTION.RADIUS);
            
            (0, helper_1.omit)(cfg, OMIT_CFG);
            axis.component.update(cfg);
            updatedCache.set(axisId, axis);
          } else {
            
            if (coordinate.isTransposed) {
              if ((0, util_1.isUndefined)(yAxisOption)) {
                return;
              } else {
                axis = _this.createCircleAxis(scale, yAxisOption, layer, constant_1.DIRECTION.CIRCLE, dim);
              }
            } else {
              axis = _this.createLineAxis(scale, yAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
            }
            _this.cache.set(axisId, axis);
            updatedCache.set(axisId, axis);
          }
          
          var grid = _this.cache.get(gridId);
          
          if (grid) {
            var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale, yAxisOption, constant_1.DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale, yAxisOption, constant_1.DIRECTION.RADIUS, dim);
            (0, helper_1.omit)(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            
            if (coordinate.isTransposed) {
              if ((0, util_1.isUndefined)(yAxisOption)) {
                return;
              } else {
                grid = _this.createLineGrid(scale, yAxisOption, layer, constant_1.DIRECTION.CIRCLE, dim);
              }
            } else {
              grid = _this.createCircleGrid(scale, yAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
            }
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else {
          
        }
      }
    });
  };
    Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {
    
    var axis = {
      component: new dependents_1.LineAxis(this.getLineAxisCfg(scale, option, direction)),
      layer: layer,
      direction: direction === constant_1.DIRECTION.RADIUS ? constant_1.DIRECTION.NONE : direction,
      type: constant_1.COMPONENT_TYPE.AXIS,
      extra: {
        dim: dim,
        scale: scale
      }
    };
    axis.component.set('field', scale.field);
    axis.component.init();
    return axis;
  };
  Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {
    var cfg = this.getLineGridCfg(scale, option, direction, dim);
    if (cfg) {
      var grid = {
        component: new dependents_1.LineGrid(cfg),
        layer: layer,
        direction: constant_1.DIRECTION.NONE,
        type: constant_1.COMPONENT_TYPE.GRID,
        extra: {
          dim: dim,
          scale: scale,
          alignTick: (0, util_1.get)(cfg, 'alignTick', true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {
    var axis = {
      component: new dependents_1.CircleAxis(this.getCircleAxisCfg(scale, option, direction)),
      layer: layer,
      direction: direction,
      type: constant_1.COMPONENT_TYPE.AXIS,
      extra: {
        dim: dim,
        scale: scale
      }
    };
    axis.component.set('field', scale.field);
    axis.component.init();
    return axis;
  };
  Axis.prototype.createCircleGrid = function (scale, option, layer, direction, dim) {
    var cfg = this.getCircleGridCfg(scale, option, direction, dim);
    if (cfg) {
      var grid = {
        component: new dependents_1.CircleGrid(cfg),
        layer: layer,
        direction: constant_1.DIRECTION.NONE,
        type: constant_1.COMPONENT_TYPE.GRID,
        extra: {
          dim: dim,
          scale: scale,
          alignTick: (0, util_1.get)(cfg, 'alignTick', true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
    Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {
    var container = (0, util_1.get)(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;
    var coordinate = this.view.getCoordinate();
    var region = (0, axis_1.getAxisRegion)(coordinate, direction);
    var titleText = (0, axis_1.getAxisTitleText)(scale, axisOption);
    var axisThemeCfg = (0, axis_1.getAxisThemeCfg)(this.view.getTheme(), direction);
    
    var optionWithTitle = (0, util_1.get)(axisOption, ['title']) ? (0, util_1.deepMix)({
      title: {
        style: {
          text: titleText
        }
      }
    }, {
      title: (0, axis_1.getAxisTitleOptions)(this.view.getTheme(), direction, axisOption.title)
    }, axisOption) : axisOption;
    var cfg = (0, util_1.deepMix)((0, tslib_1.__assign)((0, tslib_1.__assign)({
      container: container
    }, region), {
      ticks: scale.getTicks().map(function (tick) {
        return {
          id: "" + tick.tickValue,
          name: tick.text,
          value: tick.value
        };
      }),
      verticalFactor: coordinate.isPolar ? (0, axis_1.getAxisFactorByRegion)(region, coordinate.getCenter()) * -1 : (0, axis_1.getAxisFactorByRegion)(region, coordinate.getCenter()),
      theme: axisThemeCfg
    }), axisThemeCfg, optionWithTitle);
    var _a = this.getAnimateCfg(cfg),
      animate = _a.animate,
      animateOption = _a.animateOption;
    cfg.animateOption = animateOption;
    cfg.animate = animate;
    // 计算 verticalLimitLength
    var isAxisVertical = (0, axis_1.isVertical)(region);
    // TODO: 1 / 3 等默认值需要有一个全局的配置的地方
    var verticalLimitLength = (0, util_1.get)(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);
    if (verticalLimitLength <= 1) {
      // 配置的相对值，相对于画布
      var canvasWidth = this.view.getCanvas().get('width');
      var canvasHeight = this.view.getCanvas().get('height');
      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
    }
    return cfg;
  };
  /**
   * generate line grid cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @param dim
   * @return line grid cfg
   */
  Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {
    if (!(0, grid_1.showGrid)((0, axis_1.getAxisThemeCfg)(this.view.getTheme(), direction), axisOption)) {
      return undefined;
    }
    var gridThemeCfg = (0, grid_1.getGridThemeCfg)(this.view.getTheme(), direction);
    // the cfg order should be ensure
    // grid 动画以 axis 为准
    var gridCfg = (0, util_1.deepMix)({
      container: (0, util_1.get)(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer
    }, gridThemeCfg, (0, util_1.get)(axisOption, 'grid'), this.getAnimateCfg(axisOption));
    gridCfg.items = (0, grid_1.getLineGridItems)(this.view.getCoordinate(), scale, dim, (0, util_1.get)(gridCfg, 'alignTick', true));
    return gridCfg;
  };
  /**
   * generate circle axis cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @return circle axis cfg
   */
  Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {
    var container = (0, util_1.get)(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;
    var coordinate = this.view.getCoordinate();
    var ticks = scale.getTicks().map(function (tick) {
      return {
        id: "" + tick.tickValue,
        name: tick.text,
        value: tick.value
      };
    });
    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
      // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本
      ticks.pop();
    }
    var titleText = (0, axis_1.getAxisTitleText)(scale, axisOption);
    var axisThemeCfg = (0, axis_1.getAxisThemeCfg)(this.view.getTheme(), constant_1.DIRECTION.CIRCLE);
    // the cfg order should be ensure
    var optionWithTitle = (0, util_1.get)(axisOption, ['title']) ? (0, util_1.deepMix)({
      title: {
        style: {
          text: titleText
        }
      }
    }, {
      title: (0, axis_1.getAxisTitleOptions)(this.view.getTheme(), direction, axisOption.title)
    }, axisOption) : axisOption;
    var cfg = (0, util_1.deepMix)((0, tslib_1.__assign)((0, tslib_1.__assign)({
      container: container
    }, (0, axis_1.getCircleAxisCenterRadius)(this.view.getCoordinate())), {
      ticks: ticks,
      verticalFactor: 1,
      theme: axisThemeCfg
    }), axisThemeCfg, optionWithTitle);
    var _a = this.getAnimateCfg(cfg),
      animate = _a.animate,
      animateOption = _a.animateOption;
    cfg.animate = animate;
    cfg.animateOption = animateOption;
    return cfg;
  };
  /**
   * generate circle grid cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @return circle grid cfg
   */
  Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction, dim) {
    if (!(0, grid_1.showGrid)((0, axis_1.getAxisThemeCfg)(this.view.getTheme(), direction), axisOption)) {
      return undefined;
    }
    // the cfg order should be ensure
    // grid 动画以 axis 为准
    var gridThemeCfg = (0, grid_1.getGridThemeCfg)(this.view.getTheme(), constant_1.DIRECTION.RADIUS);
    var gridCfg = (0, util_1.deepMix)({
      container: (0, util_1.get)(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,
      center: this.view.getCoordinate().getCenter()
    }, gridThemeCfg, (0, util_1.get)(axisOption, 'grid'), this.getAnimateCfg(axisOption));
    var alignTick = (0, util_1.get)(gridCfg, 'alignTick', true);
    var verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();
    gridCfg.items = (0, grid_1.getCircleGridItems)(this.view.getCoordinate(), verticalScale, scale, alignTick, dim);
    // the cfg order should be ensure
    // grid 动画以 axis 为准
    return gridCfg;
  };
  Axis.prototype.getId = function (name, key) {
    var coordinate = this.view.getCoordinate();
    // 坐标系类型也作为组件的 key
    return name + "-" + key + "-" + coordinate.type;
  };
  Axis.prototype.getAnimateCfg = function (cfg) {
    return {
      animate: this.view.getOptions().animate && (0, util_1.get)(cfg, 'animate'),
      animateOption: cfg && cfg.animateOption ? (0, util_1.deepMix)({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
    };
  };
  return Axis;
}(base_1.Controller);
exports.default = Axis;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var dependents_1 = __webpack_require__(69);
var animate_1 = __webpack_require__(97);
var bbox_1 = __webpack_require__(80);
var direction_1 = __webpack_require__(282);
var helper_1 = __webpack_require__(70);
var legend_1 = __webpack_require__(452);
var scale_1 = __webpack_require__(111);
var base_1 = __webpack_require__(104);
function getLegendOption(legends, field) {
  if ((0, util_1.isBoolean)(legends)) {
    return legends === false ? false : {};
  }
  return (0, util_1.get)(legends, [field], legends);
}
function getDirection(legendOption) {
  return (0, util_1.get)(legendOption, 'position', constant_1.DIRECTION.BOTTOM);
}
var Legend = function (_super) {
  (0, tslib_1.__extends)(Legend, _super);
  function Legend(view) {
    var _this = _super.call(this, view) || this;
    _this.container = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Legend.prototype, "name", {
    get: function get() {
      return 'legend';
    },
    enumerable: false,
    configurable: true
  });
  Legend.prototype.init = function () {};
    Legend.prototype.render = function () {
    
    this.update();
  };
    Legend.prototype.layout = function () {
    var _this = this;
    this.layoutBBox = this.view.viewBBox;
    (0, util_1.each)(this.components, function (co) {
      var component = co.component,
        direction = co.direction;
      var layout = (0, legend_1.getLegendLayout)(direction);
      var maxWidthRatio = component.get('maxWidthRatio');
      var maxHeightRatio = component.get('maxHeightRatio');
      var maxSize = _this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
      var maxWidth = component.get('maxWidth');
      var maxHeight = component.get('maxHeight');
      
      component.update({
        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
      });
      var padding = component.get('padding');
      var bboxObject = component.getLayoutBBox(); 
      var bbox = new bbox_1.BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);
      var _a = (0, direction_1.directionToPosition)(_this.view.viewBBox, bbox, direction),
        x1 = _a[0],
        y1 = _a[1];
      var _b = (0, direction_1.directionToPosition)(_this.layoutBBox, bbox, direction),
        x2 = _b[0],
        y2 = _b[1];
      var x = 0;
      var y = 0;
      
      if (direction.startsWith('top') || direction.startsWith('bottom')) {
        x = x1;
        y = y2;
      } else {
        x = x2;
        y = y1;
      }
      
      component.setLocation({
        x: x + padding[3],
        y: y + padding[0]
      });
      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction);
    });
  };
    Legend.prototype.update = function () {
    var _this = this;
    this.option = this.view.getOptions().legends;
    
    var updated = {};
    var eachLegend = function eachLegend(geometry, attr, scale) {
      var id = _this.getId(scale.field);
      var existCo = _this.getComponentById(id);
      
      if (existCo) {
        var cfg = void 0;
        var legendOption = getLegendOption(_this.option, scale.field);
        
        if (legendOption !== false) {
          if ((0, util_1.get)(legendOption, 'custom')) {
            cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption, true);
          } else {
            if (scale.isLinear) {
              
              cfg = _this.getContinuousCfg(geometry, attr, scale, legendOption);
            } else if (scale.isCategory) {
              
              cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption);
            }
          }
        }
        
        if (cfg) {
          
          (0, helper_1.omit)(cfg, ['container']);
          existCo.direction = getDirection(legendOption);
          existCo.component.update(cfg);
          
          updated[id] = true;
        }
      } else {
        
        var legend = _this.createFieldLegend(geometry, attr, scale);
        if (legend) {
          legend.component.init();
          _this.components.push(legend);
          
          updated[id] = true;
        }
      }
    };
    
    if ((0, util_1.get)(this.option, 'custom')) {
      var id = 'global-custom';
      var existCo = this.getComponentById(id);
      if (existCo) {
        var customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);
        (0, helper_1.omit)(customCfg, ['container']);
        existCo.component.update(customCfg);
        updated[id] = true;
      } else {
        var component = this.createCustomLegend(undefined, undefined, undefined, this.option);
        if (component) {
          component.init();
          var layer = constant_1.LAYER.FORE;
          var direction = getDirection(this.option);
          this.components.push({
            id: id,
            component: component,
            layer: layer,
            direction: direction,
            type: constant_1.COMPONENT_TYPE.LEGEND,
            extra: undefined
          });
          
          updated[id] = true;
        }
      }
    } else {
      
      this.loopLegends(eachLegend);
    }
    
    
    var components = [];
    (0, util_1.each)(this.getComponents(), function (co) {
      if (updated[co.id]) {
        components.push(co);
      } else {
        co.component.destroy();
      }
    });
    
    this.components = components;
  };
  Legend.prototype.clear = function () {
    _super.prototype.clear.call(this);
    this.container.clear();
  };
  Legend.prototype.destroy = function () {
    _super.prototype.destroy.call(this);
    this.container.remove(true);
  };
    Legend.prototype.getGeometries = function (view) {
    var _this = this;
    var geometries = view.geometries;
    (0, util_1.each)(view.views, function (v) {
      geometries = geometries.concat(_this.getGeometries(v));
    });
    return geometries;
  };
    Legend.prototype.loopLegends = function (doEach) {
    var isRootView = this.view.getRootView() === this.view;
    
    if (!isRootView) {
      return;
    }
    
    var geometries = this.getGeometries(this.view);
    var looped = {}; 
    (0, util_1.each)(geometries, function (geometry) {
      var attributes = geometry.getGroupAttributes();
      (0, util_1.each)(attributes, function (attr) {
        var scale = attr.getScale(attr.type);
        
        if (!scale || scale.type === 'identity' || looped[scale.field]) {
          return;
        }
        doEach(geometry, attr, scale);
        looped[scale.field] = true;
      });
    });
  };
    Legend.prototype.createFieldLegend = function (geometry, attr, scale) {
    var component;
    var legendOption = getLegendOption(this.option, scale.field);
    var layer = constant_1.LAYER.FORE;
    var direction = getDirection(legendOption);
    
    if (legendOption !== false) {
      if ((0, util_1.get)(legendOption, 'custom')) {
        component = this.createCustomLegend(geometry, attr, scale, legendOption);
      } else {
        if (scale.isLinear) {
          
          component = this.createContinuousLegend(geometry, attr, scale, legendOption);
        } else if (scale.isCategory) {
          
          component = this.createCategoryLegend(geometry, attr, scale, legendOption);
        }
      }
    }
    if (component) {
      component.set('field', scale.field);
      return {
        id: this.getId(scale.field),
        component: component,
        layer: layer,
        direction: direction,
        type: constant_1.COMPONENT_TYPE.LEGEND,
        extra: {
          scale: scale
        }
      };
    }
  };
    Legend.prototype.createCustomLegend = function (geometry, attr, scale, legendOption) {
    
    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);
    return new dependents_1.CategoryLegend(cfg);
  };
    Legend.prototype.createContinuousLegend = function (geometry, attr, scale, legendOption) {
    var cfg = this.getContinuousCfg(geometry, attr, scale, (0, helper_1.omit)(legendOption, ['value']));
    return new dependents_1.ContinuousLegend(cfg);
  };
    Legend.prototype.createCategoryLegend = function (geometry, attr, scale, legendOption) {
    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);
    return new dependents_1.CategoryLegend(cfg);
  };
    Legend.prototype.getContinuousCfg = function (geometry, attr, scale, legendOption) {
    var ticks = scale.getTicks();
    var containMin = (0, util_1.find)(ticks, function (tick) {
      return tick.value === 0;
    });
    var containMax = (0, util_1.find)(ticks, function (tick) {
      return tick.value === 1;
    });
    var items = ticks.map(function (tick) {
      var value = tick.value,
        tickValue = tick.tickValue;
      var attrValue = attr.mapping(scale.invert(value)).join('');
      return {
        value: tickValue,
        attrValue: attrValue,
        color: attrValue,
        scaleValue: value
      };
    });
    if (!containMin) {
      items.push({
        value: scale.min,
        attrValue: attr.mapping(scale.invert(0)).join(''),
        color: attr.mapping(scale.invert(0)).join(''),
        scaleValue: 0
      });
    }
    if (!containMax) {
      items.push({
        value: scale.max,
        attrValue: attr.mapping(scale.invert(1)).join(''),
        color: attr.mapping(scale.invert(1)).join(''),
        scaleValue: 1
      });
    }
    // 排序
    items.sort(function (a, b) {
      return a.value - b.value;
    });
    // 跟 attr 相关的配置
    // size color 区别的配置
    var attrLegendCfg = {
      min: (0, util_1.head)(items).value,
      max: (0, util_1.last)(items).value,
      colors: [],
      rail: {
        type: attr.type
      },
      track: {}
    };
    if (attr.type === 'size') {
      attrLegendCfg.track = {
        style: {
          
          
          fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined
        }
      };
    }
    if (attr.type === 'color') {
      attrLegendCfg.colors = items.map(function (item) {
        return item.attrValue;
      });
    }
    var container = this.container;
    
    var direction = getDirection(legendOption);
    var layout = (0, legend_1.getLegendLayout)(direction);
    var title = (0, util_1.get)(legendOption, 'title');
    if (title) {
      title = (0, util_1.deepMix)({
        text: (0, scale_1.getName)(scale)
      }, title);
    }
    
    attrLegendCfg.container = container;
    attrLegendCfg.layout = layout;
    attrLegendCfg.title = title;
    attrLegendCfg.animateOption = animate_1.DEFAULT_ANIMATE_CFG;
    
    return this.mergeLegendCfg(attrLegendCfg, legendOption, 'continuous');
  };
    Legend.prototype.getCategoryCfg = function (geometry, attr, scale, legendOption, custom) {
    var container = this.container;
    
    var direction = (0, util_1.get)(legendOption, 'position', constant_1.DIRECTION.BOTTOM);
    var legendTheme = (0, legend_1.getLegendThemeCfg)(this.view.getTheme(), direction);
    
    var themeMarker = (0, util_1.get)(legendTheme, ['marker']);
    var userMarker = (0, util_1.get)(legendOption, 'marker');
    var layout = (0, legend_1.getLegendLayout)(direction);
    var themePageNavigator = (0, util_1.get)(legendTheme, ['pageNavigator']);
    var userPageNavigator = (0, util_1.get)(legendOption, 'pageNavigator');
    var items = custom ? (0, legend_1.getCustomLegendItems)(themeMarker, userMarker, legendOption.items) : (0, legend_1.getLegendItems)(this.view, geometry, attr, themeMarker, userMarker);
    var title = (0, util_1.get)(legendOption, 'title');
    if (title) {
      title = (0, util_1.deepMix)({
        text: scale ? (0, scale_1.getName)(scale) : ''
      }, title);
    }
    var maxWidthRatio = (0, util_1.get)(legendOption, 'maxWidthRatio');
    var maxHeightRatio = (0, util_1.get)(legendOption, 'maxHeightRatio');
    var baseCfg = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
    baseCfg.container = container;
    baseCfg.layout = layout;
    baseCfg.items = items;
    baseCfg.title = title;
    baseCfg.animateOption = animate_1.DEFAULT_ANIMATE_CFG;
    baseCfg.pageNavigator = (0, util_1.deepMix)({}, themePageNavigator, userPageNavigator);
    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);
    if (categoryCfg.reversed) {
      
      categoryCfg.items.reverse();
    }
    var maxItemWidth = (0, util_1.get)(categoryCfg, 'maxItemWidth');
    if (maxItemWidth && maxItemWidth <= 1) {
      
      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
    }
    return categoryCfg;
  };
    Legend.prototype.mergeLegendCfg = function (baseCfg, legendOption, direction) {
    var position = direction.split('-')[0];
    var themeObject = (0, legend_1.getLegendThemeCfg)(this.view.getTheme(), position);
    return (0, util_1.deepMix)({}, themeObject, baseCfg, legendOption);
  };
    Legend.prototype.getId = function (key) {
    return this.name + "-" + key;
  };
    Legend.prototype.getComponentById = function (id) {
    return (0, util_1.find)(this.components, function (co) {
      return co.id === id;
    });
  };
  Legend.prototype.getCategoryLegendSizeCfg = function (layout, maxWidthRatio, maxHeightRatio) {
    if (maxWidthRatio === void 0) {
      maxWidthRatio = constant_1.COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    if (maxHeightRatio === void 0) {
      maxHeightRatio = constant_1.COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    var _a = this.view.viewBBox,
      vw = _a.width,
      vh = _a.height;
    
    
    return layout === 'vertical' ? {
      maxWidth: vw * maxWidthRatio,
      maxHeight: vh
    } : {
      maxWidth: vw,
      maxHeight: vh * maxHeightRatio
    };
  };
  return Legend;
}(base_1.Controller);
exports.default = Legend;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var dependents_1 = __webpack_require__(69);
var bbox_1 = __webpack_require__(80);
var direction_1 = __webpack_require__(282);
var helper_1 = __webpack_require__(70);
var base_1 = __webpack_require__(104);
var Slider = function (_super) {
  (0, tslib_1.__extends)(Slider, _super);
  function Slider(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = util_1.noop;
        _this.resetMeasure = function () {
      _this.clear();
    };
        _this.onValueChange = function (v) {
      var min = v[0],
        max = v[1];
      _this.start = min;
      _this.end = max;
      _this.changeViewData(min, max);
    };
    _this.container = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    _this.onChangeFn = (0, util_1.throttle)(_this.onValueChange, 20, {
      leading: true
    });
    _this.width = 0;
    _this.view.on(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Slider.prototype, "name", {
    get: function get() {
      return 'slider';
    },
    enumerable: false,
    configurable: true
  });
  Slider.prototype.destroy = function () {
    _super.prototype.destroy.call(this);
    this.view.off(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
    Slider.prototype.init = function () {};
    Slider.prototype.render = function () {
    this.option = this.view.getOptions().slider;
    var _a = this.getSliderCfg(),
      start = _a.start,
      end = _a.end;
    if ((0, util_1.isNil)(this.start)) {
      this.start = start;
      this.end = end;
    }
    var viewData = this.view.getOptions().data;
    if (this.option && !(0, util_1.isEmpty)(viewData)) {
      if (this.slider) {
        
        this.slider = this.updateSlider();
      } else {
        
        this.slider = this.createSlider();
        
        this.slider.component.on('sliderchange', this.onChangeFn);
      }
    } else {
      if (this.slider) {
        
        this.slider.component.destroy();
        this.slider = undefined;
      } else {
        
      }
    }
  };
    Slider.prototype.layout = function () {
    var _this = this;
    if (this.option && !this.width) {
      this.measureSlider();
      setTimeout(function () {
        
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.start, _this.end);
        }
      }, 0);
    }
    if (this.slider) {
      var width = this.view.coordinateBBox.width;
      
      var padding = this.slider.component.get('padding');
      var paddingTop = padding[0],
        paddingRight = padding[1],
        paddingBottom = padding[2],
        paddingLeft = padding[3];
      var bboxObject = this.slider.component.getLayoutBBox();
      var bbox = new bbox_1.BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
      var _a = this.getMinMaxText(this.start, this.end),
        minText = _a.minText,
        maxText = _a.maxText;
      var _b = (0, direction_1.directionToPosition)(this.view.viewBBox, bbox, constant_1.DIRECTION.BOTTOM),
        x1 = _b[0],
        y1 = _b[1];
      var _c = (0, direction_1.directionToPosition)(this.view.coordinateBBox, bbox, constant_1.DIRECTION.BOTTOM),
        x2 = _c[0],
        y2 = _c[1];
      
      this.slider.component.update((0, tslib_1.__assign)((0, tslib_1.__assign)({}, this.getSliderCfg()), {
        x: x2 + paddingLeft,
        y: y1 + paddingTop,
        width: this.width,
        start: this.start,
        end: this.end,
        minText: minText,
        maxText: maxText
      }));
      this.view.viewBBox = this.view.viewBBox.cut(bbox, constant_1.DIRECTION.BOTTOM);
    }
  };
    Slider.prototype.update = function () {
    
    this.render();
  };
    Slider.prototype.createSlider = function () {
    var cfg = this.getSliderCfg();
    
    var component = new dependents_1.Slider((0, tslib_1.__assign)({
      container: this.container
    }, cfg));
    component.init();
    return {
      component: component,
      layer: constant_1.LAYER.FORE,
      direction: constant_1.DIRECTION.BOTTOM,
      type: constant_1.COMPONENT_TYPE.SLIDER
    };
  };
    Slider.prototype.updateSlider = function () {
    var cfg = this.getSliderCfg();
    if (this.width) {
      var _a = this.getMinMaxText(this.start, this.end),
        minText = _a.minText,
        maxText = _a.maxText;
      cfg = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cfg), {
        width: this.width,
        start: this.start,
        end: this.end,
        minText: minText,
        maxText: maxText
      });
    }
    this.slider.component.update(cfg);
    return this.slider;
  };
    Slider.prototype.measureSlider = function () {
    var width = this.getSliderCfg().width;
    this.width = width;
  };
    Slider.prototype.getSliderCfg = function () {
    var cfg = {
      height: 16,
      start: 0,
      end: 1,
      minText: '',
      maxText: '',
      x: 0,
      y: 0,
      width: this.view.coordinateBBox.width
    };
    if ((0, util_1.isObject)(this.option)) {
      // 用户配置的数据，优先级更高
      var trendCfg = (0, tslib_1.__assign)({
        data: this.getData()
      }, (0, util_1.get)(this.option, 'trendCfg', {}));
      
      cfg = (0, util_1.deepMix)({}, cfg, this.getThemeOptions(), this.option);
      
      cfg = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cfg), {
        trendCfg: trendCfg
      });
    }
    cfg.start = (0, util_1.clamp)(Math.min((0, util_1.isNil)(cfg.start) ? 0 : cfg.start, (0, util_1.isNil)(cfg.end) ? 1 : cfg.end), 0, 1);
    cfg.end = (0, util_1.clamp)(Math.max((0, util_1.isNil)(cfg.start) ? 0 : cfg.start, (0, util_1.isNil)(cfg.end) ? 1 : cfg.end), 0, 1);
    return cfg;
  };
    Slider.prototype.getData = function () {
    var data = this.view.getOptions().data;
    var yScale = this.view.getYScales()[0];
    var groupScales = this.view.getGroupScales();
    if (groupScales.length) {
      var _a = groupScales[0],
        field_1 = _a.field,
        ticks_1 = _a.ticks;
      return data.reduce(function (pre, cur) {
        if (cur[field_1] === ticks_1[0]) {
          pre.push(cur[yScale.field]);
        }
        return pre;
      }, []);
    }
    return data.map(function (datum) {
      return datum[yScale.field] || 0;
    });
  };
    Slider.prototype.getThemeOptions = function () {
    var theme = this.view.getTheme();
    return (0, util_1.get)(theme, ['components', 'slider', 'common'], {});
  };
    Slider.prototype.getMinMaxText = function (min, max) {
    var data = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var isHorizontal = true;
    var values = (0, util_1.valuesOfKey)(data, xScale.field);
    var xValues = isHorizontal ? values : values.reverse();
    var dataSize = (0, util_1.size)(data);
    if (!xScale || !dataSize) {
      return {}; 
    }

    var xTickCount = (0, util_1.size)(xValues);
    var minIndex = Math.floor(min * (xTickCount - 1));
    var maxIndex = Math.floor(max * (xTickCount - 1));
    var minText = (0, util_1.get)(xValues, [minIndex]);
    var maxText = (0, util_1.get)(xValues, [maxIndex]);
    var formatter = this.getSliderCfg().formatter;
    if (formatter) {
      minText = formatter(minText, data[minIndex], minIndex);
      maxText = formatter(maxText, data[maxIndex], maxIndex);
    }
    return {
      minText: minText,
      maxText: maxText
    };
  };
    Slider.prototype.changeViewData = function (min, max) {
    var data = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var dataSize = (0, util_1.size)(data);
    if (!xScale || !dataSize) {
      return;
    }
    var isHorizontal = true;
    var values = (0, util_1.valuesOfKey)(data, xScale.field);
    var xValues = isHorizontal ? values : values.reverse();
    var xTickCount = (0, util_1.size)(xValues);
    var minIndex = Math.floor(min * (xTickCount - 1));
    var maxIndex = Math.floor(max * (xTickCount - 1));
    
    this.view.filter(xScale.field, function (value, datum) {
      var idx = xValues.indexOf(value);
      return idx > -1 ? (0, helper_1.isBetween)(idx, minIndex, maxIndex) : true;
    });
    this.view.render(true);
  };
    Slider.prototype.getComponents = function () {
    return this.slider ? [this.slider] : [];
  };
    Slider.prototype.clear = function () {
    if (this.slider) {
      this.slider.component.destroy();
      this.slider = undefined;
    }
    this.width = 0;
    this.start = undefined;
    this.end = undefined;
  };
  return Slider;
}(base_1.Controller);
exports.default = Slider;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getItemsOfView = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var tooltip_1 = __webpack_require__(186);
var graphics_1 = __webpack_require__(46);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var DEFAULT_REGION_PATH_STYLE = {
  fill: '#CCD6EC',
  opacity: 0.3
};
function getItemsOfView(view, point, tooltipCfg) {
  var items = (0, tooltip_1.findItemsFromViewRecurisive)(view, point, tooltipCfg);
  if (items.length) {
    
    items = (0, util_1.flatten)(items);
    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
      var itemArr = items_1[_i];
      for (var _a = 0, itemArr_1 = itemArr; _a < itemArr_1.length; _a++) {
        var item = itemArr_1[_a];
        var _b = item.mappingData,
          x = _b.x,
          y = _b.y;
        item.x = (0, util_1.isArray)(x) ? x[x.length - 1] : x;
        item.y = (0, util_1.isArray)(y) ? y[y.length - 1] : y;
      }
    }
    var shared = tooltipCfg.shared;
    
    if (shared === false && items.length > 1) {
      var snapItem = items[0];
      var min = Math.abs(point.y - snapItem[0].y);
      for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
        var aItem = items_2[_c];
        var yDistance = Math.abs(point.y - aItem[0].y);
        if (yDistance <= min) {
          snapItem = aItem;
          min = yDistance;
        }
      }
      items = [snapItem];
    }
    return (0, util_1.uniq)((0, util_1.flatten)(items));
  }
  return [];
}
exports.getItemsOfView = getItemsOfView;
var ActiveRegion = function (_super) {
  (0, tslib_1.__extends)(ActiveRegion, _super);
  function ActiveRegion() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
    ActiveRegion.prototype.show = function (args) {
    var view = this.context.view;
    var ev = this.context.event;
    var tooltipCfg = view.getController('tooltip').getTooltipCfg();
    var tooltipItems = getItemsOfView(view, {
      x: ev.x,
      y: ev.y
    }, tooltipCfg);
    if ((0, util_1.isEqual)(tooltipItems, this.items)) {
      
      return;
    }
    this.items = tooltipItems;
    if (tooltipItems.length) {
      var xField_1 = view.getXScale().field;
      var xValue_1 = tooltipItems[0].data[xField_1];
      
      var elements_1 = [];
      var geometries = view.geometries;
      (0, util_1.each)(geometries, function (geometry) {
        if (geometry.type === 'interval' || geometry.type === 'schema') {
          var result = geometry.getElementsBy(function (ele) {
            var eleData = ele.getData();
            return eleData[xField_1] === xValue_1;
          });
          elements_1 = elements_1.concat(result);
        }
      });
      
      if (elements_1.length) {
        var coordinate_1 = view.getCoordinate();
        var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
        var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
        var groupBBox_1 = firstBBox_1;
        (0, util_1.each)(elements_1, function (ele) {
          var bbox = ele.shape.getCanvasBBox();
          if (coordinate_1.isTransposed) {
            if (bbox.minY < firstBBox_1.minY) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxY > lastBBox_1.maxY) {
              lastBBox_1 = bbox;
            }
          } else {
            if (bbox.minX < firstBBox_1.minX) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxX > lastBBox_1.maxX) {
              lastBBox_1 = bbox;
            }
          }
          groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
          groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
          groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
          groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
        });
        var backgroundGroup = view.backgroundGroup,
          coordinateBBox = view.coordinateBBox;
        var path = void 0;
        if (coordinate_1.isRect) {
          var xScale = view.getXScale();
          var _a = args || {},
            appendRatio = _a.appendRatio,
            appendWidth = _a.appendWidth;
          if ((0, util_1.isNil)(appendWidth)) {
            appendRatio = (0, util_1.isNil)(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio; 
            appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
          }
          var minX = void 0;
          var minY = void 0;
          var width = void 0;
          var height = void 0;
          if (coordinate_1.isTransposed) {
            minX = coordinateBBox.minX;
            minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
            width = coordinateBBox.width;
            height = groupBBox_1.height + appendWidth * 2;
          } else {
            minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
            
            minY = coordinateBBox.minY;
            width = groupBBox_1.width + appendWidth * 2;
            height = coordinateBBox.height;
          }
          path = [['M', minX, minY], ['L', minX + width, minY], ['L', minX + width, minY + height], ['L', minX, minY + height], ['Z']];
        } else {
          var firstElement = (0, util_1.head)(elements_1);
          var lastElement = (0, util_1.last)(elements_1);
          var startAngle = (0, graphics_1.getAngle)(firstElement.getModel(), coordinate_1).startAngle;
          var endAngle = (0, graphics_1.getAngle)(lastElement.getModel(), coordinate_1).endAngle;
          var center = coordinate_1.getCenter();
          var radius = coordinate_1.getRadius();
          var innterRadius = coordinate_1.innerRadius * radius;
          path = (0, graphics_1.getSectorPath)(center.x, center.y, radius, startAngle, endAngle, innterRadius);
        }
        if (this.regionPath) {
          this.regionPath.attr('path', path);
          this.regionPath.show();
        } else {
          var style = (0, util_1.get)(args, 'style', DEFAULT_REGION_PATH_STYLE);
          this.regionPath = backgroundGroup.addShape({
            type: 'path',
            name: 'active-region',
            capture: false,
            attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
              path: path
            })
          });
        }
      }
    }
  };
    ActiveRegion.prototype.hide = function () {
    if (this.regionPath) {
      this.regionPath.hide();
    }
    
    this.items = null;
  };
    ActiveRegion.prototype.destroy = function () {
    this.hide();
    if (this.regionPath) {
      this.regionPath.remove(true);
    }
    _super.prototype.destroy.call(this);
  };
  return ActiveRegion;
}(base_1.default);
exports.default = ActiveRegion;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(31);
var geometry_1 = (0, tslib_1.__importDefault)(__webpack_require__(127));
var SiblingTooltip = function (_super) {
  (0, tslib_1.__extends)(SiblingTooltip, _super);
  function SiblingTooltip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
    SiblingTooltip.prototype.showTooltip = function (view, point) {
    var siblings = (0, util_2.getSilbings)(view);
    (0, util_1.each)(siblings, function (sibling) {
      var siblingPoint = (0, util_2.getSiblingPoint)(view, sibling, point);
      sibling.showTooltip(siblingPoint);
    });
  };
    SiblingTooltip.prototype.hideTooltip = function (view) {
    var siblings = (0, util_2.getSilbings)(view);
    (0, util_1.each)(siblings, function (sibling) {
      sibling.hideTooltip();
    });
  };
  return SiblingTooltip;
}(geometry_1.default);
exports.default = SiblingTooltip;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var component_1 = __webpack_require__(179);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var dependents_1 = __webpack_require__(69);
var EllipsisText = function (_super) {
  (0, tslib_1.__extends)(EllipsisText, _super);
  function EllipsisText() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  EllipsisText.prototype.destroy = function () {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
    EllipsisText.prototype.show = function () {
    var context = this.context;
    var ev = context.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    if (timeStamp - lastTimeStamp > 16) {
      var preLoc = this.location;
      var curLoc = {
        x: ev.x,
        y: ev.y
      };
      if (!preLoc || !(0, util_1.isEqual)(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
    EllipsisText.prototype.hide = function () {
    this.hideTooltip();
    this.location = null;
  };
  EllipsisText.prototype.showTooltip = function (curLoc) {
    var context = this.context;
    var ev = context.event;
    var target = ev.target;
    if (target && target.get('tip')) {
      if (!this.tooltip) {
        this.renderTooltip(); 
      }

      var tipContent = target.get('tip');
      
      this.tooltip.update((0, tslib_1.__assign)({
        title: tipContent
      }, curLoc));
      this.tooltip.show();
    }
  };
  EllipsisText.prototype.hideTooltip = function () {
    this.tooltip && this.tooltip.hide();
  };
  EllipsisText.prototype.renderTooltip = function () {
    var _a;
    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: canvas.get('width'),
        y: canvas.get('height')
      }
    };
    var theme = view.getTheme();
    var tooltipStyles = (0, util_1.get)(theme, ['components', 'tooltip', 'domStyles'], {}); 
    var tooltip = new dependents_1.HtmlTooltip({
      parent: canvas.get('el').parentNode,
      region: region,
      visible: false,
      crosshairs: null,
      domStyles: (0, tslib_1.__assign)({}, (0, util_1.deepMix)({}, tooltipStyles, (_a = {},
      
      _a[component_1.TOOLTIP_CSS_CONST.CONTAINER_CLASS] = {
        'max-width': '50%'
      }, _a[component_1.TOOLTIP_CSS_CONST.TITLE_CLASS] = {
        'word-break': 'break-all'
      }, _a)))
    });
    tooltip.init();
    tooltip.setCapture(false); 
    this.tooltip = tooltip;
  };
  return EllipsisText;
}(base_1.default);
exports.default = EllipsisText;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var state_1 = (0, tslib_1.__importDefault)(__webpack_require__(283));
var ElementActive = function (_super) {
  (0, tslib_1.__extends)(ElementActive, _super);
  function ElementActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'active';
    return _this;
  }
    ElementActive.prototype.active = function () {
    this.setState();
  };
  return ElementActive;
}(state_1.default);
exports.default = ElementActive;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var util_1 = __webpack_require__(31);
var util_2 = __webpack_require__(0);
var LinkByColor = function (_super) {
  (0, tslib_1.__extends)(LinkByColor, _super);
  function LinkByColor() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.cache = {};
    return _this;
  }
  
  LinkByColor.prototype.getColorScale = function (view, element) {
    var colorAttr = element.geometry.getAttribute('color');
    if (!colorAttr) {
      return null;
    }
    var scale = view.getScaleByField(colorAttr.getFields()[0]);
    return scale;
  };
  
  LinkByColor.prototype.getLinkPath = function (element, nextElement) {
    var view = this.context.view;
    var isTransposed = view.getCoordinate().isTransposed;
    var bbox = element.shape.getCanvasBBox();
    var nextBBox = nextElement.shape.getCanvasBBox();
    var path = isTransposed ? [['M', bbox.minX, bbox.minY], ['L', nextBBox.minX, nextBBox.maxY], ['L', nextBBox.maxX, nextBBox.maxY], ['L', bbox.maxX, bbox.minY], ['Z']] : [['M', bbox.maxX, bbox.minY], ['L', nextBBox.minX, nextBBox.minY], ['L', nextBBox.minX, nextBBox.maxY], ['L', bbox.maxX, bbox.maxY], ['Z']];
    return path;
  };
  
  LinkByColor.prototype.addLinkShape = function (group, element, nextElement, activeStyle) {
    var style = {
      opacity: 0.4,
      fill: element.shape.attr('fill')
    };
    group.addShape({
      type: 'path',
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, (0, util_2.deepMix)({}, style, (0, util_2.isFunction)(activeStyle) ? activeStyle(style, element) : activeStyle)), {
        path: this.getLinkPath(element, nextElement)
      })
    });
  };
  
  LinkByColor.prototype.linkByElement = function (element, activeStyle) {
    var _this = this;
    var view = this.context.view;
    var scale = this.getColorScale(view, element);
    if (!scale) {
      return;
    }
    var value = (0, util_1.getElementValue)(element, scale.field);
    if (!this.cache[value]) {
      var elements_1 = (0, util_1.getElementsByField)(view, scale.field, value);
      var linkGroup = this.linkGroup;
      var group_1 = linkGroup.addGroup();
      this.cache[value] = group_1; 
      var count_1 = elements_1.length;
      (0, util_2.each)(elements_1, function (el, index) {
        if (index < count_1 - 1) {
          var nextEl = elements_1[index + 1];
          _this.addLinkShape(group_1, el, nextEl, activeStyle);
        }
      });
    }
  };
  
  LinkByColor.prototype.removeLink = function (element) {
    var scale = this.getColorScale(this.context.view, element);
    if (!scale) {
      return;
    }
    var value = (0, util_1.getElementValue)(element, scale.field);
    if (this.cache[value]) {
      this.cache[value].remove();
      this.cache[value] = null;
    }
  };
    LinkByColor.prototype.link = function (args) {
    var context = this.context;
    if (!this.linkGroup) {
      
      this.linkGroup = context.view.foregroundGroup.addGroup({
        id: 'link-by-color-group',
        capture: false
      });
    }
    var element = (0, util_1.getCurrentElement)(context);
    if (element) {
      this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
    }
  };
    LinkByColor.prototype.unlink = function () {
    var element = (0, util_1.getCurrentElement)(this.context);
    if (element) {
      this.removeLink(element);
    }
  };
    LinkByColor.prototype.clear = function () {
    if (this.linkGroup) {
      this.linkGroup.clear();
    }
    this.cache = {};
  };
    LinkByColor.prototype.destroy = function () {
    _super.prototype.destroy.call(this);
    if (this.linkGroup) {
      this.linkGroup.remove();
    }
  };
  return LinkByColor;
}(base_1.default);
exports.default = LinkByColor;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var range_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(285));
var ElementRangeActive = function (_super) {
  (0, tslib_1.__extends)(ElementRangeActive, _super);
  function ElementRangeActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'active';
    return _this;
  }
    ElementRangeActive.prototype.active = function () {
    this.setState();
  };
  return ElementRangeActive;
}(range_state_1.default);
exports.default = ElementRangeActive;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var single_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(286));
var ElementSingleActive = function (_super) {
  (0, tslib_1.__extends)(ElementSingleActive, _super);
  function ElementSingleActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'active';
    return _this;
  }
    ElementSingleActive.prototype.active = function () {
    this.setState();
  };
  return ElementSingleActive;
}(single_state_1.default);
exports.default = ElementSingleActive;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(31);
var highlight_1 = (0, tslib_1.__importDefault)(__webpack_require__(159));
var HighlightColor = function (_super) {
  (0, tslib_1.__extends)(HighlightColor, _super);
  function HighlightColor() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightColor.prototype.setStateByElement = function (element, enable) {
    var view = this.context.view;
    var colorAttr = element.geometry.getAttribute('color');
    if (!colorAttr) {
      return;
    }
    var scale = view.getScaleByField(colorAttr.getFields()[0]);
    var value = (0, util_1.getElementValue)(element, scale.field);
    var elements = (0, util_1.getElements)(view);
    var highlightElements = elements.filter(function (el) {
      return (0, util_1.getElementValue)(el, scale.field) === value;
    });
    this.setHighlightBy(elements, function (el) {
      return highlightElements.includes(el);
    }, enable);
  };
  return HighlightColor;
}(highlight_1.default);
exports.default = HighlightColor;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(31);
var highlight_1 = (0, tslib_1.__importStar)(__webpack_require__(159));
var HighlightX = function (_super) {
  (0, tslib_1.__extends)(HighlightX, _super);
  function HighlightX() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  
  HighlightX.prototype.setElementHighlight = function (el, callback) {
    if (callback(el)) {
      if (el.hasState(highlight_1.STATUS_UNACTIVE)) {
        el.setState(highlight_1.STATUS_UNACTIVE, false);
      }
      el.setState(highlight_1.STATUS_ACTIVE, true);
    } else {
      el.setState(highlight_1.STATUS_UNACTIVE, true);
      if (el.hasState(highlight_1.STATUS_ACTIVE)) {
        el.setState(highlight_1.STATUS_ACTIVE, false);
      }
    }
  };
  HighlightX.prototype.setStateByElement = function (element, enable) {
    var view = this.context.view;
    var scale = view.getXScale();
    var value = (0, util_1.getElementValue)(element, scale.field);
    var elements = (0, util_1.getElements)(view);
    var highlightElements = elements.filter(function (el) {
      return (0, util_1.getElementValue)(el, scale.field) === value;
    });
    this.setHighlightBy(elements, function (el) {
      return highlightElements.includes(el);
    }, enable);
  };
    HighlightX.prototype.toggle = function () {
    var element = (0, util_1.getCurrentElement)(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setStateByElement(element, !hasState);
    }
  };
  return HighlightX;
}(highlight_1.default);
exports.default = HighlightX;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(31);
var highlight_util_1 = __webpack_require__(287);
var single_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(286));
var ElementSingleHighlight = function (_super) {
  (0, tslib_1.__extends)(ElementSingleHighlight, _super);
  function ElementSingleHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'active';
    return _this;
  }
    ElementSingleHighlight.prototype.highlight = function () {
    this.setState();
  };
  ElementSingleHighlight.prototype.setElementState = function (element, enable) {
    var view = this.context.view;
    var elements = (0, util_1.getElements)(view);
    (0, highlight_util_1.setHighlightBy)(elements, function (el) {
      return element === el;
    }, enable);
  };
  
  ElementSingleHighlight.prototype.clear = function () {
    var view = this.context.view;
    (0, highlight_util_1.clearHighlight)(view);
  };
  return ElementSingleHighlight;
}(single_state_1.default);
exports.default = ElementSingleHighlight;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var range_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(285));
var ElementRangeSelected = function (_super) {
  (0, tslib_1.__extends)(ElementRangeSelected, _super);
  function ElementRangeSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'selected';
    return _this;
  }
    ElementRangeSelected.prototype.selected = function () {
    this.setState();
  };
  return ElementRangeSelected;
}(range_state_1.default);
exports.default = ElementRangeSelected;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var state_1 = (0, tslib_1.__importDefault)(__webpack_require__(283));
var ElementMultipleSelected = function (_super) {
  (0, tslib_1.__extends)(ElementMultipleSelected, _super);
  function ElementMultipleSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'selected';
    return _this;
  }
    ElementMultipleSelected.prototype.selected = function () {
    this.setState();
  };
  return ElementMultipleSelected;
}(state_1.default);
exports.default = ElementMultipleSelected;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var single_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(286));
var ElementSingleSelected = function (_super) {
  (0, tslib_1.__extends)(ElementSingleSelected, _super);
  function ElementSingleSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'selected';
    return _this;
  }
    ElementSingleSelected.prototype.selected = function () {
    this.setState();
  };
  return ElementSingleSelected;
}(single_state_1.default);
exports.default = ElementSingleSelected;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var list_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(151));
var ListActive = function (_super) {
  (0, tslib_1.__extends)(ListActive, _super);
  function ListActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'active';
    return _this;
  }
    ListActive.prototype.active = function () {
    this.setState();
  };
  return ListActive;
}(list_state_1.default);
exports.default = ListActive;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var list_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(151));
var ListSelected = function (_super) {
  (0, tslib_1.__extends)(ListSelected, _super);
  function ListSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'selected';
    return _this;
  }
  ListSelected.prototype.selected = function () {
    this.setState();
  };
  return ListSelected;
}(list_state_1.default);
exports.default = ListSelected;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var list_state_1 = (0, tslib_1.__importDefault)(__webpack_require__(151));
var ListUnchecked = function (_super) {
  (0, tslib_1.__extends)(ListUnchecked, _super);
  function ListUnchecked() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = 'unchecked';
    return _this;
  }
    ListUnchecked.prototype.unchecked = function () {
    this.setState();
  };
  return ListUnchecked;
}(list_state_1.default);
exports.default = ListUnchecked;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var CursorAction = function (_super) {
  (0, tslib_1.__extends)(CursorAction, _super);
  function CursorAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CursorAction.prototype.setCursor = function (cursor) {
    var view = this.context.view;
    view.getCanvas().setCursor(cursor);
  };
    CursorAction.prototype.default = function () {
    this.setCursor('default');
  };
    CursorAction.prototype.pointer = function () {
    this.setCursor('pointer');
  };
    CursorAction.prototype.move = function () {
    this.setCursor('move');
  };
    CursorAction.prototype.crosshair = function () {
    this.setCursor('crosshair');
  };
    CursorAction.prototype.wait = function () {
    this.setCursor('wait');
  };
    CursorAction.prototype.help = function () {
    this.setCursor('help');
  };
    CursorAction.prototype.text = function () {
    this.setCursor('text');
  };
    CursorAction.prototype.eResize = function () {
    this.setCursor('e-resize');
  };
    CursorAction.prototype.wResize = function () {
    this.setCursor('w-resize');
  };
    CursorAction.prototype.nResize = function () {
    this.setCursor('n-resize');
  };
    CursorAction.prototype.sResize = function () {
    this.setCursor('s-resize');
  };
    CursorAction.prototype.neResize = function () {
    this.setCursor('ne-resize');
  };
    CursorAction.prototype.nwResize = function () {
    this.setCursor('nw-resize');
  };
    CursorAction.prototype.seResize = function () {
    this.setCursor('se-resize');
  };
    CursorAction.prototype.swResize = function () {
    this.setCursor('sw-resize');
  };
    CursorAction.prototype.nsResize = function () {
    this.setCursor('ns-resize');
  };
    CursorAction.prototype.ewResize = function () {
    this.setCursor('ew-resize');
  };
  return CursorAction;
}(base_1.default);
exports.default = CursorAction;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var util_2 = __webpack_require__(31);
var DataFilter = function (_super) {
  (0, tslib_1.__extends)(DataFilter, _super);
  function DataFilter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataFilter.prototype.filterView = function (view, field, filter) {
    var _this = this;
    
    if (view.getScaleByField(field)) {
      view.filter(field, filter);
    }
    if (view.views && view.views.length) {
      (0, util_1.each)(view.views, function (subView) {
        _this.filterView(subView, field, filter);
      });
    }
  };
    DataFilter.prototype.filter = function () {
    var delegateObject = (0, util_2.getDelegationObject)(this.context);
    if (delegateObject) {
      var view = this.context.view;
      var component = delegateObject.component;
      var field = component.get('field');
      
      if ((0, util_2.isList)(delegateObject)) {
        if (field) {
          var unCheckedItems = component.getItemsByState('unchecked');
          var scale_1 = (0, util_2.getScaleByField)(view, field);
          var names_1 = unCheckedItems.map(function (item) {
            return item.name;
          });
          if (names_1.length) {
            this.filterView(view, field, function (value) {
              var text = scale_1.getText(value);
              return !names_1.includes(text);
            });
          } else {
            this.filterView(view, field, null);
          }
          view.render(true);
        }
      } else if ((0, util_2.isSlider)(delegateObject)) {
        var range = component.getValue();
        var min_1 = range[0],
          max_1 = range[1];
        this.filterView(view, field, function (value) {
          return value >= min_1 && value <= max_1;
        });
        view.render(true);
      }
    }
  };
  return DataFilter;
}(base_1.default);
exports.default = DataFilter;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var superPropBase = __webpack_require__(949);
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var keys = __webpack_require__(365);
var hasSymbols = typeof Symbol === 'function' && (0, _typeof2.default)(Symbol('foo')) === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function isFunction(fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};
var hasPropertyDescriptors = __webpack_require__(649)();
var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
var defineProperty = function defineProperty(object, name, value, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    });
  } else {
    object[name] = value; 
  }
};

var defineProperties = function defineProperties(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);
  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(366);
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : __webpack_require__(648);
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
module.exports = keysShim;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';
  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && (0, _typeof2.default)(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }
  return isArgs;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if ((0, _typeof2.default)(Symbol.iterator) === 'symbol') {
    return true;
  }
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  
  
  
  

  
  

  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  } 
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(237);
var GetIntrinsic = __webpack_require__(236);
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');
if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    
    $defineProperty = null;
  }
}
module.exports = function callBind(originalFunction) {
  var func = $reflectApply(bind, $call, arguments);
  if ($gOPD && $defineProperty) {
    var desc = $gOPD(func, 'length');
    if (desc.configurable) {
      
      $defineProperty(func, 'length', {
        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
      });
    }
  }
  return func;
};
var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var objectKeys = __webpack_require__(365);
var hasSymbols = __webpack_require__(367)();
var callBound = __webpack_require__(653);
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;


module.exports = function assign(target, source1) {
  if (target == null) {
    throw new TypeError('target must be an object');
  }
  var to = toObject(target); 
  if (arguments.length === 1) {
    return to; 
  }

  for (var s = 1; s < arguments.length; ++s) {
    var from = toObject(arguments[s]); 

    
    var keys = objectKeys(from);
    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j = 0; j < syms.length; ++j) {
        var key = syms[j];
        if ($propIsEnumerable(from, key)) {
          $push(keys, key);
        }
      }
    }

    
    for (var i = 0; i < keys.length; ++i) {
      var nextKey = keys[i];
      if ($propIsEnumerable(from, nextKey)) {
        
        var propValue = from[nextKey]; 
        to[nextKey] = propValue; 
      }
    }
  }

  return to; 
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(369);
var lacksProperEnumerationOrder = function lacksProperEnumerationOrder() {
  if (!Object.assign) {
    return false;
  }
    var str = 'abcdefghijklmnopqrst';
  var letters = str.split('');
  var map = {};
  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map);
  var actual = '';
  for (var k in obj) {
    actual += k;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function assignHasPendingExceptions() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  /*
   * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
   * which is 72% slower than our shim, and Firefox 40's native implementation.
   */
  var thrower = Object.preventExtensions({
    1: 2
  });
  try {
    Object.assign(thrower, 'xy');
  } catch (e) {
    return thrower[1] === 'y';
  }
  return false;
};
module.exports = function getPolyfill() {
  if (!Object.assign) {
    return implementation;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation;
  }
  if (assignHasPendingExceptions()) {
    return implementation;
  }
  return Object.assign;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArrayLike = _interopRequireDefault(__webpack_require__(56));
var filter = function filter(arr, func) {
  if (!(0, _isArrayLike.default)(arr)) {
    return arr;
  }
  var result = [];
  for (var index = 0; index < arr.length; index++) {
    var value = arr[index];
    if (func(value, index)) {
      result.push(value);
    }
  }
  return result;
};
var _default = filter;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isNil = _interopRequireDefault(__webpack_require__(95));
var _keys2 = _interopRequireDefault(__webpack_require__(373));
function isMatch(obj, attrs) {
  var _keys = (0, _keys2.default)(attrs);
  var length = _keys.length;
  if ((0, _isNil.default)(obj)) return !length;
  for (var i = 0; i < length; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var _default = isMatch;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _each = _interopRequireDefault(__webpack_require__(107));
var _isFunction = _interopRequireDefault(__webpack_require__(57));
var keys = Object.keys ? function (obj) {
  return Object.keys(obj);
} : function (obj) {
  var result = [];
  (0, _each.default)(obj, function (value, key) {
    if (!((0, _isFunction.default)(obj) && key === 'prototype')) {
      result.push(key);
    }
  });
  return result;
};
var _default = keys;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _default = function _default(arr) {
  if (!(0, _isArray.default)(arr)) {
    return undefined;
  }
  return arr.reduce(function (prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _default = function _default(arr) {
  if (!(0, _isArray.default)(arr)) {
    return undefined;
  }
  return arr.reduce(function (prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArrayLike = _interopRequireDefault(__webpack_require__(56));
var splice = Array.prototype.splice;
var pullAt = function pullAt(arr, indexes) {
  if (!(0, _isArrayLike.default)(arr)) {
    return [];
  }
  var length = arr ? indexes.length : 0;
  var last = length - 1;
  while (length--) {
    var previous = void 0;
    var index = indexes[length];
    if (length === last || index !== previous) {
      previous = index;
      splice.call(arr, index, 1);
    }
  }
  return arr;
};
var _default = pullAt;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _each = _interopRequireDefault(__webpack_require__(107));
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _isPlainObject = _interopRequireDefault(__webpack_require__(138));
var reduce = function reduce(arr, fn, init) {
  if (!(0, _isArray.default)(arr) && !(0, _isPlainObject.default)(arr)) {
    return arr;
  }
  var result = init;
  (0, _each.default)(arr, function (data, i) {
    result = fn(result, data, i);
  });
  return result;
};
var _default = reduce;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uniq;
function uniq(arr, cache) {
  if (cache === void 0) {
    cache = new Map();
  }
  var r = [];
  if (Array.isArray(arr)) {
    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];
      
      if (!cache.has(item)) {
        r.push(item);
        cache.set(item, true);
      }
    }
  }
  return r;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = groupToMap;
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _isFunction = _interopRequireDefault(__webpack_require__(57));
var _groupBy = _interopRequireDefault(__webpack_require__(380));
function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!(0, _isFunction.default)(condition)) {
    
    var paramscondition_1 = (0, _isArray.default)(condition) ? condition : condition.replace(/\s+/g, '').split('*');
    condition = function condition(row) {
      var unique = '_'; 
      
      for (var i = 0, l = paramscondition_1.length; i < l; i++) {
        unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
      }
      return unique;
    };
  }
  return (0, _groupBy.default)(data, condition);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isArray = _interopRequireDefault(__webpack_require__(36));
var _isFunction = _interopRequireDefault(__webpack_require__(57));
var hasOwnProperty = Object.prototype.hasOwnProperty;
function groupBy(data, condition) {
  if (!condition || !(0, _isArray.default)(data)) {
    return {};
  }
  var result = {};
  
  var predicate = (0, _isFunction.default)(condition) ? condition : function (item) {
    return item[condition];
  };
  var key;
  for (var i = 0; i < data.length; i++) {
    var item = data[i];
    key = predicate(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var _default = groupBy;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = function _default(obj, key) {
  return obj.hasOwnProperty(key);
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var toString = {}.toString;
var getType = function getType(value) {
  return toString.call(value).replace(/^\[object /, '').replace(/]$/, '');
};
var _default = getType;
exports.default = _default;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectProto = Object.prototype;
var isPrototype = function isPrototype(value) {
  var Ctor = value && value.constructor;
  var proto = typeof Ctor === 'function' && Ctor.prototype || objectProto;
  return value === proto;
};
var _default = isPrototype;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isFunction = _interopRequireDefault(__webpack_require__(57));
var _default = function _default(f, resolver) {
  if (!(0, _isFunction.default)(f)) {
    throw new TypeError('Expected a function');
  }
  var memoized = function memoized() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = f.apply(this, args);
    
    cache.set(key, result);
    return result;
  };
  memoized.cache = new Map();
  return memoized;
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isObjectLike = _interopRequireDefault(__webpack_require__(239));
var _isArrayLike = _interopRequireDefault(__webpack_require__(56));
var _isString = _interopRequireDefault(__webpack_require__(85));
var isEqual = function isEqual(value, other) {
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  if ((0, _isString.default)(value) || (0, _isString.default)(other)) {
    return false;
  }
  if ((0, _isArrayLike.default)(value) || (0, _isArrayLike.default)(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value.length; i++) {
      rst = isEqual(value[i], other[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if ((0, _isObjectLike.default)(value) || (0, _isObjectLike.default)(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var _default = isEqual;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _values = _interopRequireDefault(__webpack_require__(240));
var _memoize = _interopRequireDefault(__webpack_require__(384));
var _isString = _interopRequireDefault(__webpack_require__(85));
var ctx;
var _default = (0, _memoize.default)(function (text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize,
    fontFamily = font.fontFamily,
    fontWeight = font.fontWeight,
    fontStyle = font.fontStyle,
    fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement('canvas').getContext('2d');
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(' ');
  return ctx.measureText((0, _isString.default)(text) ? text : '').width;
}, function (text, font) {
  if (font === void 0) {
    font = {};
  }
  return (0, _tslib.__spreadArrays)([text], (0, _values.default)(font)).join('');
});
exports.default = _default;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHeight;
var _getStyle = _interopRequireDefault(__webpack_require__(139));
function getHeight(el, defaultValue) {
  var height = (0, _getStyle.default)(el, 'height', defaultValue);
  if (height === 'auto') {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHeight;
var _getStyle = _interopRequireDefault(__webpack_require__(139));
function getHeight(el, defaultValue) {
  var width = (0, _getStyle.default)(el, 'width', defaultValue);
  if (width === 'auto') {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectPath = exports.pathToCurve = exports.pathToAbsolute = exports.parsePathString = exports.parsePathArray = exports.intersection = exports.formatPath = exports.fillPathByDiff = exports.fillPath = exports.catmullRomToBezier = void 0;
var _util = __webpack_require__(0);
var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", 'ig');
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", 'ig');

var parsePathString = function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  if ((0, _util.isArray)(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function (a, b) {
      b && params.push(+b);
    });
    if (name === 'm' && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = 'l';
      b = b === 'm' ? 'l' : 'L';
    }
    if (name === 'o' && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === 'r') {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data;
};

exports.parsePathString = parsePathString;
var catmullRomToBezier = function catmullRomToBezier(crp, z) {
  var d = [];
  
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [{
      x: +crp[i - 2],
      y: +crp[i - 1]
    }, {
      x: +crp[i],
      y: +crp[i + 1]
    }, {
      x: +crp[i + 2],
      y: +crp[i + 3]
    }, {
      x: +crp[i + 4],
      y: +crp[i + 5]
    }];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
  }
  return d;
};
exports.catmullRomToBezier = catmullRomToBezier;
var ellipsePath = function ellipsePath(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
  } else {
    res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
  }
  return res;
};
var pathToAbsolute = function pathToAbsolute(pathArray) {
  pathArray = parsePathString(pathArray);
  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';
  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case 'V':
          r[1] = +pa[1] + y;
          break;
        case 'H':
          r[1] = +pa[1] + x;
          break;
        case 'R':
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case 'O':
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case 'U':
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ['U'].concat(res[res.length - 1].slice(-2));
          break;
        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else if (pa0 === 'R') {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ['R'].concat(pa.slice(-2));
    } else if (pa0 === 'O') {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === 'U') {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ['U'].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== 'O') {
      switch (r[0]) {
        case 'Z':
          x = +mx;
          y = +my;
          break;
        case 'H':
          x = r[1];
          break;
        case 'V':
          y = r[1];
          break;
        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }
  return res;
};
exports.pathToAbsolute = pathToAbsolute;
var l2c = function l2c(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  
  
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate = function rotate(x, y, rad) {
    var X = x * Math.cos(rad) - y * Math.sin(rad);
    var Y = x * Math.sin(rad) + y * Math.cos(rad);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      
      x2 += 1;
      y2 += 1;
    }
    
    
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(',');
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function pathToCurve(path, path2) {
  var p = pathToAbsolute(path);
  var p2 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = []; 
  var pcoms2 = []; 
  var pfirst = ''; // temporary holder for original path command
  var pcom = ''; // holder for previous path command of original path
  var ii;
  var processPath = function processPath(path, d, pcom) {
    var nx;
    var ny;
    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;
      case 'A':
        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
        break;
      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          
          nx = d.x * 2 - d.bx; 
          ny = d.y * 2 - d.by; 
        } else {
          
          nx = d.x;
          ny = d.y;
        }
        path = ['C', nx, ny].concat(path.slice(1));
        break;
      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          
          d.qx = d.x * 2 - d.qx; 
          d.qy = d.y * 2 - d.qy; 
        } else {
          
          d.qx = d.x;
          d.qy = d.y;
        }
        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
        break;
      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
        break;
      case 'L':
        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
        break;
      case 'H':
        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
        break;
      case 'V':
        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
        break;
      case 'Z':
        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
      default:
        break;
    }
    return path;
  };
  var fixArc = function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];
      while (pi.length) {
        pcoms1[i] = 'A'; 
        p2 && (pcoms2[i] = 'A'); 
        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
      }
      pp.splice(i, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function fixM(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
      path2.splice(i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]); 
    if (pfirst !== 'C') {
      
      pcoms1[i] = pfirst; 
      i && (pcom = pcoms1[i - 1]); 
    }

    p[i] = processPath(p[i], attrs, pcom); 
    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; 
    
    
    fixArc(p, i); 
    if (p2) {
      
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== 'C') {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);
      if (pcoms2[i] !== 'A' && pfirst === 'C') {
        pcoms2[i] = 'C';
      }
      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }
  return p2 ? [p, p2] : p;
};
exports.pathToCurve = pathToCurve;
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function parsePathArray(path) {
  return path.join(',').replace(p2s, '$1');
};
exports.parsePathArray = parsePathArray;
var base3 = function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum;
};
var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;
  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b + sqrtb2ac) / (2 * a);
    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }
    var t2 = (-b - sqrtb2ac) / (2 * a);
    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }
  var j = tvalues.length;
  var jlen = j;
  var mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function rectPath(x, y, w, h, r) {
  if (r) {
    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }
  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
  
  res.parsePathArray = parsePathArray;
  return res;
};
exports.rectPath = rectPath;
var box = function box(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x: x,
    y: y,
    width: width,
    w: width,
    height: height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(' ')
  };
};
var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!(0, _util.isArray)(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  
  return {
    x: x,
    y: y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha: alpha
  };
};
var interHelper = function interHelper(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }
  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            
            res += 1;
          } else {
            
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function interPathHelper(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];
    if (pi[0] === 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] === 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            
            res += intr;
          } else {
            
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function intersection(path1, path2) {
  return interPathHelper(path1, path2);
};
exports.intersection = intersection;
function decasteljau(points, t) {
  var left = [];
  var right = [];
  function recurse(points, t) {
    if (points.length === 1) {
      left.push(points[0]);
      right.push(points[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points.length - 1; i++) {
        if (i === 0) {
          left.push(points[0]);
        }
        if (i === points.length - 2) {
          right.push(points[i + 1]);
        }
        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
      }
      recurse(middlePoints, t);
    }
  }
  if (points.length) {
    recurse(points, t);
  }
  return {
    left: left,
    right: right.reverse()
  };
}
function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end[0] === 'A') {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === 'C') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === 'S' || end[0] === 'Q') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }
  var leftSegments = points;
  var t = 1 / count;
  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function (segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push('C');
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push('Q');
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push('L');
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function splitSegment(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === 'M') {
      temp[0] = 'L';
    }
    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function fillPath(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === 'M') {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i = 0; i < targetLen; i++) {
    var index = Math.floor(ratio * i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function (filled, count, i) {
    if (i === sourceLen) {
      return filled.concat(source[sourceLen]);
    }
    return filled.concat(splitSegment(source[i], source[i + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
    filled.push('Z');
  }
  return filled;
};
exports.fillPath = fillPath;
var isEqual = function isEqual(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  (0, _util.each)(obj1, function (item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add, modify) {
  var type = null;
  var min = modify;
  if (add < min) {
    min = add;
    type = 'add';
  }
  if (del < min) {
    min = del;
    type = 'del';
  }
  return {
    type: type,
    min: min
  };
}
var levenshteinDistance = function levenshteinDistance(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = {
      min: i
    };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = {
      min: j
    };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[i - 1][j].min + 1;
      var add = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff(del, add, modify);
    }
  }
  return dist;
};
var fillPathByDiff = function fillPathByDiff(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1;
  
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    
    for (var i = 1; i <= sourceLen; i++) {
      var min = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min) {
          min = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index = minPos;
      if (diffMatrix[i][index].type) {
        changes.push({
          index: i - 1,
          type: diffMatrix[i][index].type
        });
      }
    }
    
    for (var i = changes.length - 1; i >= 0; i--) {
      index = changes[i].index;
      if (changes[i].type === 'add') {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  }
  
  sourceLen = source.length;
  var diff = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff; i++) {
      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};

exports.fillPathByDiff = fillPathByDiff;
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);
    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case 'M':
      points.push([segment[1], segment[2]]);
      break;
    case 'L':
      points.push([segment[1], segment[2]]);
      break;
    case 'A':
      points.push([segment[6], segment[7]]);
      break;
    case 'Q':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case 'T':
      points.push([segment[1], segment[2]]);
      break;
    case 'C':
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case 'S':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case 'H':
      points.push([segment[1], segment[1]]);
      break;
    case 'V':
      points.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points;
}
var formatPath = function formatPath(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      
      points = _getSegmentPoints(fromPath[i]);
      switch (toPath[i][0]) {
        case 'M':
          fromPath[i] = ['M'].concat(points[0]);
          break;
        case 'L':
          fromPath[i] = ['L'].concat(points[0]);
          break;
        case 'A':
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;
        case 'Q':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;
        case 'T':
          fromPath[i] = ['T'].concat(points[0]);
          break;
        case 'C':
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;
        case 'S':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};
exports.formatPath = formatPath;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var GraphEvent = function () {
  function GraphEvent(type, event) {
        this.bubbles = true;
        this.target = null;
        this.currentTarget = null;
        this.delegateTarget = null;
        this.delegateObject = null;
        this.defaultPrevented = false;
        this.propagationStopped = false;
        this.shape = null;
        this.fromShape = null;
        this.toShape = null;
    
    this.propagationPath = [];
    this.type = type;
    this.name = type;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
    GraphEvent.prototype.preventDefault = function () {
    this.defaultPrevented = true;
    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
    GraphEvent.prototype.stopPropagation = function () {
    this.propagationStopped = true;
  };
  GraphEvent.prototype.toString = function () {
    var type = this.type;
    return "[Event (type=" + type + ")]";
  };
  GraphEvent.prototype.save = function () {};
  GraphEvent.prototype.restore = function () {};
  return GraphEvent;
}();
var _default = GraphEvent;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _eventEmitter = _interopRequireDefault(__webpack_require__(126));
var _util = __webpack_require__(102);
var Base = function (_super) {
  (0, _tslib.__extends)(Base, _super);
  function Base(cfg) {
    var _this = _super.call(this) || this;
        _this.destroyed = false;
    var defaultCfg = _this.getDefaultCfg();
    _this.cfg = (0, _util.mix)(defaultCfg, cfg);
    return _this;
  }
    Base.prototype.getDefaultCfg = function () {
    return {};
  };
  
  Base.prototype.get = function (name) {
    return this.cfg[name];
  };
  
  Base.prototype.set = function (name, value) {
    this.cfg[name] = value;
  };
  
  Base.prototype.destroy = function () {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };
  return Base;
}(_eventEmitter.default);
var _default = Base;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _element = _interopRequireDefault(__webpack_require__(393));
var _util2 = __webpack_require__(102);
var SHAPE_MAP = {};
var INDEX = '_INDEX';
function setCanvas(element, canvas) {
  element.set('canvas', canvas);
  if (element.isGroup()) {
    var children = element.get('children');
    if (children.length) {
      children.forEach(function (child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set('timeline', timeline);
  if (element.isGroup()) {
    var children = element.get('children');
    if (children.length) {
      children.forEach(function (child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function contains(container, element) {
  var children = container.getChildren();
  return children.indexOf(element) >= 0;
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  
  if (destroy) {
    element.destroy();
  } else {
    element.set('parent', null);
    element.set('canvas', null);
  }
  (0, _util2.removeFromArray)(container.getChildren(), element);
}
function getComparer(compare) {
  return function (left, right) {
    var result = compare(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}
var Container = function (_super) {
  (0, _tslib.__extends)(Container, _super);
  function Container() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Container.prototype.isCanvas = function () {
    return false;
  };
  
  Container.prototype.getBBox = function () {
    
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    
    var children = this.getChildren().filter(function (child) {
      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      (0, _util2.each)(children, function (child) {
        var box = child.getBBox();
        xArr.push(box.minX, box.maxX);
        yArr.push(box.minY, box.maxY);
      });
      minX = (0, _util.min)(xArr);
      maxX = (0, _util.max)(xArr);
      minY = (0, _util.min)(yArr);
      maxY = (0, _util.max)(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box = {
      x: minX,
      y: minY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box;
  };
  
  Container.prototype.getCanvasBBox = function () {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    
    var children = this.getChildren().filter(function (child) {
      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      (0, _util2.each)(children, function (child) {
        var box = child.getCanvasBBox();
        xArr.push(box.minX, box.maxX);
        yArr.push(box.minY, box.maxY);
      });
      minX = (0, _util.min)(xArr);
      maxX = (0, _util.max)(xArr);
      minY = (0, _util.min)(yArr);
      maxY = (0, _util.max)(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box = {
      x: minX,
      y: minY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box;
  };
  Container.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg['children'] = [];
    return cfg;
  };
  Container.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === 'matrix') {
      var totalMatrix = this.getTotalMatrix();
      this._applyChildrenMarix(totalMatrix);
    }
  };
  
  Container.prototype.applyMatrix = function (matrix) {
    var preTotalMatrix = this.getTotalMatrix();
    _super.prototype.applyMatrix.call(this, matrix);
    var totalMatrix = this.getTotalMatrix();
    
    
    if (totalMatrix === preTotalMatrix) {
      return;
    }
    this._applyChildrenMarix(totalMatrix);
  };
  
  Container.prototype._applyChildrenMarix = function (totalMatrix) {
    var children = this.getChildren();
    (0, _util2.each)(children, function (child) {
      child.applyMatrix(totalMatrix);
    });
  };
  
  Container.prototype.addShape = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var type = args[0];
    var cfg = args[1];
    if ((0, _util2.isObject)(type)) {
      cfg = type;
    } else {
      cfg['type'] = type;
    }
    var shapeType = SHAPE_MAP[cfg.type];
    if (!shapeType) {
      shapeType = (0, _util2.upperFirst)(cfg.type);
      SHAPE_MAP[cfg.type] = shapeType;
    }
    var ShapeBase = this.getShapeBase();
    var shape = new ShapeBase[shapeType](cfg);
    this.add(shape);
    return shape;
  };
  Container.prototype.addGroup = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var groupClass = args[0],
      cfg = args[1];
    var group;
    if ((0, _util2.isFunction)(groupClass)) {
      if (cfg) {
        group = new groupClass(cfg);
      } else {
        group = new groupClass({
          
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group = new TmpGroupClass(tmpCfg);
    }
    this.add(group);
    return group;
  };
  Container.prototype.getCanvas = function () {
    var canvas;
    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get('canvas');
    }
    return canvas;
  };
  Container.prototype.getShape = function (x, y, ev) {
    
    if (!(0, _util2.isAllowCapture)(this)) {
      return null;
    }
    var children = this.getChildren();
    var shape;
    
    if (!this.isCanvas()) {
      var v = [x, y, 1];
      
      v = this.invertFromMatrix(v);
      if (!this.isClipped(v[0], v[1])) {
        shape = this._findShape(children, v[0], v[1], ev);
      }
    } else {
      shape = this._findShape(children, x, y, ev);
    }
    return shape;
  };
  Container.prototype._findShape = function (children, x, y, ev) {
    var shape = null;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if ((0, _util2.isAllowCapture)(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x, y, ev);
        } else if (child.isHit(x, y)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  };
  Container.prototype.add = function (element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get('timeline');
    var preParent = element.getParent();
    if (preParent) {
      removeChild(preParent, element, false);
    }
    element.set('parent', this);
    if (canvas) {
      setCanvas(element, canvas);
    }
    if (timeline) {
      setTimeline(element, timeline);
    }
    children.push(element);
    element.onCanvasChange('add');
    this._applyElementMatrix(element);
  };
  
  Container.prototype._applyElementMatrix = function (element) {
    var totalMatrix = this.getTotalMatrix();
    
    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };
  Container.prototype.getChildren = function () {
    return this.get('children');
  };
  Container.prototype.sort = function () {
    var children = this.getChildren();
    
    (0, _util2.each)(children, function (child, index) {
      child[INDEX] = index;
      return child;
    });
    children.sort(getComparer(function (obj1, obj2) {
      return obj1.get('zIndex') - obj2.get('zIndex');
    }));
    this.onCanvasChange('sort');
  };
  Container.prototype.clear = function () {
    this.set('clearing', true);
    if (this.destroyed) {
      return;
    }
    var children = this.getChildren();
    for (var i = children.length - 1; i >= 0; i--) {
      children[i].destroy(); 
    }

    this.set('children', []);
    this.onCanvasChange('clear');
    this.set('clearing', false);
  };
  Container.prototype.destroy = function () {
    if (this.get('destroyed')) {
      return;
    }
    this.clear();
    _super.prototype.destroy.call(this);
  };
    Container.prototype.getFirst = function () {
    return this.getChildByIndex(0);
  };
    Container.prototype.getLast = function () {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
    Container.prototype.getChildByIndex = function (index) {
    var children = this.getChildren();
    return children[index];
  };
    Container.prototype.getCount = function () {
    var children = this.getChildren();
    return children.length;
  };
    Container.prototype.contain = function (element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
    Container.prototype.removeChild = function (element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (this.contain(element)) {
      element.remove(destroy);
    }
  };
    Container.prototype.findAll = function (fn) {
    var rst = [];
    var children = this.getChildren();
    (0, _util2.each)(children, function (element) {
      if (fn(element)) {
        rst.push(element);
      }
      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn));
      }
    });
    return rst;
  };
    Container.prototype.find = function (fn) {
    var rst = null;
    var children = this.getChildren();
    (0, _util2.each)(children, function (element) {
      if (fn(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn);
      }
      if (rst) {
        return false;
      }
    });
    return rst;
  };
    Container.prototype.findById = function (id) {
    return this.find(function (element) {
      return element.get('id') === id;
    });
  };
    Container.prototype.findByClassName = function (className) {
    return this.find(function (element) {
      return element.get('className') === className;
    });
  };
    Container.prototype.findAllByName = function (name) {
    return this.findAll(function (element) {
      return element.get('name') === name;
    });
  };
  return Container;
}(_element.default);
var _default = Container;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _matrixUtil = __webpack_require__(32);
var _util2 = __webpack_require__(102);
var _matrix = __webpack_require__(243);
var _base = _interopRequireDefault(__webpack_require__(391));
var transform = _matrixUtil.ext.transform;
var MATRIX = 'matrix';
var CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type'];

var RESERVED_PORPS = ['repeat'];
var DELEGATION_SPLIT = ':';
var WILDCARD = '*';


function _cloneArrayAttr(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if ((0, _util.isArray)(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  (0, _util.each)(props, function (v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !(0, _util.isEqual)(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }
  var startTime = animation.startTime,
    delay = animation.delay,
    duration = animation.duration;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  (0, _util.each)(animations, function (item) {
    
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      (0, _util.each)(animation.toAttrs, function (v, k) {
        if (hasOwnProperty.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element = function (_super) {
  (0, _tslib.__extends)(Element, _super);
  function Element(cfg) {
    var _this = _super.call(this, cfg) || this;
        _this.attrs = {};
    var attrs = _this.getDefaultAttrs();
    (0, _util.mix)(attrs, cfg.attrs);
    _this.attrs = attrs;
    _this.initAttrs(attrs);
    _this.initAnimate(); 
    return _this;
  }
  
  Element.prototype.getDefaultCfg = function () {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
    Element.prototype.getDefaultAttrs = function () {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
    Element.prototype.onCanvasChange = function (changeType) {};
    Element.prototype.initAttrs = function (attrs) {};
    Element.prototype.initAnimate = function () {
    this.set('animable', true);
    this.set('animating', false);
  };
  Element.prototype.isGroup = function () {
    return false;
  };
  Element.prototype.getParent = function () {
    return this.get('parent');
  };
  Element.prototype.getCanvas = function () {
    return this.get('canvas');
  };
  Element.prototype.attr = function () {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var name = args[0],
      value = args[1];
    if (!name) return this.attrs;
    if ((0, _util.isObject)(name)) {
      for (var k in name) {
        this.setAttr(k, name[k]);
      }
      this.afterAttrsChange(name);
      return this;
    }
    if (args.length === 2) {
      this.setAttr(name, value);
      this.afterAttrsChange((_a = {}, _a[name] = value, _a));
      return this;
    }
    return this.attrs[name];
  };
  
  Element.prototype.isClipped = function (refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
    Element.prototype.setAttr = function (name, value) {
    var originValue = this.attrs[name];
    if (originValue !== value) {
      this.attrs[name] = value;
      this.onAttrChange(name, value, originValue);
    }
  };
    Element.prototype.onAttrChange = function (name, value, originValue) {
    if (name === 'matrix') {
      this.set('totalMatrix', null);
    }
  };
    Element.prototype.afterAttrsChange = function (targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;
      if (applyTo) {
        applyTo.onCanvasChange('clip');
      }
    } else {
      this.onCanvasChange('attr');
    }
  };
  Element.prototype.show = function () {
    
    this.set('visible', true);
    this.onCanvasChange('show');
    return this;
  };
  Element.prototype.hide = function () {
    
    this.set('visible', false);
    this.onCanvasChange('hide');
    return this;
  };
  Element.prototype.setZIndex = function (zIndex) {
    this.set('zIndex', zIndex);
    var parent = this.getParent();
    if (parent) {
      
      parent.sort();
    }
    return this;
  };
  Element.prototype.toFront = function () {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    var el = this.get('el');
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.push(this);
    this.onCanvasChange('zIndex');
  };
  Element.prototype.toBack = function () {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    var el = this.get('el');
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.unshift(this);
    this.onCanvasChange('zIndex');
  };
  Element.prototype.remove = function (destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    var parent = this.getParent();
    if (parent) {
      (0, _util2.removeFromArray)(parent.getChildren(), this);
      if (!parent.get('clearing')) {
        
        this.onCanvasChange('remove');
      }
    } else {
      this.onCanvasChange('remove');
    }
    if (destroy) {
      this.destroy();
    }
  };
  Element.prototype.resetMatrix = function () {
    this.attr(MATRIX, this.getDefaultMatrix());
    this.onCanvasChange('matrix');
  };
  Element.prototype.getMatrix = function () {
    return this.attr(MATRIX);
  };
  Element.prototype.setMatrix = function (m) {
    this.attr(MATRIX, m);
    this.onCanvasChange('matrix');
  };
  
  Element.prototype.getTotalMatrix = function () {
    var totalMatrix = this.cfg.totalMatrix;
    if (!totalMatrix) {
      var currentMatrix = this.attr('matrix');
      var parentMatrix = this.cfg.parentMatrix;
      if (parentMatrix && currentMatrix) {
        totalMatrix = (0, _matrix.multiplyMatrix)(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }
      this.set('totalMatrix', totalMatrix);
    }
    return totalMatrix;
  };
  
  Element.prototype.applyMatrix = function (matrix) {
    var currentMatrix = this.attr('matrix');
    var totalMatrix = null;
    if (matrix && currentMatrix) {
      totalMatrix = (0, _matrix.multiplyMatrix)(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }
    this.set('totalMatrix', totalMatrix);
    this.set('parentMatrix', matrix);
  };
    Element.prototype.getDefaultMatrix = function () {
    return null;
  };
  
  Element.prototype.applyToMatrix = function (v) {
    var matrix = this.attr('matrix');
    if (matrix) {
      return (0, _matrix.multiplyVec2)(matrix, v);
    }
    return v;
  };
  
  Element.prototype.invertFromMatrix = function (v) {
    var matrix = this.attr('matrix');
    if (matrix) {
      var invertMatrix = (0, _matrix.invert)(matrix);
      if (invertMatrix) {
        return (0, _matrix.multiplyVec2)(invertMatrix, v);
      }
    }
    return v;
  };
  
  Element.prototype.setClip = function (clipCfg) {
    var canvas = this.getCanvas();
    
    
    
    
    
    
    
    var clipShape = null;
    
    if (clipCfg) {
      var ShapeBase = this.getShapeBase();
      var shapeType = (0, _util.upperFirst)(clipCfg.type);
      var Cons = ShapeBase[shapeType];
      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas: canvas
        });
      }
    }
    this.set('clipShape', clipShape);
    this.onCanvasChange('clip');
    return clipShape;
  };
  Element.prototype.getClip = function () {
    
    var clipShape = this.cfg.clipShape;
    
    if (!clipShape) {
      return null;
    }
    return clipShape;
  };
  Element.prototype.clone = function () {
    var _this = this;
    var originAttrs = this.attrs;
    var attrs = {};
    (0, _util.each)(originAttrs, function (i, k) {
      if ((0, _util.isArray)(originAttrs[k])) {
        attrs[k] = _cloneArrayAttr(originAttrs[k]);
      } else {
        attrs[k] = originAttrs[k];
      }
    });
    var cons = this.constructor;
    
    var clone = new cons({
      attrs: attrs
    });
    (0, _util.each)(CLONE_CFGS, function (cfgName) {
      clone.set(cfgName, _this.get(cfgName));
    });
    return clone;
  };
  Element.prototype.destroy = function () {
    var destroyed = this.destroyed;
    if (destroyed) {
      return;
    }
    this.attrs = {};
    _super.prototype.destroy.call(this);
    
  };
    Element.prototype.isAnimatePaused = function () {
    return this.get('_pause').isPaused;
  };
    Element.prototype.animate = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!this.get('timeline') && !this.get('canvas')) {
      return;
    }
    this.set('animating', true);
    var timeline = this.get('timeline');
    if (!timeline) {
      timeline = this.get('canvas').get('timeline');
      this.set('timeline', timeline);
    }
    var animations = this.get('animations') || [];
    
    if (!timeline.timer) {
      timeline.initTimer();
    }
    var toAttrs = args[0],
      duration = args[1],
      _a = args[2],
      easing = _a === void 0 ? 'easeLinear' : _a,
      _b = args[3],
      callback = _b === void 0 ? _util.noop : _b,
      _c = args[4],
      delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg;
    
    if ((0, _util.isFunction)(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if ((0, _util.isObject)(toAttrs) && toAttrs.onFrame) {
      
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    }
    
    if ((0, _util.isObject)(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || 'easeLinear';
      delay = animateCfg.delay || 0;
      
      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || _util.noop;
      pauseCallback = animateCfg.pauseCallback || _util.noop;
      resumeCallback = animateCfg.resumeCallback || _util.noop;
    } else {
      
      if ((0, _util.isNumber)(callback)) {
        delay = callback;
        callback = null;
      }
      
      if ((0, _util.isFunction)(easing)) {
        callback = easing;
        easing = 'easeLinear';
      } else {
        easing = easing || 'easeLinear';
      }
    }
    var formatToAttrs = getFormatToAttrs(toAttrs, this);
    var animation = {
      fromAttrs: getFormatFromAttrs(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration: duration,
      easing: easing,
      repeat: repeat,
      callback: callback,
      pauseCallback: pauseCallback,
      resumeCallback: resumeCallback,
      delay: delay,
      startTime: timeline.getTime(),
      id: (0, _util.uniqueId)(),
      onFrame: onFrame,
      pathFormatted: false
    };
    
    if (animations.length > 0) {
      
      animations = checkExistedAttrs(animations, animation);
    } else {
      
      timeline.addAnimator(this);
    }
    animations.push(animation);
    this.set('animations', animations);
    this.set('_pause', {
      isPaused: false
    });
  };
    Element.prototype.stopAnimate = function (toEnd) {
    var _this = this;
    if (toEnd === void 0) {
      toEnd = true;
    }
    var animations = this.get('animations');
    (0, _util.each)(animations, function (animation) {
      
      if (toEnd) {
        if (animation.onFrame) {
          _this.attr(animation.onFrame(1));
        } else {
          _this.attr(animation.toAttrs);
        }
      }
      if (animation.callback) {
        
        animation.callback();
      }
    });
    this.set('animating', false);
    this.set('animations', []);
  };
    Element.prototype.pauseAnimate = function () {
    var timeline = this.get('timeline');
    var animations = this.get('animations');
    var pauseTime = timeline.getTime();
    (0, _util.each)(animations, function (animation) {
      animation._paused = true;
      animation._pauseTime = pauseTime;
      if (animation.pauseCallback) {
        
        animation.pauseCallback();
      }
    });
    
    this.set('_pause', {
      isPaused: true,
      pauseTime: pauseTime
    });
    return this;
  };
    Element.prototype.resumeAnimate = function () {
    var timeline = this.get('timeline');
    var current = timeline.getTime();
    var animations = this.get('animations');
    var pauseTime = this.get('_pause').pauseTime;
    
    (0, _util.each)(animations, function (animation) {
      animation.startTime = animation.startTime + (current - pauseTime);
      animation._paused = false;
      animation._pauseTime = null;
      if (animation.resumeCallback) {
        animation.resumeCallback();
      }
    });
    this.set('_pause', {
      isPaused: false
    });
    this.set('animations', animations);
    return this;
  };
    Element.prototype.emitDelegation = function (type, eventObj) {
    var _this = this;
    var paths = eventObj.propagationPath;
    var events = this.getEvents();
    var relativeShape;
    if (type === 'mouseenter') {
      relativeShape = eventObj.fromShape;
    } else if (type === 'mouseleave') {
      relativeShape = eventObj.toShape;
    }
    var _loop_1 = function _loop_1(i) {
      var element = paths[i];
      
      var name_1 = element.get('name');
      if (name_1) {
        
        if (
        
        (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && (0, _util2.isParent)(element, relativeShape)) {
          return "break";
        }
        if ((0, _util.isArray)(name_1)) {
          (0, _util.each)(name_1, function (subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };
    var this_1 = this;
    
    for (var i = 0; i < paths.length; i++) {
      var state_1 = _loop_1(i);
      if (state_1 === "break") break;
    }
  };
  Element.prototype.emitDelegateEvent = function (element, name, eventObj) {
    var events = this.getEvents();
    
    var eventName = name + DELEGATION_SPLIT + eventObj.type;
    if (events[eventName] || events[WILDCARD]) {
      
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this;
      
      eventObj.delegateObject = element.get('delegateObject');
      this.emit(eventName, eventObj);
    }
  };
    Element.prototype.translate = function (translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }
    if (translateY === void 0) {
      translateY = 0;
    }
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['t', translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
    Element.prototype.move = function (targetX, targetY) {
    var x = this.attr('x') || 0;
    var y = this.attr('y') || 0;
    this.translate(targetX - x, targetY - y);
    return this;
  };
    Element.prototype.moveTo = function (targetX, targetY) {
    return this.move(targetX, targetY);
  };
    Element.prototype.scale = function (ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
    Element.prototype.rotate = function (radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['r', radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
    Element.prototype.rotateAtStart = function (rotate) {
    var _a = this.attr(),
      x = _a.x,
      y = _a.y;
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['t', -x, -y], ['r', rotate], ['t', x, y]]);
    this.setMatrix(newMatrix);
    return this;
  };
    Element.prototype.rotateAtPoint = function (x, y, rotate) {
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['t', -x, -y], ['r', rotate], ['t', x, y]]);
    this.setMatrix(newMatrix);
    return this;
  };
  return Element;
}(_base.default);
var _default = Element;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromMat2d = fromMat2d;
exports.fromMat4 = fromMat4;
exports.fromQuat = fromQuat;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }


function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

function transpose(out, a) {
  
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; 

  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

function translate(out, a, v) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    x = v[0],
    y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

function rotate(out, a, rad) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}

function scale(out, a, v) {
  var x = v[0],
    y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}

function normalFromMat4(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; 

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7],
    a8 = a[8];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

var mul = multiply;
exports.mul = mul;
var sub = subtract;
exports.sub = sub;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = void 0;
exports.orthoNO = orthoNO;
exports.orthoZO = orthoZO;
exports.perspective = void 0;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.perspectiveNO = perspectiveNO;
exports.perspectiveZO = perspectiveZO;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }


function create() {
  var out = new glMatrix.ARRAY_TYPE(16);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function transpose(out, a) {
  
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a03 = a[3];
    var a12 = a[6],
      a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; 

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; 

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15]; 

  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

function translate(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}

function scale(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

function rotate(out, a, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; 

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; 

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } 

  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } 

  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } 

  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function fromRotation(out, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; 

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); 

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); 

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); 

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function fromRotationTranslation(out, q, v) {
  
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; 

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}

function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}

function fromRotationTranslationScale(out, q, v, s) {
  
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

var perspective = perspectiveNO;
exports.perspective = perspective;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

var ortho = orthoNO;
exports.ortho = ortho;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2];
  var z0 = eyex - target[0],
    z1 = eyey - target[1],
    z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1,
    x1 = upz * z0 - upx * z2,
    x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var a8 = a[8],
    a9 = a[9],
    a10 = a[10],
    a11 = a[11];
  var a12 = a[12],
    a13 = a[13],
    a14 = a[14],
    a15 = a[15];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  var b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  var b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11];
  var b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

var mul = multiply;
exports.mul = mul;
var sub = subtract;
exports.sub = sub;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = void 0;
exports.calculateW = calculateW;
exports.clone = void 0;
exports.conjugate = conjugate;
exports.copy = void 0;
exports.create = create;
exports.exactEquals = exports.equals = exports.dot = void 0;
exports.exp = exp;
exports.fromEuler = fromEuler;
exports.fromMat3 = fromMat3;
exports.fromValues = void 0;
exports.getAngle = getAngle;
exports.getAxisAngle = getAxisAngle;
exports.identity = identity;
exports.invert = invert;
exports.lerp = exports.length = exports.len = void 0;
exports.ln = ln;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = void 0;
exports.pow = pow;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
exports.setAxisAngle = setAxisAngle;
exports.slerp = slerp;
exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
exports.str = str;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
var mat3 = _interopRequireWildcard(__webpack_require__(394));
var vec3 = _interopRequireWildcard(__webpack_require__(171));
var vec4 = _interopRequireWildcard(__webpack_require__(397));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }


function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}

function multiply(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var by = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bz = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

function calculateW(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

function exp(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}

function ln(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}

function slerp(out, a, b, t) {
  
  
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  var omega, cosom, sinom, scale0, scale1; 

  cosom = ax * bx + ay * by + az * bz + aw * bw; 

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } 

  if (1.0 - cosom > glMatrix.EPSILON) {
    
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    
    
    scale0 = 1.0 - t;
    scale1 = t;
  } 

  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}

function random(out) {
  
  
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}

function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; 

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

function fromMat3(out, m) {
  
  
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0.0) {
    
    fRoot = Math.sqrt(fTrace + 1.0); 

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; 

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

var clone = vec4.clone;
exports.clone = clone;
var fromValues = vec4.fromValues;
exports.fromValues = fromValues;
var copy = vec4.copy;
exports.copy = copy;
var set = vec4.set;
exports.set = set;
var add = vec4.add;
exports.add = add;
var mul = multiply;
exports.mul = mul;
var scale = vec4.scale;
exports.scale = scale;
var dot = vec4.dot;
exports.dot = dot;
var lerp = vec4.lerp;
exports.lerp = lerp;
var length = vec4.length;
exports.length = length;
var len = length;
exports.len = len;
var squaredLength = vec4.squaredLength;
exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
exports.exactEquals = exactEquals;
var equals = vec4.equals;
exports.equals = equals;
var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
exports.rotationTo = rotationTo;
var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
exports.sqlerp = sqlerp;
var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();
exports.setAxes = setAxes;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }


function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
    B = v[0] * w[2] - v[2] * w[0],
    C = v[0] * w[3] - v[3] * w[0],
    D = v[1] * w[2] - v[2] * w[1],
    E = v[1] * w[3] - v[3] * w[1],
    F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

function random(out, scale) {
  scale = scale || 1.0; 
  
  

  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

function transformQuat(out, a, q) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3]; 

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; 

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

var sub = subtract;
exports.sub = sub;
var mul = multiply;
exports.mul = mul;
var div = divide;
exports.div = div;
var dist = distance;
exports.dist = dist;
var sqrDist = squaredDistance;
exports.sqrDist = sqrDist;
var len = length;
exports.len = len;
var sqrLen = squaredLength;
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();
exports.forEach = forEach;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(__webpack_require__(79));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }


function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.hypot(x, y);
}

function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}

function length(a) {
  var x = a[0],
    y = a[1];
  return Math.hypot(x, y);
}

function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

function rotate(out, a, b, rad) {
  
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad); 

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}

function angle(a, b) {
  var x1 = a[0],
    y1 = a[1],
    x2 = b[0],
    y2 = b[1],
    
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
    
    cosine = mag && (x1 * x2 + y1 * y2) / mag; 

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

var len = length;
exports.len = len;
var sub = subtract;
exports.sub = sub;
var mul = multiply;
exports.mul = mul;
var div = divide;
exports.div = div;
var dist = distance;
exports.dist = dist;
var sqrDist = squaredDistance;
exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
exports.forEach = forEach;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.radians = exports.degrees = void 0;
var radians = Math.PI / 180;
exports.radians = radians;
var degrees = 180 / Math.PI;
exports.degrees = degrees;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgbBasisClosed = exports.rgbBasis = exports.default = void 0;
var _d3Color = __webpack_require__(60);
var _basis = _interopRequireDefault(__webpack_require__(247));
var _basisClosed = _interopRequireDefault(__webpack_require__(401));
var _color = _interopRequireWildcard(__webpack_require__(109));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _default = function rgbGamma(y) {
  var color = (0, _color.gamma)(y);
  function rgb(start, end) {
    var r = color((start = (0, _d3Color.rgb)(start)).r, (end = (0, _d3Color.rgb)(end)).r),
      g = color(start.g, end.g),
      b = color(start.b, end.b),
      opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb.gamma = rgbGamma;
  return rgb;
}(1);
exports.default = _default;
function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
      r = new Array(n),
      g = new Array(n),
      b = new Array(n),
      i,
      color;
    for (i = 0; i < n; ++i) {
      color = (0, _d3Color.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}
var rgbBasis = rgbSpline(_basis.default);
exports.rgbBasis = rgbBasis;
var rgbBasisClosed = rgbSpline(_basisClosed.default);
exports.rgbBasisClosed = rgbBasisClosed;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _basis = __webpack_require__(247);
function _default(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
      v0 = values[(i + n - 1) % n],
      v1 = values[i % n],
      v2 = values[(i + 1) % n],
      v3 = values[(i + 2) % n];
    return (0, _basis.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = function _default(x) {
  return function () {
    return x;
  };
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.genericArray = genericArray;
var _value = _interopRequireDefault(__webpack_require__(172));
var _numberArray = _interopRequireWildcard(__webpack_require__(248));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _default(a, b) {
  return ((0, _numberArray.isNumberArray)(b) ? _numberArray.default : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0,
    na = a ? Math.min(nb, a.length) : 0,
    x = new Array(na),
    c = new Array(nb),
    i;
  for (i = 0; i < na; ++i) {
    x[i] = (0, _value.default)(a[i], b[i]);
  }
  for (; i < nb; ++i) {
    c[i] = b[i];
  }
  return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }
    return c;
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(a, b) {
  var d = new Date();
  return a = +a, b = +b, function (t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var _value = _interopRequireDefault(__webpack_require__(172));
function _default(a, b) {
  var i = {},
    c = {},
    k;
  if (a === null || (0, _typeof2.default)(a) !== "object") a = {};
  if (b === null || (0, _typeof2.default)(b) !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = (0, _value.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }
    return c;
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _number = _interopRequireDefault(__webpack_require__(173));
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  reB = new RegExp(reA.source, "g");
function zero(b) {
  return function () {
    return b;
  };
}
function one(b) {
  return function (t) {
    return b(t) + "";
  };
}
function _default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
    // scan index for next number in b
    am,
    // current match in a
    bm,
    // current match in b
    bs,
    // string preceding current number in b, if any
    i = -1,
    // index in s
    s = [],
    // string constants and placeholders
    q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: (0, _number.default)(am, bm)
      });
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }
    return s.join("");
  });
}

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEasing = getEasing;
exports.registerEasing = registerEasing;
var d3Ease = _interopRequireWildcard(__webpack_require__(772));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var EASING_MAP = {};
function getEasing(type) {
  
  return EASING_MAP[type.toLowerCase()] || d3Ease[type];
}
function registerEasing(type, easeFn) {
  EASING_MAP[type.toLowerCase()] = easeFn;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tpmt = tpmt;

function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nearestPoint = nearestPoint;
exports.snapLength = snapLength;
var _util = __webpack_require__(87);
var EPSILON = 0.0001;
function nearestPoint(xArr, yArr, x, y, tCallback, length) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length && length > 200) {
    segNum = length / 10;
  }
  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = (0, _util.distance)(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = (0, _util.distance)(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = (0, _util.distance)(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}

function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += (0, _util.distance)(x, y, nextX, nextY);
  }
  return totalLength / 2;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.angleAtSegments = angleAtSegments;
exports.distanceAtSegment = distanceAtSegment;
exports.lengthOfSegment = lengthOfSegment;
exports.pointAtSegments = pointAtSegments;
var _line = _interopRequireDefault(__webpack_require__(174));
var _util = __webpack_require__(87);
function analyzePoints(points) {
  
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length_1 = (0, _util.distance)(from[0], from[1], to[0], to[1]);
    var seg = {
      from: from,
      to: to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return {
    segments: segments,
    totalLength: totalLength
  };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += (0, _util.distance)(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _a = analyzePoints(points),
    segments = _a.segments,
    totalLength = _a.totalLength;
  
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  
  var startRatio = 0;
  var point = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from,
      to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point = _line.default.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t) {
  
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _a = analyzePoints(points),
    segments = _a.segments,
    totalLength = _a.totalLength;
  
  var startRatio = 0;
  var angle = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from,
      to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle;
}
function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points.length - 1; i++) {
    var point = points[i];
    var nextPoint = points[i + 1];
    var distance_1 = _line.default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _segments = __webpack_require__(410);
var _util = __webpack_require__(87);
var _default = {
    box: function box(points) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return (0, _util.getBBoxByArray)(xArr, yArr);
  },
    length: function length(points) {
    return (0, _segments.lengthOfSegment)(points);
  },
    pointAt: function pointAt(points, t) {
    return (0, _segments.pointAtSegments)(points, t);
  },
    pointDistance: function pointDistance(points, x, y) {
    return (0, _segments.distanceAtSegment)(points, x, y);
  },
    tangentAngle: function tangentAngle(points, t) {
    return (0, _segments.angleAtSegments)(points, t);
  }
};
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assembleFont = assembleFont;
exports.getLineSpaceing = getLineSpaceing;
exports.getTextHeight = getTextHeight;
exports.getTextWidth = getTextWidth;
var _util = __webpack_require__(102);
var _offscreen = __webpack_require__(413);
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;
  if ((0, _util.isString)(text)) {
    lineCount = text.split('\n').length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text, font) {
  var context = (0, _offscreen.getOffScreenContext)(); 
  var width = 0;
  
  if ((0, _util.isNil)(text) || text === '') {
    return width;
  }
  context.save();
  context.font = font;
  if ((0, _util.isString)(text) && text.includes('\n')) {
    var textArr = text.split('\n');
    (0, _util.each)(textArr, function (subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize,
    fontFamily = attrs.fontFamily,
    fontWeight = attrs.fontWeight,
    fontStyle = attrs.fontStyle,
    fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(' ').trim();
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffScreenContext = getOffScreenContext;

var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext('2d');
  }
  return offScreenCtx;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = __webpack_require__(0);
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path = p || [];
  if ((0, _util.isArray)(path)) {
    return path;
  }
  if ((0, _util.isString)(path)) {
    path = path.match(regexTags);
    (0, _util.each)(path, function (item, index) {
      
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        
        item.splice(1, 0, item[0].substr(1));
        
        item[0] = tag;
      }
      
      (0, _util.each)(item, function (sub, i) {
        if (!isNaN(sub)) {
          
          item[i] = +sub;
        }
      });
      
      path[index] = item;
    });
    return path;
  }
}
var _default = parsePath;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rectPath;
function rectPath(x, y, w, h, r) {
  if (r) {
    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }
  return [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
  
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pathToCurve;
var _path2Absolute = _interopRequireDefault(__webpack_require__(417));
var _segment2Cubic = __webpack_require__(807);
function pathToCurve(path, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  var pathArray = (0, _path2Absolute.default)(path);
  var params = {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    x: 0,
    y: 0,
    qx: null,
    qy: null
  };
  var allPathCommands = [];
  var pathCommand = '';
  var ii = pathArray.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i = 0; i < ii; i += 1) {
    if (pathArray[i]) pathCommand = pathArray[i][0];
    allPathCommands[i] = pathCommand;
    pathArray[i] = (0, _segment2Cubic.segmentToCubic)(pathArray[i], params);
    fixArc(pathArray, allPathCommands, i);
    ii = pathArray.length; // solves curveArrays ending in Z
    // keep Z command account for lineJoin
    // @see https://github.com/antvis/util/issues/68
    if (pathCommand === 'Z') {
      zCommandIndexes.push(i);
    }
    segment = pathArray[i];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [pathArray, zCommandIndexes];
  } else {
    return pathArray;
  }
}
function fixArc(pathArray, allPathCommands, i) {
  if (pathArray[i].length > 7) {
    pathArray[i].shift();
    var pi = pathArray[i];
    
    var ni = i;
    while (pi.length) {
      
      allPathCommands[i] = 'A';
      
      pathArray.splice(ni += 1, 0, ['C'].concat(pi.splice(0, 6)));
    }
    pathArray.splice(i, 1);
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pathToAbsolute;
var _parsePathString = _interopRequireDefault(__webpack_require__(418));
var REGEX_MD = /[a-z]/;
function toSymmetry(p, c) {
  return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];
}
function pathToAbsolute(pathString) {
  var pathArray = (0, _parsePathString.default)(pathString);
  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }
  var needProcess = false; 
  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0];
    
    if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  
  
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];
  if (first[0] === 'M' || first[0] === 'm') {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }
  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1]; 
    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r[0] = upCmd;
      switch (upCmd) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case 'V':
          r[1] = +pa[1] + y;
          break;
        case 'H':
          r[1] = +pa[1] + x;
          break;
        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;
          r[1] = mx;
          r[2] = my;
          break;
        
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      
      r = pathArray[i];
    }
    
    switch (upCmd) {
      case 'Z':
        x = +mx;
        y = +my;
        break;
      case 'H':
        x = r[1];
        r = ['L', x, y];
        break;
      case 'V':
        y = r[1];
        r = ['L', x, y];
        break;
      case 'T':
        x = r[1];
        y = r[2];
        
        
        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ['Q', symetricT[0], symetricT[1], x, y];
        break;
      case 'S':
        x = r[r.length - 2];
        y = r[r.length - 1];
        
        
        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;
      case 'M':
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
    res.push(r);
  }
  return res;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parsePathString;
var _util = __webpack_require__(0);
var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');

function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  if ((0, _util.isArray)(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function (a, b) {
      b && params.push(+b);
    });
    if (name === 'm' && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = 'l';
      b = b === 'm' ? 'l' : 'L';
    }
    if (name === 'o' && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === 'r') {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return '';
  });
  return data;
}

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getArcParams;
exports.isSamePoint = isSamePoint;
var _util = __webpack_require__(0);
// 向量长度
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
// u.v/|u||v|，计算夹角的余弦值
function vRatio(u, v) {
  // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
// 向量角度
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
/**
 * 判断两个点是否重合，点坐标的格式为 [x, y]
 * @param {Array} point1 第一个点
 * @param {Array} point2 第二个点
 */
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = (0, _util.mod)((0, _util.toRadian)(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  // 弧形起点坐标
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  // 弧形终点坐标
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  // 椭圆圆心坐标
  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  // 起始点的单位向量
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  // 终止点的单位向量
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  // 计算起始点和圆心的连线，与 x 轴正方向的夹角
  var theta = vAngle([1, 0], u);
  // 计算圆弧起始点和终止点与椭圆圆心连线的夹角
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx: cx,
    cy: cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getLineIntersect;
var isBetween = function isBetween(value, min, max) {
  return value >= min && value <= max;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance = 0.001;
  var E = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point = null;
  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {
    var s = (E.x * D1.y - E.y * D1.x) / kross;
    var t = (E.x * D0.y - E.y * D0.x) / kross;
    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
      point = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }
  return point;
}
;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isInPolygon;
/**
 * @fileoverview 判断点是否在多边形内
 * @author dxq613@gmail.com
 */
// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526
var tolerance = 1e-6;
// 三态函数，判断两个double在eps精度下的大小关系
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
// 判断点Q是否在p1和p2的线段上
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
// 判断点P在多边形内-射线法
function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    // svg 中点小于 3 个时，不显示，也无法被拾取
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      // 点在多边形一条边上
      return true;
    }
    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
    // 后一个判断被测点 在 射线与边交点 的左边
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  getAdjust: true,
  registerAdjust: true,
  Adjust: true
};
Object.defineProperty(exports, "Adjust", {
  enumerable: true,
  get: function get() {
    return _adjust.default;
  }
});
Object.defineProperty(exports, "getAdjust", {
  enumerable: true,
  get: function get() {
    return _factory.getAdjust;
  }
});
Object.defineProperty(exports, "registerAdjust", {
  enumerable: true,
  get: function get() {
    return _factory.registerAdjust;
  }
});
var _factory = __webpack_require__(816);
var _adjust = _interopRequireDefault(__webpack_require__(110));
var _dodge = _interopRequireDefault(__webpack_require__(817));
var _jitter = _interopRequireDefault(__webpack_require__(818));
var _stack = _interopRequireDefault(__webpack_require__(819));
var _symmetric = _interopRequireDefault(__webpack_require__(820));
var _interface = __webpack_require__(423);
Object.keys(_interface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interface[key];
    }
  });
});
// 注册内置的 adjust
(0, _factory.registerAdjust)('Dodge', _dodge.default);
(0, _factory.registerAdjust)('Jitter', _jitter.default);
(0, _factory.registerAdjust)('Stack', _stack.default);
(0, _factory.registerAdjust)('Symmetric', _symmetric.default);


 }),
 (function(module, exports, __webpack_require__) {

"use strict";


 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return _scale.Scale;
  }
});
var _scale = __webpack_require__(66);

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTickMethod = getTickMethod;
exports.registerTickMethod = registerTickMethod;
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _base = _interopRequireDefault(__webpack_require__(141));
var Category = function (_super) {
  (0, _tslib.__extends)(Category, _super);
  function Category() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'cat';
    _this.isCategory = true;
    return _this;
  }
  Category.prototype.buildIndexMap = function () {
    if (!this.translateIndexMap) {
      this.translateIndexMap = new Map();
      
      for (var i = 0; i < this.values.length; i++) {
        this.translateIndexMap.set(this.values[i], i);
      }
    }
  };
  Category.prototype.translate = function (value) {
    
    this.buildIndexMap();
    
    var idx = this.translateIndexMap.get(value);
    if (idx === undefined) {
      idx = (0, _util.isNumber)(value) ? value : NaN;
    }
    return idx;
  };
  Category.prototype.scale = function (value) {
    var order = this.translate(value);
    
    
    
    
    var percent = this.calcPercent(order, this.min, this.max);
    return this.calcValue(percent, this.rangeMin(), this.rangeMax());
  };
  Category.prototype.invert = function (scaledValue) {
    var domainRange = this.max - this.min;
    var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
    var idx = Math.round(domainRange * percent) + this.min;
    if (idx < this.min || idx > this.max) {
      return NaN;
    }
    return this.values[idx];
  };
  Category.prototype.getText = function (value) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var v = value;
    
    if ((0, _util.isNumber)(value) && !this.values.includes(value)) {
      v = this.values[v];
    }
    return _super.prototype.getText.apply(this, (0, _tslib.__spreadArrays)([v], args));
  };
  
  Category.prototype.initCfg = function () {
    this.tickMethod = 'cat';
  };
  
  Category.prototype.setDomain = function () {
    
    if ((0, _util.isNil)(this.getConfig('min'))) {
      this.min = 0;
    }
    if ((0, _util.isNil)(this.getConfig('max'))) {
      var size = this.values.length;
      this.max = size > 1 ? size - 1 : size;
    }
    
    if (this.translateIndexMap) {
      this.translateIndexMap = undefined;
    }
  };
  return Category;
}(_base.default);
var _default = Category;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _base = _interopRequireDefault(__webpack_require__(176));
var Linear = function (_super) {
  (0, _tslib.__extends)(Linear, _super);
  function Linear() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'linear';
    _this.isLinear = true;
    return _this;
  }
  Linear.prototype.invert = function (value) {
    var percent = this.getInvertPercent(value);
    return this.min + percent * (this.max - this.min);
  };
  Linear.prototype.initCfg = function () {
    this.tickMethod = 'wilkinson-extended';
    this.nice = false;
  };
  return Linear;
}(_base.default);
var _default = Linear;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _base = _interopRequireDefault(__webpack_require__(176));
var Quantize = function (_super) {
  (0, _tslib.__extends)(Quantize, _super);
  function Quantize() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'quantize';
    return _this;
  }
  Quantize.prototype.invert = function (value) {
    var ticks = this.ticks;
    var length = ticks.length;
    var percent = this.getInvertPercent(value);
    var minIndex = Math.floor(percent * (length - 1));
    
    if (minIndex >= length - 1) {
      return (0, _util.last)(ticks);
    }
    
    if (minIndex < 0) {
      return (0, _util.head)(ticks);
    }
    var minTick = ticks[minIndex];
    var nextTick = ticks[minIndex + 1];
    
    var minIndexPercent = minIndex / (length - 1);
    var maxIndexPercent = (minIndex + 1) / (length - 1);
    return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
  };
  Quantize.prototype.initCfg = function () {
    this.tickMethod = 'r-pretty';
    this.tickCount = 5;
    this.nice = true;
  };
  Quantize.prototype.calculateTicks = function () {
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      
      if ((0, _util.last)(ticks) !== this.max) {
        ticks.push(this.max);
      }
      if ((0, _util.head)(ticks) !== this.min) {
        ticks.unshift(this.min);
      }
    }
    return ticks;
  };
  
  Quantize.prototype.getScalePercent = function (value) {
    var ticks = this.ticks;
    
    if (value < (0, _util.head)(ticks)) {
      return 0;
    }
    
    if (value > (0, _util.last)(ticks)) {
      return 1;
    }
    var minIndex = 0;
    (0, _util.each)(ticks, function (tick, index) {
      if (value >= tick) {
        minIndex = index;
      } else {
        return false;
      }
    });
    return minIndex / (ticks.length - 1);
  };
  return Quantize;
}(_base.default);
var _default = Quantize;
exports.default = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateCatTicks;
var _util = __webpack_require__(0);
function calculateCatTicks(cfg) {
  var values = cfg.values,
    tickInterval = cfg.tickInterval,
    tickCount = cfg.tickCount,
    showLast = cfg.showLast;
  if ((0, _util.isNumber)(tickInterval)) {
    var ticks_1 = (0, _util.filter)(values, function (__, i) {
      return i % tickInterval === 0;
    });
    var lastValue = (0, _util.last)(values);
    if (showLast && (0, _util.last)(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len = values.length;
  var min = cfg.min,
    max = cfg.max;
  if ((0, _util.isNil)(min)) {
    min = 0;
  }
  if ((0, _util.isNil)(max)) {
    max = values.length - 1;
  }
  if (!(0, _util.isNumber)(tickCount) || tickCount >= len) return values.slice(min, max + 1);
  if (tickCount <= 0 || max <= 0) return [];
  var interval = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));
  var ticks = [];
  var idx = min;
  for (var i = 0; i < tickCount; i++) {
    if (idx >= max) break;
    idx = Math.min(min + i * interval, max);
    if (i === tickCount - 1 && showLast) ticks.push(values[max]);else ticks.push(values[idx]);
  }
  return ticks;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prettyNumber = prettyNumber;

function prettyNumber(n) {
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pretty;
var _prettyNumber = __webpack_require__(430);
function pretty(min, max, m) {
  if (m === void 0) {
    m = 5;
  }
  if (min === max) {
    return {
      max: max,
      min: min,
      ticks: [min]
    };
  }
  var n = m < 0 ? 0 : Math.round(m);
  if (n === 0) return {
    max: max,
    min: min,
    ticks: []
  };
    var h = 1.5; 
  var h5 = 0.5 + 1.5 * h; 
  
  var d = max - min;
  var c = d / n;
  
  
  
  
  
  
  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var unit = base;
  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;
    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;
      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max / unit);
  var ns = Math.floor(min / unit);
  var hi = Math.max(nu * unit, max);
  var lo = Math.min(ns * unit, min);
  var size = Math.floor((hi - lo) / unit) + 1;
  var ticks = new Array(size);
  for (var i = 0; i < size; i++) {
    ticks[i] = (0, _prettyNumber.prettyNumber)(lo + i * unit);
  }
  return {
    min: lo,
    max: hi,
    ticks: ticks
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.propagationDelegate = propagationDelegate;
var _gBase = __webpack_require__(26);
function propagationDelegate(group, eventName, eventObject) {
  var event = new _gBase.Event(eventName, eventObject);
  event.target = group;
  event.propagationPath.push(group); 
  group.emitDelegation(eventName, event);
  var parent = group.getParent();
  
  while (parent) {
    
    parent.emitDelegation(eventName, event);
    event.propagationPath.push(parent);
    parent = parent.getParent();
  }
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStatesStyle = getStatesStyle;
var _util = __webpack_require__(0);

function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style"; 
  var styles = null;
  (0, _util.each)(stateStyles, function (v, state) {
    if (item[state] && v[styleName]) {
      if (!styles) {
        styles = {};
      }
      (0, _util.mix)(styles, v[styleName]); 
    }
  });

  return styles;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(6);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoRotate = exports.autoHide = exports.autoEllipsis = void 0;
var autoEllipsis = _interopRequireWildcard(__webpack_require__(868));
exports.autoEllipsis = autoEllipsis;
var autoHide = _interopRequireWildcard(__webpack_require__(869));
exports.autoHide = autoHide;
var autoRotate = _interopRequireWildcard(__webpack_require__(870));
exports.autoRotate = autoRotate;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CROSSHAIR_TEXT = exports.CROSSHAIR_LINE = exports.CONTAINER_CLASS = void 0;
var CONTAINER_CLASS = 'g2-crosshair';
exports.CONTAINER_CLASS = CONTAINER_CLASS;
var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
exports.CROSSHAIR_LINE = CROSSHAIR_LINE;
var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";
exports.CROSSHAIR_TEXT = CROSSHAIR_TEXT;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerAnimation = exports.getAnimation = void 0;
var ANIMATIONS_MAP = {};
function getAnimation(type) {
  return ANIMATIONS_MAP[type.toLowerCase()];
}
exports.getAnimation = getAnimation;
function registerAnimation(type, animation) {
  ANIMATIONS_MAP[type.toLowerCase()] = animation;
}
exports.registerAnimation = registerAnimation;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseRadius = exports.parseStyle = exports.parsePattern = exports.parseRadialGradient = exports.parseLineGradient = void 0;
var util_1 = __webpack_require__(51);
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  util_1.each(arr, function (item) {
    var itemArr = item.split(':');
    gradient.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box = element.getBBox();
  var start;
  var end;
  if (angle >= 0 && angle < 1 / 2 * Math.PI) {
    start = {
      x: box.minX,
      y: box.minY
    };
    end = {
      x: box.maxX,
      y: box.maxY
    };
  } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: box.maxX,
      y: box.minY
    };
    end = {
      x: box.minX,
      y: box.maxY
    };
  } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {
    start = {
      x: box.maxX,
      y: box.maxY
    };
    end = {
      x: box.minX,
      y: box.minY
    };
  } else {
    start = {
      x: box.minX,
      y: box.maxY
    };
    end = {
      x: box.maxX,
      y: box.minY
    };
  }
  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient);
  return gradient;
}
exports.parseLineGradient = parseLineGradient;
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  
  if (fr === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(':')[1];
  }
  var box = element.getBBox();
  var width = box.maxX - box.minX;
  var height = box.maxY - box.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);
  addStop(steps, gradient);
  return gradient;
}
exports.parseRadialGradient = parseRadialGradient;
function parsePattern(context, element, patternStr) {
  
  if (element.get('patternSource') && element.get('patternSource') === patternStr) {
    return element.get('pattern');
  }
  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  
  function onload() {
    
    pattern = context.createPattern(img, repeat);
    element.set('pattern', pattern); 
    element.set('patternSource', patternStr);
  }
  switch (repeat) {
    case 'a':
      repeat = 'repeat';
      break;
    case 'x':
      repeat = 'repeat-x';
      break;
    case 'y':
      repeat = 'repeat-y';
      break;
    case 'n':
      repeat = 'no-repeat';
      break;
    default:
      repeat = 'no-repeat';
  }
  img = new Image();
  
  if (!source.match(/^data:/i)) {
    
    img.crossOrigin = 'Anonymous';
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    
    img.src = img.src;
  }
  return pattern;
}
exports.parsePattern = parsePattern;
function parseStyle(context, element, color) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color;
  }
  if (util_1.isString(color)) {
    if (color[1] === '(' || color[2] === '(') {
      if (color[0] === 'l') {
        
        return parseLineGradient(context, element, color);
      }
      if (color[0] === 'r') {
        
        return parseRadialGradient(context, element, color);
      }
      if (color[0] === 'p') {
        
        return parsePattern(context, element, color);
      }
    }
    return color;
  }
  if (color instanceof CanvasPattern) {
    return color;
  }
}
exports.parseStyle = parseStyle;
function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (util_1.isArray(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}
exports.parseRadius = parseRadius;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(51);

function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}

function vRatio(u, v) {
  
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}

function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}

function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = util_1.mod(util_1.toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  
  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  
  var theta = vAngle([1, 0], u);
  
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx: cx,
    cy: cy,
    
    rx: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}
exports.default = getArcParams;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var g_base_1 = __webpack_require__(26);
function isPointInPath(shape, x, y) {
  var ctx = g_base_1.getOffScreenContext();
  shape.createPath(ctx);
  return ctx.isPointInPath(x, y);
}
exports.default = isPointInPath;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tolerance = 1e-6;

function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}

function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}

function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      
      return true;
    }
    
    
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
exports.default = isInPolygon;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(51);
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); 
  if (angle < startAngle || angle > endAngle) {
    return false;
  }
  var point = {
    x: cx + r * Math.cos(angle),
    y: cy + r * Math.sin(angle)
  };
  return util_1.distance(point.x, point.y, x, y) <= lineWidth / 2;
}
exports.default = arc;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var line_1 = __webpack_require__(183);
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if (line_1.default(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  
  if (isClose) {
    var first = points[0];
    var last = points[count - 1];
    if (line_1.default(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}
exports.default = inPolyline;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerEngine = exports.getEngine = void 0;
var ENGINES = {};
function getEngine(name) {
  var G = ENGINES[name];
  if (!G) {
    throw new Error("G engine '" + name + "' is not exist, please register it at first.");
  }
  return G;
}
exports.getEngine = getEngine;
function registerEngine(name, engine) {
  ENGINES[name] = engine;
}
exports.registerEngine = registerEngine;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerGeometry = exports.View = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(263));
var facet_1 = __webpack_require__(264);
var interaction_1 = __webpack_require__(266);
var theme_1 = __webpack_require__(92);
var bbox_1 = __webpack_require__(80);
var coordinate_1 = __webpack_require__(48);
var helper_1 = __webpack_require__(70);
var tooltip_1 = __webpack_require__(186);
var padding_1 = __webpack_require__(267);
var scale_1 = __webpack_require__(111);
var util_2 = __webpack_require__(446);
var controller_1 = __webpack_require__(447);
var coordinate_2 = (0, tslib_1.__importDefault)(__webpack_require__(940));
var event_1 = (0, tslib_1.__importDefault)(__webpack_require__(268));
var layout_1 = (0, tslib_1.__importDefault)(__webpack_require__(941));
var scale_pool_1 = __webpack_require__(942);
var padding_cal_1 = __webpack_require__(448);
var auto_1 = __webpack_require__(943);
var sync_view_padding_1 = __webpack_require__(944);
var View = function (_super) {
  (0, tslib_1.__extends)(View, _super);
  function View(props) {
    var _this = _super.call(this, {
      visible: props.visible
    }) || this;
        _this.views = [];
        _this.geometries = [];
        _this.controllers = [];
        _this.interactions = {};
        _this.limitInPlot = false;
    
    _this.options = {
      data: [],
      animate: true 
    }; 
        _this.usedControllers = (0, controller_1.getComponentControllerNames)();
        _this.scalePool = new scale_pool_1.ScalePool();
        _this.layoutFunc = layout_1.default;
        _this.isPreMouseInPlot = false;
        _this.isDataChanged = false;
        _this.isCoordinateChanged = false;
        _this.createdScaleKeys = new Map();
    _this.onCanvasEvent = function (evt) {
      var name = evt.name;
      if (!name.includes(':')) {
        
        var e = _this.createViewEvent(evt);
        
        _this.doPlotEvent(e);
        _this.emit(name, e);
      }
    };
        _this.onDelegateEvents = function (evt) {
      
      
      var name = evt.name;
      if (!name.includes(':')) {
        return;
      }
      
      var e = _this.createViewEvent(evt);
      
      _this.emit(name, e);
      
      
      
      
      
      
      
      
      
      
      
    };

    var _a = props.id,
      id = _a === void 0 ? (0, util_1.uniqueId)('view') : _a,
      parent = props.parent,
      canvas = props.canvas,
      backgroundGroup = props.backgroundGroup,
      middleGroup = props.middleGroup,
      foregroundGroup = props.foregroundGroup,
      _b = props.region,
      region = _b === void 0 ? {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 1,
          y: 1
        }
      } : _b,
      padding = props.padding,
      appendPadding = props.appendPadding,
      theme = props.theme,
      options = props.options,
      limitInPlot = props.limitInPlot,
      syncViewPadding = props.syncViewPadding;
    _this.parent = parent;
    _this.canvas = canvas;
    _this.backgroundGroup = backgroundGroup;
    _this.middleGroup = middleGroup;
    _this.foregroundGroup = foregroundGroup;
    _this.region = region;
    _this.padding = padding;
    _this.appendPadding = appendPadding;
    
    _this.options = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, _this.options), options);
    _this.limitInPlot = limitInPlot;
    _this.id = id;
    _this.syncViewPadding = syncViewPadding;
    
    _this.themeObject = (0, util_1.isObject)(theme) ? (0, util_1.deepMix)({}, (0, theme_1.getTheme)('default'), (0, util_2.createTheme)(theme)) : (0, theme_1.getTheme)(theme);
    _this.init();
    return _this;
  }
    View.prototype.setLayout = function (layout) {
    this.layoutFunc = layout;
  };
    View.prototype.init = function () {
    
    this.calculateViewBBox();
    
    this.initEvents();
    
    this.initComponentController();
    this.initOptions();
  };
    View.prototype.render = function (isUpdate, payload) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_RENDER, event_1.default.fromData(this, constant_1.VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
    
    this.paint(isUpdate);
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER, event_1.default.fromData(this, constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
    if (this.visible === false) {
      
      this.changeVisible(false);
    }
  };
    View.prototype.clear = function () {
    var _this = this;
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
    
    this.filteredData = [];
    this.coordinateInstance = undefined;
    this.isDataChanged = false; 
    this.isCoordinateChanged = false; 
    
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      geometries[i].clear();
      
      geometries[i].container.remove(true);
      geometries[i].labelsContainer.remove(true);
    }
    this.geometries = [];
    
    var controllers = this.controllers;
    for (var i = 0; i < controllers.length; i++) {
      if (controllers[i].name === 'annotation') {
        
        controllers[i].clear(true);
      } else {
        controllers[i].clear();
      }
    }
    
    this.createdScaleKeys.forEach(function (v, k) {
      _this.getRootView().scalePool.deleteScale(k);
    });
    this.createdScaleKeys.clear();
    
    var views = this.views;
    for (var i = 0; i < views.length; i++) {
      views[i].clear();
    }
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_CLEAR);
  };
    View.prototype.destroy = function () {
    
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
    var interactions = this.interactions;
    
    (0, util_1.each)(interactions, function (interaction) {
      if (interaction) {
        
        interaction.destroy();
      }
    });
    this.clear();
    
    var controllers = this.controllers;
    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      controller.destroy();
    }
    this.backgroundGroup.remove(true);
    this.middleGroup.remove(true);
    this.foregroundGroup.remove(true);
    _super.prototype.destroy.call(this);
  };
      View.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible);
    var geometries = this.geometries;
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry = geometries[i];
      geometry.changeVisible(visible);
    }
    var controllers = this.controllers;
    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      controller.changeVisible(visible);
    }
    this.foregroundGroup.set('visible', visible);
    this.middleGroup.set('visible', visible);
    this.backgroundGroup.set('visible', visible);
    
    this.getCanvas().draw();
    return this;
  };
    View.prototype.data = function (data) {
    (0, util_1.set)(this.options, 'data', data);
    this.isDataChanged = true;
    return this;
  };
    View.prototype.source = function (data) {
    console.warn('This method will be removed at G2 V4.1. Please use chart.data() instead.');
    return this.data(data);
  };
    View.prototype.filter = function (field, condition) {
    if ((0, util_1.isFunction)(condition)) {
      (0, util_1.set)(this.options, ['filters', field], condition);
      return this;
    }
    
    if (!condition && (0, util_1.get)(this.options, ['filters', field])) {
      delete this.options.filters[field];
    }
    return this;
  };
  View.prototype.axis = function (field, axisOption) {
    if ((0, util_1.isBoolean)(field)) {
      (0, util_1.set)(this.options, ['axes'], field);
    } else {
      (0, util_1.set)(this.options, ['axes', field], axisOption);
    }
    return this;
  };
  View.prototype.legend = function (field, legendOption) {
    if ((0, util_1.isBoolean)(field)) {
      (0, util_1.set)(this.options, ['legends'], field);
    } else if ((0, util_1.isString)(field)) {
      (0, util_1.set)(this.options, ['legends', field], legendOption);
      if ((0, util_1.isPlainObject)(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
        (0, util_1.set)(this.options, ['filters', field], function (name) {
          var _a;
          return (_a = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a !== void 0 ? _a : true;
        });
      }
    } else {
      
      (0, util_1.set)(this.options, ['legends'], field);
    }
    return this;
  };
  View.prototype.scale = function (field, scaleOption) {
    var _this = this;
    if ((0, util_1.isString)(field)) {
      (0, util_1.set)(this.options, ['scales', field], scaleOption);
    } else if ((0, util_1.isObject)(field)) {
      (0, util_1.each)(field, function (v, k) {
        (0, util_1.set)(_this.options, ['scales', k], v);
      });
    }
    return this;
  };
    View.prototype.tooltip = function (cfg) {
    (0, util_1.set)(this.options, 'tooltip', cfg);
    return this;
  };
    View.prototype.annotation = function () {
    return this.getController('annotation');
  };
    View.prototype.guide = function () {
    console.warn('This method will be removed at G2 V4.1. Please use chart.annotation() instead.');
    return this.annotation();
  };
  View.prototype.coordinate = function (type, coordinateCfg) {
    
    if ((0, util_1.isString)(type)) {
      (0, util_1.set)(this.options, 'coordinate', {
        type: type,
        cfg: coordinateCfg
      });
    } else {
      (0, util_1.set)(this.options, 'coordinate', type);
    }
    
    this.coordinateController.update(this.options.coordinate);
    return this.coordinateController;
  };
    View.prototype.coord = function (type, coordinateCfg) {
    console.warn('This method will be removed at G2 V4.1. Please use chart.coordinate() instead.');
    
    return this.coordinate(type, coordinateCfg);
  };
    View.prototype.facet = function (type, cfg) {
    
    if (this.facetInstance) {
      this.facetInstance.destroy();
    }
    
    var Ctor = (0, facet_1.getFacet)(type);
    if (!Ctor) {
      throw new Error("facet '" + type + "' is not exist!");
    }
    this.facetInstance = new Ctor(this, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cfg), {
      type: type
    }));
    return this;
  };
    View.prototype.animate = function (status) {
    (0, util_1.set)(this.options, 'animate', status);
    return this;
  };
    View.prototype.updateOptions = function (options) {
    this.clear(); 
    (0, util_1.mix)(this.options, options);
    
    
    this.views.forEach(function (view) {
      return view.destroy();
    });
    this.views = [];
    this.initOptions();
    
    this.coordinateBBox = this.viewBBox;
    return this;
  };
    View.prototype.option = function (name, opt) {
    
    
    if (View.prototype[name]) {
      throw new Error("Can't use built in variable name \"" + name + "\", please change another one.");
    }
    
    (0, util_1.set)(this.options, name, opt);
    return this;
  };
    View.prototype.theme = function (theme) {
    this.themeObject = (0, util_1.isObject)(theme) ? (0, util_1.deepMix)({}, this.themeObject, (0, util_2.createTheme)(theme)) : (0, theme_1.getTheme)(theme);
    return this;
  };
      View.prototype.interaction = function (name, cfg) {
    var existInteraction = this.interactions[name];
    
    if (existInteraction) {
      existInteraction.destroy();
    }
    
    var interaction = (0, interaction_1.createInteraction)(name, this, cfg);
    if (interaction) {
      interaction.init();
      this.interactions[name] = interaction;
    }
    return this;
  };
    View.prototype.removeInteraction = function (name) {
    var existInteraction = this.interactions[name];
    
    if (existInteraction) {
      existInteraction.destroy();
      this.interactions[name] = undefined;
    }
  };
    View.prototype.changeData = function (data) {
    this.isDataChanged = true;
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_1.default.fromData(this, constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    
    this.data(data);
    
    this.paint(true);
    
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      
      view.changeData(data);
    }
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_1.default.fromData(this, constant_1.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
      View.prototype.createView = function (cfg) {
    
    
    if (this.parent && this.parent.parent) {
      
      console.warn('The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.');
    }
    
    var sharedOptions = {
      data: this.options.data,
      scales: (0, util_1.clone)(this.options.scales),
      axes: (0, util_1.clone)(this.options.axes),
      coordinate: (0, util_1.clone)(this.coordinateController.getOption()),
      tooltip: (0, util_1.clone)(this.options.tooltip),
      legends: (0, util_1.clone)(this.options.legends),
      animate: this.options.animate,
      visible: this.visible
    };
    var v = new View((0, tslib_1.__assign)((0, tslib_1.__assign)({
      parent: this,
      canvas: this.canvas,
      
      backgroundGroup: this.backgroundGroup.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.BG
      }),
      middleGroup: this.middleGroup.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.MID
      }),
      foregroundGroup: this.foregroundGroup.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.FORE
      }),
      theme: this.themeObject,
      padding: this.padding
    }, cfg), {
      options: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, sharedOptions), (0, util_1.get)(cfg, 'options', {}))
    }));
    this.views.push(v);
    return v;
  };
    View.prototype.view = function (cfg) {
    console.warn('This method will be removed at G2 V4.1. Please use chart.createView() instead.');
    return this.createView(cfg);
  };
    View.prototype.removeView = function (view) {
    var removedView = (0, util_1.remove)(this.views, function (v) {
      return v === view;
    })[0];
    if (removedView) {
      removedView.destroy();
    }
    return removedView;
  };
    
    View.prototype.getCoordinate = function () {
    return this.coordinateInstance;
  };
    View.prototype.getTheme = function () {
    return this.themeObject;
  };
    View.prototype.getXScale = function () {
    
    
    var g = this.geometries[0];
    return g ? g.getXScale() : null;
  };
    View.prototype.getYScales = function () {
    
    var tmpMap = {};
    var yScales = [];
    this.geometries.forEach(function (g) {
      var yScale = g.getYScale();
      var field = yScale.field;
      if (!tmpMap[field]) {
        tmpMap[field] = true;
        yScales.push(yScale);
      }
    });
    return yScales;
  };
    View.prototype.getScalesByDim = function (dimType) {
    var geometries = this.geometries;
    var scales = {};
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry = geometries[i];
      var scale = dimType === 'x' ? geometry.getXScale() : geometry.getYScale();
      if (scale && !scales[scale.field]) {
        scales[scale.field] = scale;
      }
    }
    return scales;
  };
    View.prototype.getScale = function (field, key) {
    var defaultKey = key ? key : this.getScaleKey(field);
    
    return this.getRootView().scalePool.getScale(defaultKey);
  };
    View.prototype.getScaleByField = function (field, key) {
    return this.getScale(field, key);
  };
    View.prototype.getOptions = function () {
    return this.options;
  };
    View.prototype.getData = function () {
    return this.filteredData;
  };
    View.prototype.getOriginalData = function () {
    return this.options.data;
  };
    View.prototype.getPadding = function () {
    return this.autoPadding.getPadding();
  };
    View.prototype.getGeometries = function () {
    return this.geometries;
  };
    View.prototype.getElements = function () {
    return (0, util_1.reduce)(this.geometries, function (elements, geometry) {
      return elements.concat(geometry.getElements());
    }, []);
  };
    View.prototype.getElementsBy = function (condition) {
    return this.getElements().filter(function (el) {
      return condition(el);
    });
  };
    View.prototype.getLayer = function (layer) {
    return layer === constant_1.LAYER.BG ? this.backgroundGroup : layer === constant_1.LAYER.MID ? this.middleGroup : layer === constant_1.LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
  };
    View.prototype.isPointInPlot = function (point) {
    return (0, coordinate_1.isPointInCoordinate)(this.getCoordinate(), point);
  };
    View.prototype.getLegendAttributes = function () {
    return (0, util_1.flatten)(this.geometries.map(function (g) {
      return g.getGroupAttributes();
    }));
  };
    View.prototype.getGroupScales = function () {
    
    var scales = this.geometries.map(function (g) {
      return g.getGroupScales();
    });
    return (0, helper_1.uniq)((0, util_1.flatten)(scales));
  };
    View.prototype.getCanvas = function () {
    return this.getRootView().canvas;
  };
    View.prototype.getRootView = function () {
    var v = this;
    while (true) {
      if (v.parent) {
        v = v.parent;
        continue;
      }
      break;
    }
    return v;
  };
    View.prototype.getXY = function (data) {
    var coordinate = this.getCoordinate();
    var xScales = this.getScalesByDim('x');
    var yScales = this.getScalesByDim('y');
    var x;
    var y;
    (0, util_1.each)(data, function (value, key) {
      if (xScales[key]) {
        x = xScales[key].scale(value);
      }
      if (yScales[key]) {
        y = yScales[key].scale(value);
      }
    });
    if (!(0, util_1.isNil)(x) && !(0, util_1.isNil)(y)) {
      return coordinate.convert({
        x: x,
        y: y
      });
    }
  };
    View.prototype.getController = function (name) {
    return (0, util_1.find)(this.controllers, function (c) {
      return c.name === name;
    });
  };
    View.prototype.showTooltip = function (point) {
    var tooltip = this.getController('tooltip');
    if (tooltip) {
      tooltip.showTooltip(point);
    }
    return this;
  };
    View.prototype.hideTooltip = function () {
    var tooltip = this.getController('tooltip');
    if (tooltip) {
      tooltip.hideTooltip();
    }
    return this;
  };
    View.prototype.lockTooltip = function () {
    var tooltip = this.getController('tooltip');
    if (tooltip) {
      tooltip.lockTooltip();
    }
    return this;
  };
    View.prototype.unlockTooltip = function () {
    var tooltip = this.getController('tooltip');
    if (tooltip) {
      tooltip.unlockTooltip();
    }
    return this;
  };
    View.prototype.isTooltipLocked = function () {
    var tooltip = this.getController('tooltip');
    return tooltip && tooltip.isTooltipLocked();
  };
    View.prototype.getTooltipItems = function (point) {
    var tooltip = this.getController('tooltip');
    return tooltip ? tooltip.getTooltipItems(point) : [];
  };
    View.prototype.getSnapRecords = function (point) {
    var geometries = this.geometries;
    var rst = [];
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geom = geometries[i];
      var dataArray = geom.dataArray;
      geom.sort(dataArray); 
      var record = void 0;
      for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
        var data = dataArray[j];
        record = (0, tooltip_1.findDataByPoint)(point, data, geom);
        if (record) {
          rst.push(record);
        }
      }
    }
    
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      var snapRecords = view.getSnapRecords(point);
      rst = rst.concat(snapRecords);
    }
    return rst;
  };
    View.prototype.getComponents = function () {
    var components = [];
    var controllers = this.controllers;
    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      components = components.concat(controller.getComponents());
    }
    return components;
  };
    View.prototype.filterData = function (data) {
    var filters = this.options.filters;
    
    if ((0, util_1.size)(filters) === 0) {
      return data;
    }
    
    return (0, util_1.filter)(data, function (datum, idx) {
      
      var fields = Object.keys(filters);
      
      return fields.every(function (field) {
        var condition = filters[field];
        
        return condition(datum[field], datum, idx);
      });
    });
  };
    View.prototype.filterFieldData = function (field, data) {
    var filters = this.options.filters;
    var condition = (0, util_1.get)(filters, field);
    if ((0, util_1.isUndefined)(condition)) {
      return data;
    }
    return data.filter(function (datum, idx) {
      return condition(datum[field], datum, idx);
    });
  };
    View.prototype.adjustCoordinate = function () {
    var _a = this.getCoordinate(),
      curStart = _a.start,
      curEnd = _a.end;
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    
    if ((0, util_1.isEqual)(curStart, start) && (0, util_1.isEqual)(curEnd, end)) {
      this.isCoordinateChanged = false;
      
      return;
    }
    this.isCoordinateChanged = true;
    this.coordinateInstance = this.coordinateController.adjust(start, end);
  };
  View.prototype.paint = function (isUpdate) {
    this.renderDataRecursive(isUpdate);
    
    this.syncScale();
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_PAINT);
    
    this.renderPaddingRecursive(isUpdate);
    
    this.renderLayoutRecursive(isUpdate);
    
    this.renderBackgroundStyleShape();
    
    this.renderPaintRecursive(isUpdate);
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_PAINT);
    this.isDataChanged = false; 
  };
    View.prototype.renderBackgroundStyleShape = function () {
    
    if (this.parent) {
      return;
    }
    var background = (0, util_1.get)(this.themeObject, 'background');
    
    if (background) {
      
      if (!this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape = this.backgroundGroup.addShape('rect', {
          attrs: {},
          zIndex: -1,
          
          capture: false
        });
        this.backgroundStyleRectShape.toBack();
      }
      
      var _a = this.viewBBox,
        x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height;
      this.backgroundStyleRectShape.attr({
        fill: background,
        x: x,
        y: y,
        width: width,
        height: height
      });
    } else {
      
      if (this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape.remove(true);
        this.backgroundStyleRectShape = undefined;
      }
    }
  };
    View.prototype.renderPaddingRecursive = function (isUpdate) {
    
    this.calculateViewBBox();
    
    this.adjustCoordinate();
    
    this.initComponents(isUpdate);
    
    
    this.autoPadding = (0, auto_1.calculatePadding)(this).shrink((0, padding_1.parsePadding)(this.appendPadding));
    
    
    this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
    this.adjustCoordinate();
    
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderPaddingRecursive(isUpdate);
    }
  };
    View.prototype.renderLayoutRecursive = function (isUpdate) {
    
    
    var syncViewPaddingFn = this.syncViewPadding === true ? sync_view_padding_1.defaultSyncViewPadding : (0, util_1.isFunction)(this.syncViewPadding) ? this.syncViewPadding : undefined;
    if (syncViewPaddingFn) {
      syncViewPaddingFn(this, this.views, padding_cal_1.PaddingCal);
      
      this.views.forEach(function (v) {
        v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
        v.adjustCoordinate();
      });
    }
    
    this.doLayout();
    
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderLayoutRecursive(isUpdate);
    }
  };
    View.prototype.renderPaintRecursive = function (isUpdate) {
    var middleGroup = this.middleGroup;
    if (this.limitInPlot) {
      var _a = (0, coordinate_1.getCoordinateClipCfg)(this.coordinateInstance),
        type = _a.type,
        attrs = _a.attrs;
      middleGroup.setClip({
        type: type,
        attrs: attrs
      });
    } else {
      
      middleGroup.setClip(undefined);
    }
    
    this.paintGeometries(isUpdate);
    
    this.renderComponents(isUpdate);
    
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderPaintRecursive(isUpdate);
    }
  };
  
    View.prototype.createScale = function (field, data, scaleDef, key) {
    
    var currentScaleDef = (0, util_1.get)(this.options.scales, [field]);
    var mergedScaleDef = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, currentScaleDef), scaleDef);
    
    if (this.parent) {
      return this.parent.createScale(field, data, mergedScaleDef, key);
    }
    
    return this.scalePool.createScale(field, data, mergedScaleDef, key);
  };
    View.prototype.renderDataRecursive = function (isUpdate) {
    
    this.doFilterData();
    
    this.createCoordinate();
    
    this.initGeometries(isUpdate);
    
    this.renderFacet(isUpdate);
    
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderDataRecursive(isUpdate);
    }
  };
    View.prototype.calculateViewBBox = function () {
    var x;
    var y;
    var width;
    var height;
    if (this.parent) {
      var bbox = this.parent.coordinateBBox;
      
      x = bbox.x;
      y = bbox.y;
      width = bbox.width;
      height = bbox.height;
    } else {
      
      x = 0;
      y = 0;
      width = this.canvas.get('width');
      height = this.canvas.get('height');
    }
    var _a = this.region,
      start = _a.start,
      end = _a.end;
    
    var viewBBox = new bbox_1.BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
      
      this.viewBBox = new bbox_1.BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    }
    
    this.coordinateBBox = this.viewBBox;
  };
    View.prototype.initEvents = function () {
    
    this.foregroundGroup.on('*', this.onDelegateEvents);
    this.middleGroup.on('*', this.onDelegateEvents);
    this.backgroundGroup.on('*', this.onDelegateEvents);
    this.canvas.on('*', this.onCanvasEvent);
  };
    View.prototype.initComponentController = function () {
    var usedControllers = this.usedControllers;
    for (var i = 0, len = usedControllers.length; i < len; i++) {
      var controllerName = usedControllers[i];
      var Ctor = (0, controller_1.getComponentController)(controllerName);
      if (Ctor) {
        this.controllers.push(new Ctor(this));
      }
    }
  };
  View.prototype.createViewEvent = function (evt) {
    var shape = evt.shape,
      name = evt.name;
    var data = shape ? shape.get('origin') : null;
    
    var e = new event_1.default(this, evt, data);
    e.type = name;
    return e;
  };
    View.prototype.doPlotEvent = function (e) {
    var type = e.type,
      x = e.x,
      y = e.y;
    var point = {
      x: x,
      y: y
    };
    var ALL_EVENTS = ['mousedown', 'mouseup', 'mousemove', 'mouseleave', 'mousewheel', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'click', 'dblclick', 'contextmenu'];
    if (ALL_EVENTS.includes(type)) {
      var currentInPlot = this.isPointInPlot(point);
      var newEvent = e.clone();
      if (currentInPlot) {
        var TYPE = "plot:" + type; 
        newEvent.type = TYPE;
        this.emit(TYPE, newEvent);
        if (type === 'mouseleave' || type === 'touchend') {
          
          this.isPreMouseInPlot = false;
        }
      }
      
      if (type === 'mousemove' || type === 'touchmove') {
        if (this.isPreMouseInPlot && !currentInPlot) {
          if (type === 'mousemove') {
            newEvent.type = constant_1.PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(constant_1.PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = constant_1.PLOT_EVENTS.LEAVE;
          this.emit(constant_1.PLOT_EVENTS.LEAVE, newEvent);
        } else if (!this.isPreMouseInPlot && currentInPlot) {
          if (type === 'mousemove') {
            newEvent.type = constant_1.PLOT_EVENTS.MOUSE_ENTER;
            this.emit(constant_1.PLOT_EVENTS.MOUSE_ENTER, newEvent);
          }
          newEvent.type = constant_1.PLOT_EVENTS.ENTER;
          this.emit(constant_1.PLOT_EVENTS.ENTER, newEvent);
        }
        
        this.isPreMouseInPlot = currentInPlot;
      } else if (type === 'mouseleave' || type === 'touchend') {
        
        if (this.isPreMouseInPlot) {
          if (type === 'mouseleave') {
            newEvent.type = constant_1.PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(constant_1.PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = constant_1.PLOT_EVENTS.LEAVE;
          this.emit(constant_1.PLOT_EVENTS.LEAVE, newEvent);
          this.isPreMouseInPlot = false;
        }
      }
    }
  };
  
    View.prototype.doFilterData = function () {
    var data = this.options.data;
    this.filteredData = this.filterData(data);
  };
    View.prototype.initGeometries = function (isUpdate) {
    
    this.createOrUpdateScales();
    
    var coordinate = this.getCoordinate();
    var scaleDefs = (0, util_1.get)(this.options, 'scales', {});
    var geometries = this.geometries;
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry = geometries[i];
      
      geometry.scales = this.getGeometryScales();
      var cfg = {
        coordinate: coordinate,
        scaleDefs: scaleDefs,
        data: this.filteredData,
        theme: this.themeObject,
        isDataChanged: this.isDataChanged,
        isCoordinateChanged: this.isCoordinateChanged
      };
      if (isUpdate) {
        
        geometry.update(cfg);
      } else {
        geometry.init(cfg);
      }
    }
    
    this.adjustScales();
  };
    View.prototype.createOrUpdateScales = function () {
    var fields = this.getScaleFields();
    var groupedFields = this.getGroupedFields();
    var _a = this.getOptions(),
      data = _a.data,
      _b = _a.scales,
      scales = _b === void 0 ? {} : _b;
    var filteredData = this.filteredData;
    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var scaleDef = scales[field];
      
      var key = this.getScaleKey(field);
      this.createScale(field,
      
      groupedFields.includes(field) ? data : filteredData, scaleDef, key);
      
      this.createdScaleKeys.set(key, true);
    }
  };
    View.prototype.syncScale = function () {
    
    this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
  };
    View.prototype.getGeometryScales = function () {
    var fields = this.getScaleFields();
    var scales = {};
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      scales[field] = this.getScaleByField(field);
    }
    return scales;
  };
  View.prototype.getScaleFields = function () {
    var fields = [];
    var tmpMap = new Map();
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      var geometryScales = geometry.getScaleFields();
      (0, helper_1.uniq)(geometryScales, fields, tmpMap);
    }
    return fields;
  };
  View.prototype.getGroupedFields = function () {
    var fields = [];
    var tmpMap = new Map();
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      var groupFields = geometry.getGroupFields();
      (0, helper_1.uniq)(groupFields, fields, tmpMap);
    }
    return fields;
  };
    View.prototype.adjustScales = function () {
    
    
    this.adjustCategoryScaleRange();
  };
    View.prototype.adjustCategoryScaleRange = function () {
    var _this = this;
    var xyScales = (0, tslib_1.__spreadArray)([this.getXScale()], this.getYScales(), true).filter(function (e) {
      return !!e;
    });
    var coordinate = this.getCoordinate();
    var scaleOptions = this.options.scales;
    (0, util_1.each)(xyScales, function (scale) {
      var field = scale.field,
        values = scale.values,
        isCategory = scale.isCategory,
        isIdentity = scale.isIdentity;
      
      if (isCategory || isIdentity) {
        
        if (values && !(0, util_1.get)(scaleOptions, [field, 'range'])) {
          
          scale.range = (0, scale_1.getDefaultCategoryScaleRange)(scale, coordinate, _this.theme);
        }
      }
    });
  };
    View.prototype.initComponents = function (isUpdate) {
    
    var controllers = this.controllers;
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      
      if (isUpdate) {
        controller.update();
      } else {
        controller.clear();
        controller.render();
      }
    }
  };
  View.prototype.doLayout = function () {
    this.layoutFunc(this);
  };
    View.prototype.createCoordinate = function () {
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    this.coordinateInstance = this.coordinateController.create(start, end);
  };
    View.prototype.paintGeometries = function (isUpdate) {
    var doAnimation = this.options.animate;
    
    var coordinate = this.getCoordinate();
    var canvasRegion = {
      x: this.viewBBox.x,
      y: this.viewBBox.y,
      minX: this.viewBBox.minX,
      minY: this.viewBBox.minY,
      maxX: this.viewBBox.maxX,
      maxY: this.viewBBox.maxY,
      width: this.viewBBox.width,
      height: this.viewBBox.height
    };
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      geometry.coordinate = coordinate;
      geometry.canvasRegion = canvasRegion;
      if (!doAnimation) {
        
        geometry.animate(false);
      }
      geometry.paint(isUpdate);
    }
  };
    View.prototype.renderComponents = function (isUpdate) {
    
    for (var i = 0; i < this.getComponents().length; i++) {
      var co = this.getComponents()[i];
      co.component.render();
    }
  };
    View.prototype.renderFacet = function (isUpdate) {
    if (this.facetInstance) {
      if (isUpdate) {
        this.facetInstance.update();
      } else {
        this.facetInstance.clear();
        
        this.facetInstance.init();
        
        this.facetInstance.render();
      }
    }
  };
  View.prototype.initOptions = function () {
    var _this = this;
    var _a = this.options,
      _b = _a.geometries,
      geometries = _b === void 0 ? [] : _b,
      _c = _a.interactions,
      interactions = _c === void 0 ? [] : _c,
      _d = _a.views,
      views = _d === void 0 ? [] : _d,
      _e = _a.annotations,
      annotations = _e === void 0 ? [] : _e,
      coordinate = _a.coordinate,
      events = _a.events,
      facets = _a.facets;
    
    if (this.coordinateController) {
      
      coordinate && this.coordinateController.update(coordinate);
    } else {
      
      this.coordinateController = new coordinate_2.default(coordinate);
    }
    
    for (var i = 0; i < geometries.length; i++) {
      var geometryOption = geometries[i];
      this.createGeometry(geometryOption);
    }
    
    for (var j = 0; j < interactions.length; j++) {
      var interactionOption = interactions[j];
      var type = interactionOption.type,
        cfg = interactionOption.cfg;
      this.interaction(type, cfg);
    }
    
    for (var k = 0; k < views.length; k++) {
      var viewOption = views[k];
      this.createView(viewOption);
    }
    
    var annotationComponent = this.getController('annotation');
    for (var l = 0; l < annotations.length; l++) {
      var annotationOption = annotations[l];
      annotationComponent.annotation(annotationOption);
    }
    
    if (events) {
      (0, util_1.each)(events, function (eventCallback, eventName) {
        _this.on(eventName, eventCallback);
      });
    }
    if (facets) {
      (0, util_1.each)(facets, function (facet) {
        var type = facet.type,
          rest = (0, tslib_1.__rest)(facet, ["type"]);
        _this.facet(type, rest);
      });
    }
  };
  View.prototype.createGeometry = function (geometryOption) {
    var type = geometryOption.type,
      _a = geometryOption.cfg,
      cfg = _a === void 0 ? {} : _a;
    if (this[type]) {
      var geometry_1 = this[type](cfg);
      (0, util_1.each)(geometryOption, function (v, k) {
        if ((0, util_1.isFunction)(geometry_1[k])) {
          geometry_1[k](v);
        }
      });
    }
  };
    View.prototype.getScaleKey = function (field) {
    return this.id + "-" + field;
  };
  return View;
}(base_1.default);
exports.View = View;
function registerGeometry(name, Ctor) {
  
  View.prototype[name.toLowerCase()] = function (cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var props = (0, tslib_1.__assign)({
            container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);
    var geometry = new Ctor(props);
    this.geometries.push(geometry);
    return geometry;
  };
}
exports.registerGeometry = registerGeometry;
exports.default = View;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Interaction = function () {
  function Interaction(view, cfg) {
    this.view = view;
    this.cfg = cfg;
  }
    Interaction.prototype.init = function () {
    this.initEvents();
  };
    Interaction.prototype.initEvents = function () {};
    Interaction.prototype.clearEvents = function () {};
    Interaction.prototype.destroy = function () {
    this.clearEvents();
  };
  return Interaction;
}();
exports.default = Interaction;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTheme = void 0;
var create_theme_1 = __webpack_require__(939);
Object.defineProperty(exports, "createTheme", {
  enumerable: true,
  get: function get() {
    return create_theme_1.createTheme;
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComponentController = exports.getComponentControllerNames = exports.unregisterComponentController = exports.registerComponentController = void 0;
var LOAD_COMPONENT_CONTROLLERS = {};
function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
exports.registerComponentController = registerComponentController;
function unregisterComponentController(name) {
  delete LOAD_COMPONENT_CONTROLLERS[name];
}
exports.unregisterComponentController = unregisterComponentController;
function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
exports.getComponentControllerNames = getComponentControllerNames;
function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}
exports.getComponentController = getComponentController;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaddingCal = void 0;
var tslib_1 = __webpack_require__(1);
var constant_1 = __webpack_require__(21);
var PaddingCal = function () {
    function PaddingCal(top, right, bottom, left) {
    if (top === void 0) {
      top = 0;
    }
    if (right === void 0) {
      right = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left === void 0) {
      left = 0;
    }
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
    PaddingCal.instance = function (top, right, bottom, left) {
    if (top === void 0) {
      top = 0;
    }
    if (right === void 0) {
      right = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left === void 0) {
      left = 0;
    }
    return new PaddingCal(top, right, bottom, left);
  };
    PaddingCal.prototype.max = function (padding) {
    var top = padding[0],
      right = padding[1],
      bottom = padding[2],
      left = padding[3];
    this.top = Math.max(this.top, top);
    this.right = Math.max(this.right, right);
    this.bottom = Math.max(this.bottom, bottom);
    this.left = Math.max(this.left, left);
    return this;
  };
    PaddingCal.prototype.shrink = function (padding) {
    var top = padding[0],
      right = padding[1],
      bottom = padding[2],
      left = padding[3];
    this.top += top;
    this.right += right;
    this.bottom += bottom;
    this.left += left;
    return this;
  };
    PaddingCal.prototype.inc = function (bbox, direction) {
    var width = bbox.width,
      height = bbox.height;
    switch (direction) {
      case constant_1.DIRECTION.TOP:
      case constant_1.DIRECTION.TOP_LEFT:
      case constant_1.DIRECTION.TOP_RIGHT:
        this.top += height;
        break;
      case constant_1.DIRECTION.RIGHT:
      case constant_1.DIRECTION.RIGHT_TOP:
      case constant_1.DIRECTION.RIGHT_BOTTOM:
        this.right += width;
        break;
      case constant_1.DIRECTION.BOTTOM:
      case constant_1.DIRECTION.BOTTOM_LEFT:
      case constant_1.DIRECTION.BOTTOM_RIGHT:
        this.bottom += height;
        break;
      case constant_1.DIRECTION.LEFT:
      case constant_1.DIRECTION.LEFT_TOP:
      case constant_1.DIRECTION.LEFT_BOTTOM:
        this.left += width;
        break;
      default:
        break;
    }
    return this;
  };
    PaddingCal.prototype.getPadding = function () {
    return [this.top, this.right, this.bottom, this.left];
  };
    PaddingCal.prototype.clone = function () {
    return new (PaddingCal.bind.apply(PaddingCal, (0, tslib_1.__spreadArray)([void 0], this.getPadding(), false)))();
  };
  return PaddingCal;
}();
exports.PaddingCal = PaddingCal;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isModelChange = void 0;
var util_1 = __webpack_require__(0);
function isModelChange(currentModel, preModel) {
  return (0, util_1.some)(['color', 'shape', 'size', 'x', 'y', 'isInCircle', 'data', 'style', 'defaultStyle', 'points', 'mappingData'], function (key) {
    return !(0, util_1.isEqual)(currentModel[key], preModel[key]);
  });
}
exports.isModelChange = isModelChange;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diff = void 0;
function diff(keyItem, keys) {
  var added = [];
  var updated = [];
  var removed = [];
  var keyIncluded = new Map();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (keyItem[key]) updated.push(key);else added.push(key);
    keyIncluded.set(key, true);
  }
  Object.keys(keyItem).forEach(function (key) {
    if (!keyIncluded.has(key)) removed.push(key);
  });
  return {
    added: added,
    updated: updated,
    removed: removed
  };
}
exports.diff = diff;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMappingValue = void 0;
var tslib_1 = __webpack_require__(1);
function getMappingValue(attr, value, def) {
  if (!attr) {
    return def;
  }
  var r;
  
  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill('');
    r = attr.mapping.apply(attr, (0, tslib_1.__spreadArray)([value], restArgs, false)).join('');
  } else {
    r = attr.mapping(value).join('');
  }
  return r || def;
}
exports.getMappingValue = getMappingValue;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLegendThemeCfg = exports.getCustomLegendItems = exports.getLegendItems = exports.getLegendLayout = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var constant_1 = __webpack_require__(21);
var attr_1 = __webpack_require__(451);
var helper_1 = __webpack_require__(70);
var marker_1 = __webpack_require__(146);
/** 线条形 marker symbol */
var STROKES_SYMBOLS = ['line', 'cross', 'tick', 'plus', 'hyphen'];
function handleUserMarkerStyle(markerStyle, style) {
  if ((0, util_1.isFunction)(style)) {
    return style(markerStyle);
  }
  return (0, util_1.deepMix)({}, markerStyle, style);
}
function adpatorMarkerStyle(marker, color) {
  var symbol = marker.symbol;
  if ((0, util_1.isString)(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    var markerStyle = (0, util_1.get)(marker, 'style', {});
    var lineWidth = (0, util_1.get)(markerStyle, 'lineWidth', 1);
    var stroke = markerStyle.stroke || markerStyle.fill || color;
    marker.style = (0, util_1.deepMix)({}, marker.style, {
      lineWidth: lineWidth,
      stroke: stroke,
      fill: null
    });
  }
}
function setMarkerSymbol(marker) {
  var symbol = marker.symbol;
  if ((0, util_1.isString)(symbol) && marker_1.MarkerSymbols[symbol]) {
    marker.symbol = marker_1.MarkerSymbols[symbol];
  }
}
function getLegendLayout(direction) {
  return direction.startsWith(constant_1.DIRECTION.LEFT) || direction.startsWith(constant_1.DIRECTION.RIGHT) ? 'vertical' : 'horizontal';
}
exports.getLegendLayout = getLegendLayout;
function getLegendItems(view, geometry, attr, themeMarker, userMarker) {
  var scale = attr.getScale(attr.type);
  if (scale.isCategory) {
    var field_1 = scale.field;
    var colorAttr_1 = geometry.getAttribute('color');
    var shapeAttr_1 = geometry.getAttribute('shape');
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry.coordinate.isPolar;
    return scale.getTicks().map(function (tick, index) {
      var _a;
      var text = tick.text,
        scaleValue = tick.value;
      var name = text;
      var value = scale.invert(scaleValue);
      
      var unchecked = view.filterFieldData(field_1, [(_a = {}, _a[field_1] = value, _a)]).length === 0;
      (0, util_1.each)(view.views, function (subView) {
        var _a;
        if (!subView.filterFieldData(field_1, [(_a = {}, _a[field_1] = value, _a)]).length) {
          unchecked = true;
        }
      });
      
      var color = (0, attr_1.getMappingValue)(colorAttr_1, value, defaultColor_1);
      var shape = (0, attr_1.getMappingValue)(shapeAttr_1, value, 'point');
      var marker = geometry.getShapeMarker(shape, {
        color: color,
        isInPolar: isInPolar_1
      });
      var markerCfg = userMarker;
      if ((0, util_1.isFunction)(markerCfg)) {
        markerCfg = markerCfg(name, index, (0, tslib_1.__assign)({
          name: name,
          value: value
        }, (0, util_1.deepMix)({}, themeMarker, marker)));
      }
      
      marker = (0, util_1.deepMix)({}, themeMarker, marker, (0, helper_1.omit)((0, tslib_1.__assign)({}, markerCfg), ['style']));
      adpatorMarkerStyle(marker, color);
      if (markerCfg && markerCfg.style) {
        
        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
      }
      setMarkerSymbol(marker);
      return {
        id: value,
        name: name,
        value: value,
        marker: marker,
        unchecked: unchecked
      };
    });
  }
  return [];
}
exports.getLegendItems = getLegendItems;
function getCustomLegendItems(themeMarker, userMarker, customItems) {
  
  return customItems.map(function (item, index) {
    var markerCfg = userMarker;
    if ((0, util_1.isFunction)(markerCfg)) {
      markerCfg = markerCfg(item.name, index, (0, util_1.deepMix)({}, themeMarker, item));
    }
    var itemMarker = (0, util_1.isFunction)(item.marker) ? item.marker(item.name, index, (0, util_1.deepMix)({}, themeMarker, item)) : item.marker;
    var marker = (0, util_1.deepMix)({}, themeMarker, markerCfg, itemMarker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}
exports.getCustomLegendItems = getCustomLegendItems;
function getLegendThemeCfg(theme, direction) {
  var legendTheme = (0, util_1.get)(theme, ['components', 'legend'], {});
  return (0, util_1.deepMix)({}, (0, util_1.get)(legendTheme, ['common'], {}), (0, util_1.deepMix)({}, (0, util_1.get)(legendTheme, [direction], {})));
}
exports.getLegendThemeCfg = getLegendThemeCfg;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseLineGradient = parseLineGradient;
exports.parsePattern = parsePattern;
exports.parseRadialGradient = parseRadialGradient;
exports.parseRadius = parseRadius;
exports.parseStyle = parseStyle;
var _util = __webpack_require__(53);
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  (0, _util.each)(arr, function (item) {
    var itemArr = item.split(':');
    gradient.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box = element.getBBox();
  var start;
  var end;
  if (angle >= 0 && angle < 1 / 2 * Math.PI) {
    start = {
      x: box.minX,
      y: box.minY
    };
    end = {
      x: box.maxX,
      y: box.maxY
    };
  } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: box.maxX,
      y: box.minY
    };
    end = {
      x: box.minX,
      y: box.maxY
    };
  } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {
    start = {
      x: box.maxX,
      y: box.maxY
    };
    end = {
      x: box.minX,
      y: box.minY
    };
  } else {
    start = {
      x: box.minX,
      y: box.maxY
    };
    end = {
      x: box.maxX,
      y: box.minY
    };
  }
  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient);
  return gradient;
}
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  
  if (fr === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(':')[1];
  }
  var box = element.getBBox();
  var width = box.maxX - box.minX;
  var height = box.maxY - box.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);
  addStop(steps, gradient);
  return gradient;
}
function parsePattern(context, element, patternStr) {
  
  if (element.get('patternSource') && element.get('patternSource') === patternStr) {
    return element.get('pattern');
  }
  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  
  function onload() {
    
    pattern = context.createPattern(img, repeat);
    element.set('pattern', pattern); 
    element.set('patternSource', patternStr);
  }
  switch (repeat) {
    case 'a':
      repeat = 'repeat';
      break;
    case 'x':
      repeat = 'repeat-x';
      break;
    case 'y':
      repeat = 'repeat-y';
      break;
    case 'n':
      repeat = 'no-repeat';
      break;
    default:
      repeat = 'no-repeat';
  }
  img = new Image();
  
  if (!source.match(/^data:/i)) {
    
    img.crossOrigin = 'Anonymous';
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    
    img.src = img.src;
  }
  return pattern;
}
function parseStyle(context, element, color) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color;
  }
  if ((0, _util.isString)(color)) {
    if (color[1] === '(' || color[2] === '(') {
      if (color[0] === 'l') {
        
        return parseLineGradient(context, element, color);
      }
      if (color[0] === 'r') {
        
        return parseRadialGradient(context, element, color);
      }
      if (color[0] === 'p') {
        
        return parsePattern(context, element, color);
      }
    }
    return color;
  }
  if (color instanceof CanvasPattern) {
    return color;
  }
}
function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if ((0, _util.isArray)(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getArcParams;
var _util = __webpack_require__(53);

function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}

function vRatio(u, v) {
  
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}

function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}

function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = (0, _util.mod)((0, _util.toRadian)(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  
  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  
  var theta = vAngle([1, 0], u);
  
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx: cx,
    cy: cy,
    
    rx: (0, _util.isSamePoint)(startPoint, [x2, y2]) ? 0 : rx,
    ry: (0, _util.isSamePoint)(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPointInPath;
var _gBase = __webpack_require__(26);
function isPointInPath(shape, x, y) {
  var ctx = (0, _gBase.getOffScreenContext)();
  shape.createPath(ctx);
  return ctx.isPointInPath(x, y);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isInPolygon;

var tolerance = 1e-6;

function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}

function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}

function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      
      return true;
    }
    
    
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = arc;
var _util = __webpack_require__(53);
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); 
  if (angle < startAngle || angle > endAngle) {
    return false;
  }
  var point = {
    x: cx + r * Math.cos(angle),
    y: cy + r * Math.sin(angle)
  };
  return (0, _util.distance)(point.x, point.y, x, y) <= lineWidth / 2;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inPolyline;
var _line = _interopRequireDefault(__webpack_require__(189));
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if ((0, _line.default)(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  
  if (isClose) {
    var first = points[0];
    var last = points[count - 1];
    if ((0, _line.default)(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var _antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(206);
 var _antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__);
 __webpack_require__.d(__webpack_exports__, "a", function() { return _antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__["antvDark"]; });

 var _antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
 var _antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__);
 __webpack_require__.d(__webpack_exports__, "b", function() { return _antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"]; });

 var _antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);
 var _antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__);
 __webpack_require__.d(__webpack_exports__, "c", function() { return _antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"]; });

 var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(92);
 var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__);






Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__["registerTheme"])('dark', Object(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"])(_antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__["antvDark"]));
Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__["registerTheme"])('default', Object(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"])(_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"]));
Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__["registerTheme"])('light', Object(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"])(_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"]));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLineMarker = void 0;
var LineSymbols = {
  line: function line(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  dot: function dot(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  dash: function dash(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  smooth: function smooth(x, y, r) {
    return [['M', x - r, y], ['A', r / 2, r / 2, 0, 1, 1, x, y], ['A', r / 2, r / 2, 0, 1, 0, x + r, y]];
  },
  hv: function hv(x, y, r) {
    return [['M', x - r - 1, y - 2.5], ['L', x, y - 2.5], ['L', x, y + 2.5], ['L', x + r + 1, y + 2.5]];
  },
  vh: function vh(x, y, r) {
    return [['M', x - r - 1, y + 2.5], ['L', x, y + 2.5], ['L', x, y - 2.5], ['L', x + r + 1, y - 2.5]];
  },
  hvh: function hvh(x, y, r) {
    return [['M', x - (r + 1), y + 2.5], ['L', x - r / 2, y + 2.5], ['L', x - r / 2, y - 2.5], ['L', x + r / 2, y - 2.5], ['L', x + r / 2, y + 2.5], ['L', x + r + 1, y + 2.5]];
  },
  vhv: function vhv(x, y) {
    
    return [['M', x - 5, y + 2.5], ['L', x - 5, y], ['L', x, y], ['L', x, y - 3], ['L', x, y + 3], ['L', x + 6.5, y + 3]];
  }
};
function getLineMarker(markerCfg, shapeType) {
  var color = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color
    }
  };
}
exports.getLineMarker = getLineMarker;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
var path_1 = __webpack_require__(112);
var split_points_1 = __webpack_require__(277);
var EdgeShapeFactory = (0, base_1.registerShapeFactory)('edge', {
  defaultShapeType: 'line',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return (0, split_points_1.splitPoints)(pointInfo);
  }
});
(0, base_1.registerShape)('edge', 'line', {
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, true, false, 'lineWidth');
    var path = (0, path_1.getLinePath)(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path
      })
    });
  },
  getMarker: function getMarker(markerCfg) {
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
exports.default = EdgeShapeFactory;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
function getPath(points) {
  var flag = points[0];
  var i = 1;
  var path = [['M', flag.x, flag.y]];
  while (i < points.length) {
    var c = points[i];
    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
      path.push(['L', c.x, c.y]);
      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
        flag = points[i + 1];
        path.push(['Z']);
        path.push(['M', flag.x, flag.y]);
        i++;
      }
    }
    i++;
  }
  if (!(0, util_1.isEqual)((0, util_1.last)(path), flag)) {
    path.push(['L', flag.x, flag.y]);
  }
  path.push(['Z']);
  return path;
}
var PolygonShapeFactory = (0, base_1.registerShapeFactory)('polygon', {
  defaultShapeType: 'polygon',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    var points = [];
    (0, util_1.each)(pointInfo.x, function (subX, index) {
      var subY = pointInfo.y[index];
      points.push({
        x: subX,
        y: subY
      });
    });
    return points;
  }
});
(0, base_1.registerShape)('polygon', 'polygon', {
  draw: function draw(cfg, container) {
    if (!(0, util_1.isEmpty)(cfg.points)) {
      var shapeAttrs = (0, get_style_1.getStyle)(cfg, true, true);
      var path = this.parsePath(getPath(cfg.points));
      return container.addShape('path', {
        attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeAttrs), {
          path: path
        }),
        name: 'polygon'
      });
    }
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});
exports.default = PolygonShapeFactory;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var base_1 = __webpack_require__(27);
var SchemaShapeFactory = (0, base_1.registerShapeFactory)('schema', {
  defaultShapeType: '' // 'schema' is for some custom shapes, so will not specify defaultShapeType
});

exports.default = SchemaShapeFactory;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQPath = exports.getCPath = void 0;
var util_1 = __webpack_require__(0);
function getCPath(from, to) {
  return ['C', from.x * 1 / 2 + to.x * 1 / 2, from.y, from.x * 1 / 2 + to.x * 1 / 2, to.y, to.x, to.y];
}
exports.getCPath = getCPath;
function getQPath(to, center) {
  var points = [];
  points.push({
    x: center.x,
    y: center.y
  });
  points.push(to);
  var sub = ['Q'];
  (0, util_1.each)(points, function (point) {
    sub.push(point.x, point.y);
  });
  return sub;
}
exports.getQPath = getQPath;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
var util_1 = __webpack_require__(150);
(0, base_1.registerShape)('interval', 'funnel', {
  getPoints: function getPoints(shapePoint) {
    shapePoint.size = shapePoint.size * 2; 
    return (0, util_1.getRectPoints)(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, false, true);
    var path = this.parsePath((0, util_1.getFunnelPath)(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = __webpack_require__(27);
var constant_1 = __webpack_require__(270);
var get_style_1 = __webpack_require__(33);
var util_1 = __webpack_require__(150);
(0, base_1.registerShape)('interval', 'hollow-rect', {
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, true, false);
    var group = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group = container.addGroup();
      var backgroundStyle = (0, get_style_1.getBackgroundRectStyle)(cfg);
      var backgroundPath = (0, util_1.getBackgroundRectPath)(cfg, this.parsePoints(cfg.points), this.coordinate);
      group.addShape('path', {
        attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, backgroundStyle), {
          path: backgroundPath
        }),
        zIndex: -1,
        name: constant_1.BACKGROUND_SHAPE
      });
    }
    var path = this.parsePath((0, util_1.getRectPath)(cfg.points));
    var shape = group.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return backgroundCfg ? group : shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color,
      isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: 'circle',
        style: {
          r: 4.5,
          stroke: color,
          fill: null
        }
      };
    }
    return {
      symbol: 'square',
      style: {
        r: 4,
        stroke: color,
        fill: null
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
var util_2 = __webpack_require__(150);
var helper_1 = __webpack_require__(70);

function getLinePoints(pointInfo) {
  var x = pointInfo.x,
    y = pointInfo.y,
    y0 = pointInfo.y0;
  if ((0, util_1.isArray)(y)) {
    return y.map(function (yItem, idx) {
      return {
        x: (0, util_1.isArray)(x) ? x[idx] : x,
        y: yItem
      };
    });
  }
  
  return [{
    x: x,
    y: y0
  }, {
    x: x,
    y: y
  }];
}
(0, base_1.registerShape)('interval', 'line', {
  getPoints: function getPoints(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, true, false, 'lineWidth');
    var newStyle = (0, helper_1.omit)((0, tslib_1.__assign)({}, style), ['fill']);
    var path = this.parsePath((0, util_2.getRectPath)(cfg.points, false));
    var shape = container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, newStyle), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        return [['M', x, y - r], ['L', x, y + r]];
      },
      style: {
        r: 5,
        stroke: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
var util_1 = __webpack_require__(150);
(0, base_1.registerShape)('interval', 'pyramid', {
  getPoints: function getPoints(shapePoint) {
    shapePoint.size = shapePoint.size * 2; 
    return (0, util_1.getRectPoints)(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, false, true);
    var path = this.parsePath((0, util_1.getFunnelPath)(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);

function getTickPoints(pointInfo) {
  var x = pointInfo.x,
    y = pointInfo.y,
    y0 = pointInfo.y0,
    size = pointInfo.size;
  var yMin;
  var yMax;
  if ((0, util_1.isArray)(y)) {
    yMin = y[0], yMax = y[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMax = x + size / 2;
  var xMin = x - size / 2;
  
  
  
  
  return [{
    x: x,
    y: yMin
  }, {
    x: x,
    y: yMax
  }, {
    x: xMin,
    y: yMin
  }, {
    x: xMax,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }, {
    x: xMax,
    y: yMax
  }];
}

function getTickPath(points) {
  return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]];
}
(0, base_1.registerShape)('interval', 'tick', {
  getPoints: function getPoints(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, true, false);
    var path = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];
      },
      style: {
        r: 5,
        stroke: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(0);
var marker_1 = __webpack_require__(146);
var base_1 = __webpack_require__(27);
var util_2 = __webpack_require__(280);

(0, util_1.each)(util_2.HOLLOW_SHAPES, function (shapeName) {
  (0, base_1.registerShape)('point', shapeName, {
    draw: function draw(cfg, container) {
      return (0, util_2.drawPoints)(this, cfg, container, shapeName, true);
    },
    getMarker: function getMarker(markerCfg) {
      var color = markerCfg.color;
      return {
        symbol: marker_1.MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color,
          fill: null
        }
      };
    }
  });
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
(0, base_1.registerShape)('point', 'image', {
  draw: function draw(cfg, container) {
    var size = (0, get_style_1.getStyle)(cfg, false, false, 'r').r;
    var points = this.parsePoints(cfg.points);
    var pointPosition = points[0];
    if (cfg.isStack) {
      pointPosition = points[1];
    } else if (points.length > 1) {
      var group = container.addGroup();
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        group.addShape('image', {
          attrs: {
            x: point.x - size / 2,
            y: point.y - size,
            width: size,
            height: size,
            img: cfg.shape[1]
          }
        });
      }
      return group;
    }
    return container.addShape('image', {
      attrs: {
        x: pointPosition.x - size / 2,
        y: pointPosition.y - size,
        width: size,
        height: size,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util_1 = __webpack_require__(0);
var marker_1 = __webpack_require__(146);
var base_1 = __webpack_require__(27);
var util_2 = __webpack_require__(280);

(0, util_1.each)(util_2.SHAPES, function (shapeName) {
  (0, base_1.registerShape)('point', shapeName, {
    draw: function draw(cfg, container) {
      return (0, util_2.drawPoints)(this, cfg, container, shapeName, false);
    },
    getMarker: function getMarker(markerCfg) {
      var color = markerCfg.color;
      return {
        symbol: marker_1.MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color
        }
      };
    }
  });
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
function parseValue(value) {
  var array = !(0, util_1.isArray)(value) ? [value] : value;
  var min = array[0]; 
  var max = array[array.length - 1]; 
  var min1 = array.length > 1 ? array[1] : min;
  var max1 = array.length > 3 ? array[3] : max;
  var median = array.length > 2 ? array[2] : min1;
  return {
    min: min,
    max: max,
    min1: min1,
    max1: max1,
    median: median
  };
}
function getBoxPoints(x, y, size) {
  var halfSize = size / 2;
  var pointsArray;
  if ((0, util_1.isArray)(y)) {
    
    var _a = parseValue(y),
      min = _a.min,
      max = _a.max,
      median = _a.median,
      min1 = _a.min1,
      max1 = _a.max1;
    var minX = x - halfSize;
    var maxX = x + halfSize;
    pointsArray = [[minX, max], [maxX, max], [x, max], [x, max1], [minX, min1], [minX, max1], [maxX, max1], [maxX, min1], [x, min1], [x, min], [minX, min], [maxX, min], [minX, median], [maxX, median]];
  } else {
    
    y = (0, util_1.isNil)(y) ? 0.5 : y;
    var _b = parseValue(x),
      min = _b.min,
      max = _b.max,
      median = _b.median,
      min1 = _b.min1,
      max1 = _b.max1;
    var minY = y - halfSize;
    var maxY = y + halfSize;
    pointsArray = [[min, minY], [min, maxY], [min, y], [min1, y], [min1, minY], [min1, maxY], [max1, maxY], [max1, minY], [max1, y], [max, y], [max, minY], [max, maxY], [median, minY], [median, maxY]];
  }
  return pointsArray.map(function (arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}
function getBoxPath(points) {
  return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x, points[10].y], ['L', points[11].x, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
}

(0, base_1.registerShape)('schema', 'box', {
  getPoints: function getPoints(shapePoint) {
    var x = shapePoint.x,
      y = shapePoint.y,
      size = shapePoint.size;
    return getBoxPoints(x, y, size);
  },
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, true, false);
    var path = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path,
        name: 'schema'
      })
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points = getBoxPoints(x, yValues, r);
        return [['M', points[0].x + 1, points[0].y], ['L', points[1].x - 1, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x + 1, points[10].y], ['L', points[11].x - 1, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var helper_1 = __webpack_require__(70);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
function getCandleYValues(value) {
  var array = !(0, util_1.isArray)(value) ? [value] : value;
  
  var sorted = array.sort(function (a, b) {
    return b - a;
  });
  return (0, helper_1.padEnd)(sorted, 4, sorted[sorted.length - 1]);
}

function getCandlePoints(x, y, size) {
  var yValues = getCandleYValues(y);
  return [{
    x: x,
    y: yValues[0]
  }, {
    x: x,
    y: yValues[1]
  }, {
    x: x - size / 2,
    y: yValues[2]
  }, {
    x: x - size / 2,
    y: yValues[1]
  }, {
    x: x + size / 2,
    y: yValues[1]
  }, {
    x: x + size / 2,
    y: yValues[2]
  }, {
    x: x,
    y: yValues[2]
  }, {
    x: x,
    y: yValues[3]
  }];
}
function getCandlePath(points) {
  return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
}

(0, base_1.registerShape)('schema', 'candle', {
  getPoints: function getPoints(shapePoint) {
    var x = shapePoint.x,
      y = shapePoint.y,
      size = shapePoint.size;
    return getCandlePoints(x, y, size);
  },
  draw: function draw(cfg, container) {
    var style = (0, get_style_1.getStyle)(cfg, true, true);
    var path = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape('path', {
      attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), {
        path: path,
        name: 'schema'
      })
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points = getCandlePoints(x, yValues, r);
        return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
      },
      style: {
        lineWidth: 1,
        stroke: color,
        fill: color,
        r: 6
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = __webpack_require__(27);
var get_style_1 = __webpack_require__(33);
function getRectAttrs(points, size) {
  var width = Math.abs(points[0].x - points[2].x);
  var height = Math.abs(points[0].y - points[2].y);
  var len = Math.min(width, height);
  if (size) {
    len = (0, util_1.clamp)(size, 0, Math.min(width, height));
  }
  len = len / 2;
  var centerX = (points[0].x + points[2].x) / 2;
  var centerY = (points[0].y + points[2].y) / 2;
  return {
    x: centerX - len,
    y: centerY - len,
    width: len * 2,
    height: len * 2
  };
}
(0, base_1.registerShape)('polygon', 'square', {
  draw: function draw(cfg, container) {
    if (!(0, util_1.isEmpty)(cfg.points)) {
      var shapeAttrs = (0, get_style_1.getStyle)(cfg, true, true);
      var points = this.parsePoints(cfg.points); 
      return container.addShape('rect', {
        attrs: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shapeAttrs), getRectAttrs(points, cfg.size)),
        name: 'polygon'
      });
    }
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.antiCollision = void 0;
function antiCollision(items, labelHeight, plotRange) {
  var labels = items.filter(function (item) {
    return !item.invisible;
  });
  
  labels.sort(function (a, b) {
    return a.y - b.y;
  });
  
  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function (label) {
    if (label.y > maxY) {
      maxY = label.y;
    }
    if (label.y < minY) {
      minY = label.y;
    }
    return {
      content: label.content,
      size: labelHeight,
      targets: [label.y - startY],
      pos: null
    };
  });
  minY -= startY;
  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }
  while (overlapping) {
        boxes.forEach(function (box) {
      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
      box.pos = Math.max(0, box.pos);
    });
    
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box = boxes[i];
        if (previousBox.pos + previousBox.size > box.pos) {
          
          previousBox.size += box.size;
          previousBox.targets = previousBox.targets.concat(box.targets);
          
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1); 
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  
  boxes.forEach(function (b) {
    var posInCompositeBox = startY + labelHeight / 2; 
    b.targets.forEach(function () {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i++;
    });
  });
}
exports.antiCollision = antiCollision;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(288));
var RectMask = function (_super) {
  (0, tslib_1.__extends)(RectMask, _super);
  function RectMask() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = 'rect';
    return _this;
  }
  RectMask.prototype.getRegion = function () {
    var points = this.points;
    return {
      start: (0, util_1.head)(points),
      end: (0, util_1.last)(points)
    };
  };
  
  RectMask.prototype.getMaskAttrs = function () {
    var _a = this.getRegion(),
      start = _a.start,
      end = _a.end;
    var x = Math.min(start.x, end.x);
    var y = Math.min(start.y, end.y);
    var width = Math.abs(end.x - start.x);
    var height = Math.abs(end.y - start.y);
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };
  return RectMask;
}(base_1.default);
exports.default = RectMask;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(288));
var PathMask = function (_super) {
  (0, tslib_1.__extends)(PathMask, _super);
  function PathMask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  
  PathMask.prototype.getMaskPath = function () {
    var points = this.points;
    var path = [];
    if (points.length) {
      (0, util_1.each)(points, function (point, index) {
        if (index === 0) {
          path.push(['M', point.x, point.y]);
        } else {
          path.push(['L', point.x, point.y]);
        }
      });
      path.push(['L', points[0].x, points[0].y]);
    }
    return path;
  };
  PathMask.prototype.getMaskAttrs = function () {
    return {
      path: this.getMaskPath()
    };
  };
    PathMask.prototype.addPoint = function () {
    this.resize();
  };
  return PathMask;
}(base_1.default);
exports.default = PathMask;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BRUSH_FILTER_EVENTS = void 0;
var tslib_1 = __webpack_require__(1);
var chart_1 = __webpack_require__(98);
var base_1 = (0, tslib_1.__importDefault)(__webpack_require__(44));
var util_1 = __webpack_require__(31);

function getFilter(scale, dim, point1, point2) {
  var min = Math.min(point1[dim], point2[dim]);
  var max = Math.max(point1[dim], point2[dim]);
  var _a = scale.range,
    rangeMin = _a[0],
    rangeMax = _a[1];
  
  if (min < rangeMin) {
    min = rangeMin;
  }
  if (max > rangeMax) {
    max = rangeMax;
  }
  
  if (min === rangeMax && max === rangeMax) {
    return null;
  }
  var minValue = scale.invert(min);
  var maxValue = scale.invert(max);
  if (scale.isCategory) {
    var minIndex = scale.values.indexOf(minValue);
    var maxIndex = scale.values.indexOf(maxValue);
    var arr_1 = scale.values.slice(minIndex, maxIndex + 1);
    return function (value) {
      return arr_1.includes(value);
    };
  } else {
    return function (value) {
      return value >= minValue && value <= maxValue;
    };
  }
}
var EVENTS;
(function (EVENTS) {
  EVENTS["FILTER"] = "brush-filter-processing";
  EVENTS["RESET"] = "brush-filter-reset";
  EVENTS["BEFORE_FILTER"] = "brush-filter:beforefilter";
  EVENTS["AFTER_FILTER"] = "brush-filter:afterfilter";
  EVENTS["BEFORE_RESET"] = "brush-filter:beforereset";
  EVENTS["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS || (EVENTS = {}));
exports.BRUSH_FILTER_EVENTS = EVENTS;
var RangeFilter = function (_super) {
  (0, tslib_1.__extends)(RangeFilter, _super);
  function RangeFilter() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dims = ['x', 'y'];
        _this.startPoint = null;
    _this.isStarted = false;
    return _this;
  }
  
  RangeFilter.prototype.hasDim = function (dim) {
    return this.dims.includes(dim);
  };
    RangeFilter.prototype.start = function () {
    var context = this.context;
    this.isStarted = true;
    this.startPoint = context.getCurrentPoint();
  };
    RangeFilter.prototype.filter = function () {
    var startPoint;
    var currentPoint;
    if ((0, util_1.isMask)(this.context)) {
      var maskShape = this.context.event.target;
      var bbox = maskShape.getCanvasBBox();
      startPoint = {
        x: bbox.x,
        y: bbox.y
      };
      currentPoint = {
        x: bbox.maxX,
        y: bbox.maxY
      };
    } else {
      if (!this.isStarted) {
        
        return;
      }
      startPoint = this.startPoint;
      currentPoint = this.context.getCurrentPoint();
    }
    if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
      
      return;
    }
    var _a = this.context,
      view = _a.view,
      event = _a.event;
    var payload = {
      view: view,
      event: event,
      dims: this.dims
    };
    view.emit(EVENTS.BEFORE_FILTER, chart_1.Event.fromData(view, EVENTS.BEFORE_FILTER, payload));
    var coord = view.getCoordinate();
    var normalCurrent = coord.invert(currentPoint);
    var normalStart = coord.invert(startPoint);
    
    if (this.hasDim('x')) {
      var xScale = view.getXScale();
      var filter = getFilter(xScale, 'x', normalCurrent, normalStart);
      this.filterView(view, xScale.field, filter);
    }
    
    if (this.hasDim('y')) {
      var yScale = view.getYScales()[0];
      var filter = getFilter(yScale, 'y', normalCurrent, normalStart);
      this.filterView(view, yScale.field, filter);
    }
    this.reRender(view, {
      source: EVENTS.FILTER
    });
    view.emit(EVENTS.AFTER_FILTER, chart_1.Event.fromData(view, EVENTS.AFTER_FILTER, payload));
  };
    RangeFilter.prototype.end = function () {
    this.isStarted = false;
  };
    RangeFilter.prototype.reset = function () {
    var view = this.context.view;
    view.emit(EVENTS.BEFORE_RESET, chart_1.Event.fromData(view, EVENTS.BEFORE_RESET, {}));
    this.isStarted = false;
    if (this.hasDim('x')) {
      var xScale = view.getXScale();
      this.filterView(view, xScale.field, null); 
    }

    if (this.hasDim('y')) {
      
      var yScale = view.getYScales()[0];
      this.filterView(view, yScale.field, null); 
    }

    this.reRender(view, {
      source: EVENTS.RESET
    });
    view.emit(EVENTS.AFTER_RESET, chart_1.Event.fromData(view, EVENTS.AFTER_RESET, {}));
  };
    RangeFilter.prototype.filterView = function (view, field, filter) {
    view.filter(field, filter);
  };
    RangeFilter.prototype.reRender = function (view, payload) {
    view.render(true, payload);
  };
  return RangeFilter;
}(base_1.default);
exports.default = RangeFilter;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var tslib_1 = __webpack_require__(1);
var __1 = __webpack_require__(185);
var DIM_X = 'x';
var DIM_Y = 'y';
var ScaleTranslate = function (_super) {
  (0, tslib_1.__extends)(ScaleTranslate, _super);
  function ScaleTranslate() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = [DIM_X, DIM_Y];
    _this.cfgFields = ['dims'];
    _this.cacheScaleDefs = {};
    return _this;
  }
  
  ScaleTranslate.prototype.hasDim = function (dim) {
    return this.dims.includes(dim);
  };
  ScaleTranslate.prototype.getScale = function (dim) {
    var view = this.context.view;
    if (dim === 'x') {
      return view.getXScale();
    } else {
      return view.getYScales()[0];
    }
  };
  ScaleTranslate.prototype.resetDim = function (dim) {
    var view = this.context.view;
    if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
      var scale = this.getScale(dim);
      view.scale(scale.field, this.cacheScaleDefs[dim]);
      this.cacheScaleDefs[dim] = null;
    }
  };
    ScaleTranslate.prototype.reset = function () {
    this.resetDim(DIM_X);
    this.resetDim(DIM_Y);
    var view = this.context.view;
    view.render(true);
  };
  return ScaleTranslate;
}(__1.Action);
exports.default = ScaleTranslate;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeToArray = __webpack_require__(482);
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverEntry = void 0;
var _calculateBoxSize = __webpack_require__(289);
var _freeze = __webpack_require__(191);
var ResizeObserverEntry = function () {
  function ResizeObserverEntry(target) {
    var boxes = (0, _calculateBoxSize.calculateBoxSizes)(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = (0, _freeze.freeze)([boxes.borderBoxSize]);
    this.contentBoxSize = (0, _freeze.freeze)([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = (0, _freeze.freeze)([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry;
}();
exports.ResizeObserverEntry = ResizeObserverEntry;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverBoxOptions = void 0;
var ResizeObserverBoxOptions;
exports.ResizeObserverBoxOptions = ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
  ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (exports.ResizeObserverBoxOptions = ResizeObserverBoxOptions = {}));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverSize = void 0;
var _freeze = __webpack_require__(191);
var ResizeObserverSize = function () {
  function ResizeObserverSize(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    (0, _freeze.freeze)(this);
  }
  return ResizeObserverSize;
}();
exports.ResizeObserverSize = ResizeObserverSize;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.global = void 0;
var global = typeof window !== 'undefined' ? window : {};
exports.global = global;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateDepthForNode = void 0;
var _element = __webpack_require__(192);
var calculateDepthForNode = function calculateDepthForNode(node) {
  if ((0, _element.isHidden)(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
exports.calculateDepthForNode = calculateDepthForNode;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
var isObjectLike = function isObjectLike(value) {
    return (0, _typeof2.default)(value) === 'object' && value !== null;
};
exports.default = isObjectLike;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
 var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(336);
 var _antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2__);
 var _antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(337);
 var _antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3__);
 var _antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(338);
 var _antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(339);
 var _antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5__);
 var _antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(340);
 var _antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6__);
 var _antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(341);
 var _antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7___default = __webpack_require__.n(_antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7__);
 var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(40);
 var _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(81);
 var _core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8);

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerFacet"])('rect', _antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerFacet"])('mirror', _antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerFacet"])('list', _antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerFacet"])('matrix', _antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerFacet"])('circle', _antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerFacet"])('tree', _antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7___default.a);
function Facet(props) {
  var chart = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_8__[ "a"])();
  var chartInstance = Object(_hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_9__[ "a"])();
  var type = props.type,
    children = props.children,
    cfg = __rest(props, ["type", "children"]);
  
  if (chart.facetInstance) {
    
    
    chart.facetInstance.destroy();
    
    chart.facetInstance = null;
    
    chartInstance.forceReRender = true; 
  }

  if (_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default()(children)) {
    chart.facet(type, object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg), {
      
      eachView: children
    }));
  } else {
    chart.facet(type, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg));
  }
  return null;
}
 __webpack_exports__["a"] = (Facet);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(344);
 var _antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
 var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__);
 var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);





Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__["registerComponentController"])('slider', _antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1___default.a);
function Slider(props) {
  var view = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_3__[ "a"])();
  view.option('slider', props);
  return null;
}
 __webpack_exports__["a"] = (Slider);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var _antv_g2_lib_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
 var _antv_g2_lib_chart__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_antv_g2_lib_chart__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_g2_lib_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(272);
 var _antv_g2_lib_interface__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_g2_lib_interface__WEBPACK_IMPORTED_MODULE_1__);



;

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return SchemaGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(332);
 var _antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_5__);
 var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
 var _antv_g2_lib_geometry_shape_schema__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(463);
 var _antv_g2_lib_geometry_shape_schema__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_schema__WEBPACK_IMPORTED_MODULE_8__);
 var _antv_g2_lib_geometry_shape_schema_candle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(474);
 var _antv_g2_lib_geometry_shape_schema_candle__WEBPACK_IMPORTED_MODULE_9___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_schema_candle__WEBPACK_IMPORTED_MODULE_9__);
 var _antv_g2_lib_geometry_shape_schema_box__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(473);
 var _antv_g2_lib_geometry_shape_schema_box__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(_antv_g2_lib_geometry_shape_schema_box__WEBPACK_IMPORTED_MODULE_10__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Schema', _antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_5___default.a);
var SchemaGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(SchemaGeom, _BaseGemo);
  var _super = _createSuper(SchemaGeom);
  function SchemaGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, SchemaGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'schema';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(SchemaGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_6__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return PathGeom; });
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
 var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
 var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
 var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
 var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
 var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
 var _antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(158);
 var _antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_5__);
 var _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
 var _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_6__);
 var _Base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(39);
 var _core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('path-in', _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_6__["pathIn"]);
Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerGeometry"])('Path', _antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_5___default.a);
var PathGeom = function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(PathGeom, _BaseGemo);
  var _super = _createSuper(PathGeom);
  function PathGeom() {
    var _this;
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PathGeom);
    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'path';
    return _this;
  }
  return _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(PathGeom);
}(_Base__WEBPACK_IMPORTED_MODULE_7__[ "a"]);


 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
 var _Area__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(128);
 var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(216);
 var _Heatmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(217);
 var _Interval__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(218);
 var _Line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(129);
 var _Point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(130);
 var _Polygon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(219);
 var _LineAdvance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(220);
 var warning__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17);
 var warning__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_10__);

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










var GEOM_MAP = {
  area: _Area__WEBPACK_IMPORTED_MODULE_2__[ "a"],
  edge: _Edge__WEBPACK_IMPORTED_MODULE_3__[ "a"],
  heatmap: _Heatmap__WEBPACK_IMPORTED_MODULE_4__[ "a"],
  interval: _Interval__WEBPACK_IMPORTED_MODULE_5__[ "a"],
  line: _Line__WEBPACK_IMPORTED_MODULE_6__[ "a"],
  point: _Point__WEBPACK_IMPORTED_MODULE_7__[ "a"],
  polygon: _Polygon__WEBPACK_IMPORTED_MODULE_8__[ "a"],
  
  'line-advance': _LineAdvance__WEBPACK_IMPORTED_MODULE_9__[ "a"]
};
 __webpack_exports__["a"] = (function (props) {
  var type = props.type,
    cfg = __rest(props, ["type"]);
  var Geom = GEOM_MAP[type];
  if (Geom) return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Geom, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg));
  warning__WEBPACK_IMPORTED_MODULE_10___default()(false, 'Only support the below type: area|edge|heatmap|interval|line|point|polygon|line-advance');
  return null;
});

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Coord; });
 var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
 var object_assign__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
 var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
 var warning__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_2__);
 var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(215);




function Coord(props) {
  warning__WEBPACK_IMPORTED_MODULE_2___default()(false, 'Coord (协调) 组件将重命名为更加语义化的组件名 Coordinate（坐标）,请使用Coordinate替代，我们将在5.0后删除Coord组件');
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_index__WEBPACK_IMPORTED_MODULE_3__[ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, props));
}

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
 var warning__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
 var _components_Annotation_arc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(207);
 var _components_Annotation_dataMarker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(208);
 var _components_Annotation_dataRegion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(209);
 var _components_Annotation_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(210);
 var _components_Annotation_line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(211);
 var _components_Annotation_region__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(212);
 var _components_Annotation_text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(213);











var Guide = function Guide(props) {
  warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Guide组件将在5.0后不再支持，请使用Annotation替代，请查看Annotation的使用文档');
  return props.children;
};
Guide.Arc = _components_Annotation_arc__WEBPACK_IMPORTED_MODULE_1__[ "a"];
Guide.DataMarker = _components_Annotation_dataMarker__WEBPACK_IMPORTED_MODULE_2__[ "a"];
Guide.DataRegion = _components_Annotation_dataRegion__WEBPACK_IMPORTED_MODULE_3__[ "a"];

Guide.Image = _components_Annotation_image__WEBPACK_IMPORTED_MODULE_4__[ "a"];
Guide.Line = _components_Annotation_line__WEBPACK_IMPORTED_MODULE_5__[ "a"];
Guide.Region = _components_Annotation_region__WEBPACK_IMPORTED_MODULE_6__[ "a"];
Guide.Text = _components_Annotation_text__WEBPACK_IMPORTED_MODULE_7__[ "a"];
 __webpack_exports__["a"] = (Guide);

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Effects; });
 var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
 var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__);
 var _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
 var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
 var warning__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_3__);




function Effects(props) {
  var chart = Object(_hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_2__[ "a"])();
  if (_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default()(props.children)) {
    var res = props.children(chart);
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.isValidElement(res) ? res : null;
  }
  warning__WEBPACK_IMPORTED_MODULE_3___default()(false, 'Effects 的子组件应当是一个函数 (chart) => {}');
  return null;
}

 }),
 (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return Interaction; });
 var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);


function Interaction(props) {
  var chart = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_1__[ "a"])();
  var type = props.type,
    config = props.config;
  
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"])(function () {
    chart.interaction(type, config);
    return function () {
      chart.removeInteraction(type);
    };
  });
  return null;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick = void 0;
function pick(obj, keys) {
  var r = {};
  if (obj !== null && (0, _typeof2.default)(obj) === 'object') {
    keys.forEach(function (key) {
      var v = obj[key];
      if (v !== undefined) {
        r[key] = v;
      }
    });
  }
  return r;
}
exports.pick = pick;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = exports.invariant = exports.LEVEL = void 0;
var tslib_1 = __webpack_require__(1);
var LEVEL;
(function (LEVEL) {
  LEVEL["ERROR"] = "error";
  LEVEL["WARN"] = "warn";
  LEVEL["INFO"] = "log";
})(LEVEL = exports.LEVEL || (exports.LEVEL = {}));
var BRAND = 'AntV/G2Plot';
function getMessage(format) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var argIndex = 0;
  return BRAND + ": " + format.replace(/%s/g, function () {
    return "" + args[argIndex++];
  });
}
/**
 * invariant error
 * @param condition
 * @param format
 * @param args
 */
function invariant(condition, format) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (!condition) {
    var error = new Error(getMessage.apply(void 0, tslib_1.__spreadArrays([format], args)));
    error.name = BRAND;
    // error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}
exports.invariant = invariant;
/**
 * 打印语句
 * @param level
 * @param condition
 * @param format
 * @param args
 */
function log(level, condition, format) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  if (!condition) {
    console[level](getMessage.apply(void 0, tslib_1.__spreadArrays([format], args)));
  }
}
exports.log = log;

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSiblingViews = exports.getViews = exports.findViewById = void 0;
function findViewById(chart, id) {
  return chart.views.find(function (view) {
    return view.id === id;
  });
}
exports.findViewById = findViewById;
function getViews(view) {
  var parent = view.parent;
  return parent ? parent.views : [];
}
exports.getViews = getViews;
function getSiblingViews(view) {
  return getViews(view).filter(function (sub) {
    return sub !== view;
  });
}
exports.getSiblingViews = getSiblingViews;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepAssign = void 0;
var MAX_MIX_LEVEL = 5; 
var toString = {}.toString;

var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};
var isArray = function isArray(value) {
  return isType(value, 'Array');
};
var isObjectLike = function isObjectLike(value) {
    return (0, _typeof2.default)(value) === 'object' && value !== null;
};
var isPlainObject = function isPlainObject(value) {
    if (!isObjectLike(value) || !isType(value, 'Object')) {
    return false;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var deep = function deep(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      var value = src[key];
      if (!value) {
        
        dist[key] = value;
      } else {
        if (isPlainObject(value)) {
          if (!isPlainObject(dist[key])) {
            dist[key] = {};
          }
          if (level < maxLevel) {
            deep(dist[key], value, level + 1, maxLevel);
          } else {
            
            dist[key] = src[key];
          }
        } else if (isArray(value)) {
          dist[key] = [];
          dist[key] = dist[key].concat(value);
        } else {
          dist[key] = value;
        }
      }
    }
  }
};
exports.deepAssign = function (rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderGaugeStatistic = exports.renderStatistic = exports.setStatisticContainerStyle = exports.adapteStyle = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var _1 = __webpack_require__(15);
function adapteStyle(style) {
  var styleObject = {
    overflow: 'hidden',
    'white-space': 'nowrap',
    'text-overflow': 'ellipsis',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center'
  };
  var shapeStyleKeys = ['stroke', 'lineWidth', 'shadowColor', 'strokeOpacity', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'fill'];
  
  if (util_1.get(style, 'fill')) {
    styleObject['color'] = style['fill'];
  }
  var _a = _1.pick(style, shapeStyleKeys),
    shadowColor = _a.shadowColor,
    _b = _a.shadowBlur,
    shadowBlur = _b === void 0 ? 0 : _b,
    _c = _a.shadowOffsetX,
    shadowOffsetX = _c === void 0 ? 0 : _c,
    _d = _a.shadowOffsetY,
    shadowOffsetY = _d === void 0 ? 0 : _d;
  styleObject['text-shadow'] = "" + [shadowColor, shadowOffsetX + "px", shadowOffsetY + "px", shadowBlur + "px"].join(' ');
  var _e = _1.pick(style, shapeStyleKeys),
    stroke = _e.stroke,
    _f = _e.lineWidth,
    lineWidth = _f === void 0 ? 0 : _f;
  styleObject['-webkit-text-stroke'] = "" + [lineWidth + "px", stroke].join(' ');
  
  util_1.each(style, function (v, k) {
    
    if (['fontSize'].includes(k) && util_1.isNumber(v)) {
      styleObject[_1.kebabCase(k)] = v + "px";
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[_1.kebabCase(k)] = "" + v;
    }
  });
  return styleObject;
}
exports.adapteStyle = adapteStyle;
/**
 * @desc 设置 html-statistic 容器的默认样式
 *
 * - 默认事件穿透
 */
function setStatisticContainerStyle(container, style) {
  container.style['pointer-events'] = 'none';
  util_1.each(style, function (v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}
exports.setStatisticContainerStyle = setStatisticContainerStyle;
/**
 * 渲染环图 html-annotation（默认 position 居中 [50%, 50%]）
 * @param chart
 * @param options
 * @param meta 字段元信息
 * @param {optional} datum 当前的元数据
 */
exports.renderStatistic = function (chart, options, datum) {
  var statistic = options.statistic,
    plotType = options.plotType;
  var titleOpt = statistic.title,
    contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option, idx) {
    if (!option) {
      return;
    }
    var transform = '';
    if (idx === 0) {
      transform = contentOpt ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
    } else {
      transform = titleOpt ? 'translate(-50%, 0)' : 'translate(-50%, -50%)';
    }
    var style = util_1.isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(tslib_1.__assign({
      position: ['50%', '50%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate();
        var containerW = 0;
        if (plotType === 'pie' || plotType === 'ring-progress') {
          containerW = coordinate.getRadius() * coordinate.innerRadius * 2;
        } else if (plotType === 'liquid') {
          var liquidShape = util_1.get(view.geometries, [0, 'elements', 0, 'shape']);
          if (liquidShape) {
            // 获取到水波图边框大小
            var path = liquidShape.find(function (t) {
              return t.get('name') === 'wrap';
            });
            var width = path.getCanvasBBox().width;
            containerW = width;
          }
        } else if (!containerW) {
          // 保底方案
          containerW = coordinate.getWidth();
        }
        setStatisticContainerStyle(container, tslib_1.__assign({
          width: containerW + "px",
          transform: transform
        }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text = option.content;
        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        }
        
        return text ? util_1.isString(text) ? text : "" + text : '<div></div>';
      },
      // @ts-ignore
      key: (idx === 0 ? 'top' : 'bottom') + "-statistic"
    }, _1.pick(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter']) ));
  });
};
exports.renderGaugeStatistic = function (chart, options, datum) {
  var statistic = options.statistic;
  var titleOpt = statistic.title,
    contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option) {
    if (!option) {
      return;
    }
    var style = util_1.isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(tslib_1.__assign({
      position: ['50%', '100%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate();
        
        var polarCoord = view.views[0].getCoordinate();
        var polarCenter = polarCoord.getCenter();
        var polarRadius = polarCoord.getRadius();
        var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
        var offsetY = polarCenter.y + polarMaxY - coordinate.y.start - parseFloat(util_1.get(style, 'fontSize', 0));
        var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
        setStatisticContainerStyle(container, tslib_1.__assign({
          width: containerWidth + "px",
          transform: "translate(-50%, " + offsetY + "px)"
        }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text = option.content;
        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        }
        
        return text ? util_1.isString(text) ? text : "" + text : '<div></div>';
      }
    }, _1.pick(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter']) /** 透传配置 */));
  });
};

/***/ }),
/* 504 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
 __webpack_require__.d(__webpack_exports__, "a", function() { return useTheme; });
 var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(133);
 var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
 var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
 var react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
 var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
 var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__);



function useTheme() {
  var defaultThemeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
  var defaultTheme = Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__["getTheme"])(defaultThemeName);
  defaultTheme.name = defaultThemeName;
  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(defaultTheme),
    _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_useState, 2),
    theme = _useState2[0],
    setG2Theme = _useState2[1];
  var setTheme = function setTheme(themeName) {
    var nextTheme = Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__["getTheme"])(themeName);
    nextTheme.name = themeName;
    setG2Theme(nextTheme);
  };
  return [theme, setTheme];
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ver = exports.clear = exports.bind = void 0;
var _sensorPool = __webpack_require__(1065);


var bind = function bind(element, cb) {
  var sensor = (0, _sensorPool.getSensor)(element); 

  sensor.bind(cb); 

  return function () {
    sensor.unbind(cb);
  };
};

exports.bind = bind;
var clear = function clear(element) {
  var sensor = (0, _sensorPool.getSensor)(element);
  (0, _sensorPool.removeSensor)(sensor);
};
exports.clear = clear;
var ver = "1.0.1";
exports.ver = ver;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _default = function _default(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;
  var timer = null;
  return function () {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(_this, args);
    }, delay);
  };
};
exports["default"] = _default;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SensorTabIndex = exports.SensorClassName = exports.SizeSensorId = void 0;

var SizeSensorId = 'size-sensor-id';
exports.SizeSensorId = SizeSensorId;
var SensorClassName = 'size-sensor-object';
exports.SensorClassName = SensorClassName;
var SensorTabIndex = '-1';
exports.SensorTabIndex = SensorTabIndex;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.geometry = void 0;
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
var common_1 = __webpack_require__(34);
var geometries_1 = __webpack_require__(43);
var constants_1 = __webpack_require__(511);
var utils_2 = __webpack_require__(295);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var percent = options.percent,
    progressStyle = options.progressStyle,
    color = options.color,
    barWidthRatio = options.barWidthRatio;
  chart.data(utils_2.getProgressData(percent));
  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: '1',
      yField: 'percent',
      seriesField: 'type',
      isStack: true,
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: util_1.isString(color) ? [color, constants_1.DEFAULT_COLOR[1]] : color
      },
      args: {
        zIndexReversed: true
      }
    }
  });
  geometries_1.interval(p);
  
  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
exports.geometry = geometry;
function coordinate(params) {
  var chart = params.chart;
  chart.coordinate('rect').transpose();
  return params;
}
function adaptor(params) {
  
  return utils_1.flow(geometry, common_1.scale({}), coordinate, common_1.animation, common_1.theme, common_1.annotation())(params);
}
exports.adaptor = adaptor;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AXIS_META_CONFIG_KEYS = void 0;
exports.AXIS_META_CONFIG_KEYS = ['type', 'alias', 'tickCount', 'tickInterval', 'min', 'max', 'nice', 'minLimit', 'maxLimit',

'range', 'tickMethod',

'base',

'exponent',

'mask',

'sync'];

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polygon = void 0;
var tslib_1 = __webpack_require__(1);
var tooltip_1 = __webpack_require__(64);
var utils_1 = __webpack_require__(15);
var base_1 = __webpack_require__(59);
function polygon(params) {
  var options = params.options;
  var polygon = options.polygon,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField,
    tooltip = options.tooltip;
  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField]),
    fields = _a.fields,
    formatter = _a.formatter;
  return polygon ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'polygon',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: tslib_1.__assign({
        tooltip: formatter
      }, polygon)
    }
  })) : params;
}
exports.polygon = polygon;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.DEFAULT_COLOR = void 0;
exports.DEFAULT_COLOR = ['#FAAD14', '#E8EDF3'];
exports.DEFAULT_OPTIONS = {
  percent: 0.2,
  color: exports.DEFAULT_COLOR,
  animation: {}
};

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.adjust = exports.legend = exports.axis = exports.meta = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var common_1 = __webpack_require__(34);
var utils_1 = __webpack_require__(15);
var geometries_1 = __webpack_require__(43);
var utils_2 = __webpack_require__(15);
var data_1 = __webpack_require__(292);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    color = options.color,
    lineStyle = options.lineStyle,
    lineShape = options.lineShape,
    pointMapping = options.point,
    areaMapping = options.area,
    seriesField = options.seriesField;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  chart.data(data);
  
  var primary = utils_1.deepAssign({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color,
        style: lineStyle,
        shape: lineShape
      },
      
      
      point: pointMapping && tslib_1.__assign({
        color: color,
        shape: 'circle'
      }, pointMapping),
      
      area: areaMapping && tslib_1.__assign({
        color: color
      }, areaMapping),
      
      label: undefined
    }
  });
  var second = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  var areaParams = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  geometries_1.line(primary);
  geometries_1.point(second);
  geometries_1.area(areaParams);
  return params;
}
function meta(params) {
  var _a, _b;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField,
    data = options.data;
  return utils_2.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = data_1.adjustYMetaByZero(data, yField), _b)))(params);
}
exports.meta = meta;
function coordinate(params) {
  var chart = params.chart,
    options = params.options;
  var reflect = options.reflect;
  if (reflect) {
    var p = reflect;
    if (!util_1.isArray(p)) {
      p = [p];
    }
    var actions = p.map(function (d) {
      return ['reflect', d];
    });
    chart.coordinate({
      type: 'rect',
      actions: actions
    });
  }
  return params;
}
function axis(params) {
  var chart = params.chart,
    options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField;
  
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
exports.axis = axis;
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    seriesField = options.seriesField;
  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }
  return params;
}
exports.legend = legend;
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    yField = options.yField;
  var lineGeometry = utils_1.findGeometry(chart, 'line');
  
  if (!label) {
    lineGeometry.label(false);
  } else {
    var callback = label.callback,
      cfg = tslib_1.__rest(label, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: tslib_1.__assign({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, utils_1.transformLabel(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart,
    options = params.options;
  var isStack = options.isStack;
  if (isStack) {
    util_1.each(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }
  return params;
}
exports.adjust = adjust;
function adaptor(params) {
  
  return utils_2.flow(geometry, meta, adjust, common_1.theme, coordinate, axis, legend, common_1.tooltip, label, common_1.slider, common_1.interaction, common_1.animation, common_1.annotation(), common_1.limitInPlot)(params);
}
exports.adaptor = adaptor;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = exports.resetDrillDown = exports.enableDrillInteraction = exports.enableInteraction = exports.findInteraction = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var drill_down_1 = __webpack_require__(514);
var treemap_1 = __webpack_require__(1091);
function findInteraction(interactions, interactionType) {
  if (!util_1.isArray(interactions)) return undefined;
  return interactions.find(function (i) {
    return i.type === interactionType;
  });
}
exports.findInteraction = findInteraction;
function enableInteraction(interactions, interactionType) {
  var interaction = findInteraction(interactions, interactionType);
  return interaction && interaction.enable !== false;
}
exports.enableInteraction = enableInteraction;
function enableDrillInteraction(options) {
  var interactions = options.interactions,
    drilldown = options.drilldown;
  
  return util_1.get(drilldown, 'enabled') || enableInteraction(interactions, 'treemap-drill-down');
}
exports.enableDrillInteraction = enableDrillInteraction;
function resetDrillDown(chart) {
  var drillDownInteraction = chart.interactions['drill-down'];
  if (!drillDownInteraction) return;
  
  var drillDownAction = drillDownInteraction.context.actions.find(function (i) {
    return i.name === 'drill-down-action';
  });
  drillDownAction.reset();
}
exports.resetDrillDown = resetDrillDown;
function transformData(options) {
  var data = options.data,
    colorField = options.colorField,
    enableDrillDown = options.enableDrillDown,
    hierarchyConfig = options.hierarchyConfig;
  var nodes = treemap_1.treemap(data, tslib_1.__assign(tslib_1.__assign({}, hierarchyConfig), {
    
    type: 'hierarchy.treemap',
    field: 'value',
    as: ['x', 'y']
  }));
  var result = [];
  nodes.forEach(function (node) {
    if (node.depth === 0) {
      return null;
    }
    
    if (enableDrillDown && node.depth !== 1) {
      return null;
    }
    
    if (!enableDrillDown && node.children) {
      return null;
    }
    
    var curPath = node.ancestors().map(function (n) {
      return {
        data: n.data,
        height: n.height,
        value: n.value
      };
    });
    
    var path = enableDrillDown && util_1.isArray(data.path) ? curPath.concat(data.path.slice(1)) : curPath;
    var nodeInfo = Object.assign({}, node.data, tslib_1.__assign({
      x: node.x,
      y: node.y,
      depth: node.depth,
      value: node.value,
      path: path
    }, node));
    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function (n) {
        return n.data[colorField];
      });
      nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      nodeInfo[colorField] = node.data[colorField];
    }
    nodeInfo[drill_down_1.HIERARCHY_DATA_TRANSFORM_PARAMS] = {
      hierarchyConfig: hierarchyConfig,
      colorField: colorField,
      enableDrillDown: enableDrillDown
    };
    result.push(nodeInfo);
  });
  return result;
}
exports.transformData = transformData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrillDownAction = exports.HIERARCHY_DATA_TRANSFORM_PARAMS = exports.DEFAULT_BREAD_CRUMB_CONFIG = exports.BREAD_CRUMB_NAME = exports.PADDING_TOP = void 0;
var tslib_1 = __webpack_require__(1);
var g2_1 = __webpack_require__(14);
var util_1 = __webpack_require__(0);
var deep_assign_1 = __webpack_require__(502);

var PADDING = 4;

var PADDING_LEFT = 0;

exports.PADDING_TOP = 5;
exports.BREAD_CRUMB_NAME = 'drilldown-bread-crumb';

exports.DEFAULT_BREAD_CRUMB_CONFIG = {
    position: 'top-left',
  dividerText: '/',
  textStyle: {
    fontSize: 12,
    fill: 'rgba(0, 0, 0, 0.65)',
    cursor: 'pointer'
  },
  activeTextStyle: {
    fill: '#87B5FF'
  }
};
exports.HIERARCHY_DATA_TRANSFORM_PARAMS = 'hierarchy-data-transform-params';
var DrillDownAction = function (_super) {
  tslib_1.__extends(DrillDownAction, _super);
  function DrillDownAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'drill-down';
    
    _this.historyCache = [];
    
    _this.breadCrumbGroup = null;
    
    _this.breadCrumbCfg = exports.DEFAULT_BREAD_CRUMB_CONFIG;
    return _this;
  }
    DrillDownAction.prototype.click = function () {
    var data = util_1.get(this.context, ['event', 'data', 'data']);
    if (!data) return false;
    this.drill(data);
    this.drawBreadCrumb();
  };
    DrillDownAction.prototype.resetPosition = function () {
    
    if (!this.breadCrumbGroup) return;
    var coordinate = this.context.view.getCoordinate();
    var breadCrumbGroup = this.breadCrumbGroup;
    var bbox = breadCrumbGroup.getBBox();
    var position = this.getButtonCfg().position;
    
    
    var point = {
      x: coordinate.start.x,
      y: coordinate.end.y - (bbox.height + exports.PADDING_TOP * 2)
    };
    if (coordinate.isPolar) {
      
      point = {
        x: 0,
        y: 0
      };
    }
    if (position === 'bottom-left') {
      
      point = {
        x: coordinate.start.x,
        y: coordinate.start.y
      };
    }
        var matrix = g2_1.Util.transform(null, [['t', point.x + PADDING_LEFT, point.y + bbox.height + exports.PADDING_TOP]]);
    breadCrumbGroup.setMatrix(matrix);
  };
    DrillDownAction.prototype.back = function () {
    if (util_1.size(this.historyCache)) {
      this.backTo(this.historyCache.slice(0, -1));
    }
  };
    DrillDownAction.prototype.reset = function () {
    if (this.historyCache[0]) {
      this.backTo(this.historyCache.slice(0, 1));
    }
    
    this.historyCache = [];
    this.hideCrumbGroup();
  };
    DrillDownAction.prototype.drill = function (nodeInfo) {
    var view = this.context.view;
    var transformData = util_1.get(view, ['interactions', 'drill-down', 'cfg', 'transformData'], function (v) {
      return v;
    });
    
    var drillData = transformData(tslib_1.__assign({
      data: nodeInfo.data
    }, nodeInfo[exports.HIERARCHY_DATA_TRANSFORM_PARAMS]));
    view.changeData(drillData);
    
    var historyCache = [];
    var node = nodeInfo;
    while (node) {
      var nodeData = node.data;
      historyCache.unshift({
        id: nodeData.name + "_" + node.height + "_" + node.depth,
        name: nodeData.name,
        
        children: transformData(tslib_1.__assign({
          data: nodeData
        }, nodeInfo[exports.HIERARCHY_DATA_TRANSFORM_PARAMS]))
      });
      node = node.parent;
    }
    this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
  };
    DrillDownAction.prototype.backTo = function (historyCache) {
    if (!historyCache || historyCache.length <= 0) {
      return;
    }
    var view = this.context.view;
    var data = util_1.last(historyCache).children; 
    view.changeData(data);
    if (historyCache.length > 1) {
      this.historyCache = historyCache;
      this.drawBreadCrumb();
    } else {
      
      this.historyCache = [];
      this.hideCrumbGroup();
    }
  };
    DrillDownAction.prototype.getButtonCfg = function () {
    var view = this.context.view;
    var drillDownConfig = util_1.get(view, ['interactions', 'drill-down', 'cfg', 'drillDownConfig']);
    return deep_assign_1.deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
  };
    DrillDownAction.prototype.drawBreadCrumb = function () {
    this.drawBreadCrumbGroup();
    this.resetPosition();
    this.breadCrumbGroup.show();
  };
    DrillDownAction.prototype.drawBreadCrumbGroup = function () {
    var _this = this;
    var config = this.getButtonCfg();
    var cache = this.historyCache;
    
    if (!this.breadCrumbGroup) {
      this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
        name: exports.BREAD_CRUMB_NAME
      });
    } else {
      this.breadCrumbGroup.clear();
    }
    
    var left = 0;
    cache.forEach(function (record, index) {
      
      var textShape = _this.breadCrumbGroup.addShape({
        type: 'text',
        id: record.id,
        name: exports.BREAD_CRUMB_NAME + "_" + record.name + "_text",
        attrs: tslib_1.__assign(tslib_1.__assign({
          text: index === 0 && !util_1.isNil(config.rootText) ? config.rootText : record.name
        }, config.textStyle), {
          x: left,
          y: 0
        })
      });
      var textShapeBox = textShape.getBBox();
      left += textShapeBox.width + PADDING;
      
      textShape.on('click', function (event) {
        var _a;
        var targetId = event.target.get('id');
        if (targetId !== ((_a = util_1.last(cache)) === null || _a === void 0 ? void 0 : _a.id)) {
          var newHistoryCache = cache.slice(0, cache.findIndex(function (d) {
            return d.id === targetId;
          }) + 1);
          _this.backTo(newHistoryCache);
        }
      });
      
      textShape.on('mouseenter', function (event) {
        var _a;
        var targetId = event.target.get('id');
        if (targetId !== ((_a = util_1.last(cache)) === null || _a === void 0 ? void 0 : _a.id)) {
          textShape.attr(config.activeTextStyle);
        } else {
          textShape.attr({
            cursor: 'default'
          });
        }
      });
      textShape.on('mouseleave', function () {
        textShape.attr(config.textStyle);
      });
      if (index < cache.length - 1) {
        
        var dividerShape = _this.breadCrumbGroup.addShape({
          type: 'text',
          name: config.name + "_" + record.name + "_divider",
          attrs: tslib_1.__assign(tslib_1.__assign({
            text: config.dividerText
          }, config.textStyle), {
            x: left,
            y: 0
          })
        });
        var dividerBox = dividerShape.getBBox();
        left += dividerBox.width + PADDING;
      }
    });
  };
    DrillDownAction.prototype.hideCrumbGroup = function () {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.hide();
    }
  };
    DrillDownAction.prototype.destroy = function () {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return DrillDownAction;
}(g2_1.Action);
exports.DrillDownAction = DrillDownAction;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.packEnclose = packEnclose;
var _array = _interopRequireDefault(__webpack_require__(516));
var _enclose = _interopRequireDefault(__webpack_require__(517));
function place(b, a, c) {
  var dx = b.x - a.x,
    x,
    a2,
    dy = b.y - a.y,
    y,
    b2,
    d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}
function intersects(a, b) {
  var dr = a.r + b.r - 1e-6,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a = node._,
    b = node.next._,
    ab = a.r + b.r,
    dx = (a.x * b.r + b.x * a.r) / ab,
    dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}
function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = (0, _array.default)(circles)).length)) return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  
  place(b, a, c = circles[2]);

  
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    
    
    
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  
  a = [b._], c = b;
  while ((c = c.next) !== b) {
    a.push(c._);
  }
  c = (0, _enclose.default)(a);

  
  for (i = 0; i < n; ++i) {
    a = circles[i], a.x -= c.x, a.y -= c.y;
  }
  return c.r;
}
function _default(circles) {
  packEnclose(circles);
  return circles;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.shuffle = shuffle;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
function _default(x) {
  return (0, _typeof2.default)(x) === "object" && "length" in x ? x 
  : Array.from(x); 
}

function shuffle(array) {
  var m = array.length,
    t,
    i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _array = __webpack_require__(516);
function _default(circles) {
  var i = 0,
    n = (circles = (0, _array.shuffle)(Array.from(circles))).length,
    B = [],
    p,
    e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }
  return e;
}
function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B)) return [p];

  
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  
  throw new Error();
}
function enclosesNot(a, b) {
  var dr = a.r - b.r,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}
function encloseBasis2(a, b) {
  var x1 = a.x,
    y1 = a.y,
    r1 = a.r,
    x2 = b.x,
    y2 = b.y,
    r2 = b.r,
    x21 = x2 - x1,
    y21 = y2 - y1,
    r21 = r2 - r1,
    l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a, b, c) {
  var x1 = a.x,
    y1 = a.y,
    r1 = a.r,
    x2 = b.x,
    y2 = b.y,
    r2 = b.r,
    x3 = c.x,
    y3 = c.y,
    r3 = c.r,
    a2 = x1 - x2,
    a3 = x1 - x3,
    b2 = y1 - y2,
    b3 = y1 - y3,
    c2 = r2 - r1,
    c3 = r3 - r1,
    d1 = x1 * x1 + y1 * y1 - r1 * r1,
    d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
    d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
    ab = a3 * b2 - a2 * b3,
    xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
    xb = (b3 * c2 - b2 * c3) / ab,
    ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
    yb = (a2 * c3 - a3 * c2) / ab,
    A = xb * xb + yb * yb - 1,
    B = 2 * (r1 + xa * xb + ya * yb),
    C = xa * xa + ya * ya - r1 * r1,
    r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constantZero = constantZero;
exports.default = _default;
function constantZero() {
  return 0;
}
function _default(x) {
  return function () {
    return x;
  };
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var g2_1 = __webpack_require__(14);
g2_1.registerInteraction('drag-move', {
  start: [{
    trigger: 'plot:mousedown',
    action: 'scale-translate:start'
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: 'scale-translate:translate',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: 'scale-translate:end'
  }]
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagFormatter = void 0;
var util_1 = __webpack_require__(0);
function conversionTagFormatter(prev, next) {
  if (!util_1.isNumber(prev) || !util_1.isNumber(next)) {
    return '-';
  }
  if (prev === next) {
    return '100%';
  }
  if (prev === 0) {
    return '∞';
  }
  if (next === 0) {
    return '-∞';
  }
  return (100 * next / prev).toFixed(2) + "%";
}
exports.conversionTagFormatter = conversionTagFormatter;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brushInteraction = void 0;
var util_1 = __webpack_require__(0);
var brush_1 = __webpack_require__(523);
var utils_1 = __webpack_require__(15);
__webpack_require__(523);
var BRUSH_TYPES = ['brush', 'brush-x', 'brush-y', 'brush-highlight', 'brush-x-highlight', 'brush-y-highlight'];
function brushInteraction(params) {
  var options = params.options;
  var brush = options.brush;
  
  var interactions = util_1.filter(options.interactions || [], function (i) {
    return BRUSH_TYPES.indexOf(i.type) === -1;
  });
  
  if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
    BRUSH_TYPES.forEach(function (type) {
      var _a;
      var enable = false;
      switch (brush.type) {
        case 'x-rect':
          enable = type === (brush.action === 'highlight' ? 'brush-x-highlight' : 'brush-x');
          break;
        case 'y-rect':
          enable = type === (brush.action === 'highlight' ? 'brush-y-highlight' : 'brush-y');
          break;
        default:
          enable = type === (brush.action === 'highlight' ? 'brush-highlight' : 'brush');
          break;
      }
      var obj = {
        type: type,
        enable: enable
      };
      if (((_a = brush.mask) === null || _a === void 0 ? void 0 : _a.style) || brush.type) {
        obj.cfg = brush_1.getInteractionCfg(type, brush.type, brush.mask);
      }
      interactions.push(obj);
    });
    
    if ((brush === null || brush === void 0 ? void 0 : brush.action) !== 'highlight') {
      interactions.push({
        type: 'filter-action',
        cfg: {
          buttonConfig: brush.button
        }
      });
    }
  }
  return utils_1.deepAssign({}, params, {
    options: {
      interactions: interactions
    }
  });
}
exports.brushInteraction = brushInteraction;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInteractionCfg = void 0;
var g2_1 = __webpack_require__(14);
var reset_button_1 = __webpack_require__(1123);
g2_1.registerAction('brush-reset-button', reset_button_1.ButtonAction, {
  name: 'brush-reset-button'
});
g2_1.registerInteraction('filter-action', {});
function isPointInView(context) {
  return context.isInPlot();
}
function getInteractionCfg(interactionType, brushType, mask) {
  var maskType = brushType || 'rect';
  switch (interactionType) {
    case 'brush':
      return {
        showEnable: [{
          trigger: 'plot:mouseenter',
          action: 'cursor:crosshair'
        }, {
          trigger: 'plot:mouseleave',
          action: 'cursor:default'
        }],
        start: [{
          trigger: 'mousedown',
          isEnable: isPointInView,
          action: ['brush:start', maskType + "-mask:start", maskType + "-mask:show"],
          
          arg: [null, {
            maskStyle: mask === null || mask === void 0 ? void 0 : mask.style
          }]
        }],
        processing: [{
          trigger: 'mousemove',
          isEnable: isPointInView,
          action: [maskType + "-mask:resize"]
        }],
        end: [{
          trigger: 'mouseup',
          isEnable: isPointInView,
          action: ['brush:filter', 'brush:end', maskType + "-mask:end", maskType + "-mask:hide", 'brush-reset-button:show']
        }],
        rollback: [{
          trigger: 'brush-reset-button:click',
          action: ['brush:reset', 'brush-reset-button:hide', 'cursor:crosshair']
        }]
      };
    case 'brush-highlight':
      return {
        showEnable: [{
          trigger: 'plot:mouseenter',
          action: 'cursor:crosshair'
        }, {
          trigger: 'mask:mouseenter',
          action: 'cursor:move'
        }, {
          trigger: 'plot:mouseleave',
          action: 'cursor:default'
        }, {
          trigger: 'mask:mouseleave',
          action: 'cursor:crosshair'
        }],
        start: [{
          trigger: 'plot:mousedown',
          isEnable: function isEnable(context) {
            
            return !context.isInShape('mask');
          },
          action: [maskType + "-mask:start", maskType + "-mask:show"],
          
          arg: [{
            maskStyle: mask === null || mask === void 0 ? void 0 : mask.style
          }]
        }, {
          trigger: 'mask:dragstart',
          action: [maskType + "-mask:moveStart"]
        }],
        processing: [{
          trigger: 'plot:mousemove',
          action: [maskType + "-mask:resize"]
        }, {
          trigger: 'mask:drag',
          action: [maskType + "-mask:move"]
        }, {
          trigger: 'mask:change',
          action: ['element-range-highlight:highlight']
        }],
        end: [{
          trigger: 'plot:mouseup',
          action: [maskType + "-mask:end"]
        }, {
          trigger: 'mask:dragend',
          action: [maskType + "-mask:moveEnd"]
        }, {
          trigger: 'document:mouseup',
          isEnable: function isEnable(context) {
            return !context.isInPlot();
          },
          action: ['element-range-highlight:clear', maskType + "-mask:end", maskType + "-mask:hide"]
        }],
        rollback: [{
          trigger: 'dblclick',
          action: ['element-range-highlight:clear', maskType + "-mask:hide"]
        }]
      };
    case 'brush-x':
      return {
        showEnable: [{
          trigger: 'plot:mouseenter',
          action: 'cursor:crosshair'
        }, {
          trigger: 'plot:mouseleave',
          action: 'cursor:default'
        }],
        start: [{
          trigger: 'mousedown',
          isEnable: isPointInView,
          action: ['brush-x:start', maskType + "-mask:start", maskType + "-mask:show"],
          
          arg: [null, {
            maskStyle: mask === null || mask === void 0 ? void 0 : mask.style
          }]
        }],
        processing: [{
          trigger: 'mousemove',
          isEnable: isPointInView,
          action: [maskType + "-mask:resize"]
        }],
        end: [{
          trigger: 'mouseup',
          isEnable: isPointInView,
          action: ['brush-x:filter', 'brush-x:end', maskType + "-mask:end", maskType + "-mask:hide"]
        }],
        rollback: [{
          trigger: 'dblclick',
          action: ['brush-x:reset']
        }]
      };
    case 'brush-x-highlight':
      return {
        showEnable: [{
          trigger: 'plot:mouseenter',
          action: 'cursor:crosshair'
        }, {
          trigger: 'mask:mouseenter',
          action: 'cursor:move'
        }, {
          trigger: 'plot:mouseleave',
          action: 'cursor:default'
        }, {
          trigger: 'mask:mouseleave',
          action: 'cursor:crosshair'
        }],
        start: [{
          trigger: 'plot:mousedown',
          isEnable: function isEnable(context) {
            
            return !context.isInShape('mask');
          },
          action: [maskType + "-mask:start", maskType + "-mask:show"],
          
          arg: [{
            maskStyle: mask === null || mask === void 0 ? void 0 : mask.style
          }]
        }, {
          trigger: 'mask:dragstart',
          action: [maskType + "-mask:moveStart"]
        }],
        processing: [{
          trigger: 'plot:mousemove',
          action: [maskType + "-mask:resize"]
        }, {
          trigger: 'mask:drag',
          action: [maskType + "-mask:move"]
        }, {
          trigger: 'mask:change',
          action: ['element-range-highlight:highlight']
        }],
        end: [{
          trigger: 'plot:mouseup',
          action: [maskType + "-mask:end"]
        }, {
          trigger: 'mask:dragend',
          action: [maskType + "-mask:moveEnd"]
        }, {
          trigger: 'document:mouseup',
          isEnable: function isEnable(context) {
            return !context.isInPlot();
          },
          action: ['element-range-highlight:clear', maskType + "-mask:end", maskType + "-mask:hide"]
        }],
        rollback: [{
          trigger: 'dblclick',
          action: ['element-range-highlight:clear', maskType + "-mask:hide"]
        }]
      };
    case 'brush-y':
      return {
        showEnable: [{
          trigger: 'plot:mouseenter',
          action: 'cursor:crosshair'
        }, {
          trigger: 'plot:mouseleave',
          action: 'cursor:default'
        }],
        start: [{
          trigger: 'mousedown',
          isEnable: isPointInView,
          action: ['brush-y:start', maskType + "-mask:start", maskType + "-mask:show"],
          
          arg: [null, {
            maskStyle: mask === null || mask === void 0 ? void 0 : mask.style
          }]
        }],
        processing: [{
          trigger: 'mousemove',
          isEnable: isPointInView,
          action: [maskType + "-mask:resize"]
        }],
        end: [{
          trigger: 'mouseup',
          isEnable: isPointInView,
          action: ['brush-y:filter', 'brush-y:end', maskType + "-mask:end", maskType + "-mask:hide"]
        }],
        rollback: [{
          trigger: 'dblclick',
          action: ['brush-y:reset']
        }]
      };
    case 'brush-y-highlight':
      return {
        showEnable: [{
          trigger: 'plot:mouseenter',
          action: 'cursor:crosshair'
        }, {
          trigger: 'mask:mouseenter',
          action: 'cursor:move'
        }, {
          trigger: 'plot:mouseleave',
          action: 'cursor:default'
        }, {
          trigger: 'mask:mouseleave',
          action: 'cursor:crosshair'
        }],
        start: [{
          trigger: 'plot:mousedown',
          isEnable: function isEnable(context) {
            
            return !context.isInShape('mask');
          },
          action: [maskType + "-mask:start", maskType + "-mask:show"],
          
          arg: [{
            maskStyle: mask === null || mask === void 0 ? void 0 : mask.style
          }]
        }, {
          trigger: 'mask:dragstart',
          action: [maskType + "-mask:moveStart"]
        }],
        processing: [{
          trigger: 'plot:mousemove',
          action: [maskType + "-mask:resize"]
        }, {
          trigger: 'mask:drag',
          action: [maskType + "-mask:move"]
        }, {
          trigger: 'mask:change',
          action: ['element-range-highlight:highlight']
        }],
        end: [{
          trigger: 'plot:mouseup',
          action: [maskType + "-mask:end"]
        }, {
          trigger: 'mask:dragend',
          action: [maskType + "-mask:moveEnd"]
        }, {
          trigger: 'document:mouseup',
          isEnable: function isEnable(context) {
            return !context.isInPlot();
          },
          action: ['element-range-highlight:clear', maskType + "-mask:end", maskType + "-mask:hide"]
        }],
        rollback: [{
          trigger: 'dblclick',
          action: ['element-range-highlight:clear', maskType + "-mask:hide"]
        }]
      };
    default:
      return {};
  }
}
exports.getInteractionCfg = getInteractionCfg;

g2_1.registerInteraction('brush', getInteractionCfg('brush'));

g2_1.registerInteraction('brush-highlight', getInteractionCfg('brush-highlight'));

g2_1.registerInteraction('brush-x', getInteractionCfg('brush-x', 'x-rect'));

g2_1.registerInteraction('brush-y', getInteractionCfg('brush-y', 'y-rect'));

g2_1.registerInteraction('brush-x-highlight', getInteractionCfg('brush-x-highlight', 'x-rect'));

g2_1.registerInteraction('brush-y-highlight', getInteractionCfg('brush-y-highlight', 'y-rect'));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformBarData = void 0;
function transformBarData(data) {
  return data ? data.slice().reverse() : data;
}
exports.transformBarData = transformBarData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = void 0;
var plot_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(15);
exports.DEFAULT_OPTIONS = utils_1.deepAssign({}, plot_1.Plot.getDefaultOptions(), {
  legend: {
    position: 'right'
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: {
      type: 'limit-in-plot',
      cfg: {
        action: 'ellipsis'
      }
    }
  },
    pieStyle: {
    stroke: 'white',
    lineWidth: 1
  },
    statistic: {
    title: {
      style: {
        fontWeight: 300,
        color: '#4B535E',
        textAlign: 'center',
        fontSize: '20px',
        lineHeight: 1
      }
    },
    content: {
      style: {
        fontWeight: 'bold',
        color: 'rgba(44,53,66,0.85)',
        textAlign: 'center',
        fontSize: '32px',
        lineHeight: 1
      }
    }
  },
    theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAllZero = exports.adaptOffset = exports.getTotalValue = void 0;
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
function getTotalValue(data, field) {
  var total = null;
  util_1.each(data, function (item) {
    if (typeof item[field] === 'number') {
      total += item[field];
    }
  });
  return total;
}
exports.getTotalValue = getTotalValue;
function adaptOffset(type, offset) {
  var defaultOffset;
  switch (type) {
    case 'inner':
      defaultOffset = '-30%';
      if (util_1.isString(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }
      return offset < 0 ? offset : defaultOffset;
    case 'outer':
      defaultOffset = 12;
      if (util_1.isString(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }
      return offset > 0 ? offset : defaultOffset;
    default:
      return offset;
  }
}
exports.adaptOffset = adaptOffset;
function isAllZero(data, angleField) {
  return util_1.every(utils_1.processIllegalData(data, angleField), function (d) {
    return d[angleField] === 0;
  });
}
exports.isAllZero = isAllZero;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PIE_STATISTIC = void 0;
var g2_1 = __webpack_require__(14);
var legend_active_1 = __webpack_require__(1129);
var statistic_active_1 = __webpack_require__(1130);
exports.PIE_STATISTIC = 'pie-statistic';
g2_1.registerAction(exports.PIE_STATISTIC, statistic_active_1.StatisticAction);
g2_1.registerInteraction('pie-statistic-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'pie-statistic:change'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'pie-statistic:reset'
  }]
});
g2_1.registerAction('pie-legend', legend_active_1.PieLegendAction);
g2_1.registerInteraction('pie-legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: 'pie-legend:active'
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: 'pie-legend:reset'
  }]
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = void 0;
var tslib_1 = __webpack_require__(1);
var g2_1 = __webpack_require__(14);
var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function transform(actions, matrix) {
  var ulMatrix = matrix ? tslib_1.__spreadArrays(matrix) : tslib_1.__spreadArrays(ORIGIN_MATRIX);
  return g2_1.Util.transform(ulMatrix, actions);
}
exports.transform = transform;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSingleKeyValues = exports.getFontSizeMapping = exports.processImageMask = exports.getSize = exports.transform = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var padding_1 = __webpack_require__(293);
var utils_1 = __webpack_require__(15);
var word_cloud_1 = __webpack_require__(1137);
function transform(params) {
  var rawOptions = params.options,
    chart = params.chart;
  var _a = chart,
    width = _a.width,
    height = _a.height,
    chartPadding = _a.padding,
    appendPadding = _a.appendPadding,
    ele = _a.ele;
  var data = rawOptions.data,
    imageMask = rawOptions.imageMask,
    wordField = rawOptions.wordField,
    weightField = rawOptions.weightField,
    colorField = rawOptions.colorField,
    wordStyle = rawOptions.wordStyle,
    timeInterval = rawOptions.timeInterval,
    random = rawOptions.random,
    spiral = rawOptions.spiral,
    _b = rawOptions.autoFit,
    autoFit = _b === void 0 ? true : _b,
    placementStrategy = rawOptions.placementStrategy;
  if (!data || !data.length) {
    return [];
  }
  var fontFamily = wordStyle.fontFamily,
    fontWeight = wordStyle.fontWeight,
    padding = wordStyle.padding,
    fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data, weightField);
  var range = [min(arr), max(arr)];
  
  var words = data.map(function (datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum: datum
    };
  });
  var options = {
    imageMask: imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range),
    fontWeight: fontWeight,
    
    size: getSize({
      width: width,
      height: height,
      padding: chartPadding,
      appendPadding: appendPadding,
      autoFit: autoFit,
      container: ele
    }),
    padding: padding,
    timeInterval: timeInterval,
    random: random,
    spiral: spiral,
    rotate: getRotate(rawOptions)
  };
  
  if (util_1.isFunction(placementStrategy)) {
    var result = words.map(function (word, index, words) {
      return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, word), {
        hasText: !!word.text,
        font: word_cloud_1.functor(options.font)(word, index, words),
        weight: word_cloud_1.functor(options.fontWeight)(word, index, words),
        rotate: word_cloud_1.functor(options.rotate)(word, index, words),
        size: word_cloud_1.functor(options.fontSize)(word, index, words),
        style: 'normal'
      }), placementStrategy.call(chart, word, index, words));
    });
    
    result.push({
      text: '',
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: '',
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  }
  // 数据准备在外部做，wordCloud 单纯就是做布局
  return word_cloud_1.wordCloud(words, options);
}
exports.transform = transform;
/**
 * 获取最终的实际绘图尺寸：[width, height]
 * @param chart
 */
function getSize(options) {
  var width = options.width,
    height = options.height;
  var container = options.container,
    autoFit = options.autoFit,
    padding = options.padding,
    appendPadding = options.appendPadding;
  // 由于词云图每个词语的坐标都是先通过 DataSet 根据图表宽高计算出来的，
  // 也就是说，如果一开始提供给 DataSet 的宽高信息和最终显示的宽高不相同，
  // 那么就会出现布局错乱的情况，所以这里处理的目的就是让一开始提供给 DataSet 的
  // 宽高信息与最终显示的宽高信息相同，避免显示错乱。
  if (autoFit) {
    var containerSize = utils_1.getContainerSize(container);
    width = containerSize.width;
    height = containerSize.height;
  }
  // 宽高不能为 0，否则会造成死循环
  width = width || 400;
  height = height || 400;
  var _a = resolvePadding({
      padding: padding,
      appendPadding: appendPadding
    }),
    top = _a[0],
    right = _a[1],
    bottom = _a[2],
    left = _a[3];
  var result = [width - (left + right), height - (top + bottom)];
  return result;
}
exports.getSize = getSize;
/**
 * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding
 * @param chart
 */
function resolvePadding(options) {
  var padding = padding_1.normalPadding(options.padding);
  var appendPadding = padding_1.normalPadding(options.appendPadding);
  var top = padding[0] + appendPadding[0];
  var right = padding[1] + appendPadding[1];
  var bottom = padding[2] + appendPadding[2];
  var left = padding[3] + appendPadding[3];
  return [top, right, bottom, left];
}
/**
 * 处理 imageMask 可能为 url 字符串的情况
 * @param  {HTMLImageElement | string} img
 * @return {Promise}
 */
function processImageMask(img) {
  return new Promise(function (res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (util_1.isString(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = 'anonymous';
      image_1.src = img;
      image_1.onload = function () {
        res(image_1);
      };
      image_1.onerror = function () {
        utils_1.log(utils_1.LEVEL.ERROR, false, 'image %s load failed !!!', img);
        rej();
      };
      return;
    }
    utils_1.log(utils_1.LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');
    rej();
  });
}
exports.processImageMask = processImageMask;
function getFontSizeMapping(fontSize, range) {
  if (util_1.isFunction(fontSize)) {
    return fontSize;
  }
  if (util_1.isArray(fontSize)) {
    var fMin_1 = fontSize[0],
      fMax_1 = fontSize[1];
    if (!range) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    var min_1 = range[0],
      max_1 = range[1];
    if (max_1 === min_1) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    return function fontSize(_a) {
      var value = _a.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value - min_1) + fMin_1;
    };
  }
  return function () {
    return fontSize;
  };
}
exports.getFontSizeMapping = getFontSizeMapping;
function getSingleKeyValues(data, key) {
  return data.map(function (v) {
    return v[key];
  }).filter(function (v) {
    
    if (typeof v === 'number' && !isNaN(v)) return true;
    return false;
  });
}
exports.getSingleKeyValues = getSingleKeyValues;
function getRotate(options) {
  var _a = resolveRotate(options),
    rotation = _a.rotation,
    rotationSteps = _a.rotationSteps;
  if (!util_1.isArray(rotation)) return rotation;
  var min = rotation[0];
  var max = rotation[1];
  
  var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);
  return function rotate() {
    if (max === min) return max;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;
  if (rotationSteps < 1) {
    utils_1.log(utils_1.LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');
    rotationSteps = 1;
  }
  return {
    rotation: options.wordStyle.rotation,
    rotationSteps: rotationSteps
  };
}
function min(numbers) {
  return Math.min.apply(Math, numbers);
}
function max(numbers) {
  return Math.max.apply(Math, numbers);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.WORD_CLOUD_COLOR_FIELD = void 0;
var plot_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(15);
exports.WORD_CLOUD_COLOR_FIELD = 'color';
exports.DEFAULT_OPTIONS = utils_1.deepAssign({}, plot_1.Plot.getDefaultOptions(), {
  timeInterval: 2000,
  legend: false,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: false,
    fields: ['text', 'value', exports.WORD_CLOUD_COLOR_FIELD],
    formatter: function formatter(datum) {
      return {
        name: datum.text,
        value: datum.value
      };
    }
  },
  wordStyle: {
    fontFamily: 'Verdana',
    fontWeight: 'normal',
    padding: 1,
    fontSize: [12, 60],
    rotation: [0, 90],
    rotationSteps: 2,
    rotateRatio: 0.5
  }
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basicFunnel = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
var tooltip_1 = __webpack_require__(64);
var base_1 = __webpack_require__(59);
var constant_1 = __webpack_require__(120);
var common_1 = __webpack_require__(300);
function field(params) {
  var chart = params.chart,
    options = params.options;
  var _a = options.data,
    data = _a === void 0 ? [] : _a,
    yField = options.yField,
    maxSize = options.maxSize,
    minSize = options.minSize;
  var formatData = common_1.transformData(data, data, {
    yField: yField,
    maxSize: maxSize,
    minSize: minSize
  });
  
  chart.data(formatData);
  return params;
}
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var xField = options.xField,
    yField = options.yField,
    color = options.color,
    tooltip = options.tooltip,
    label = options.label,
    _a = options.shape,
    shape = _a === void 0 ? 'funnel' : _a,
    funnelStyle = options.funnelStyle,
    state = options.state;
  var _b = tooltip_1.getTooltipMapping(tooltip, [xField, yField]),
    fields = _b.fields,
    formatter = _b.formatter;
  base_1.geometry({
    chart: chart,
    options: {
      type: 'interval',
      xField: xField,
      yField: constant_1.FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: util_1.isArray(fields) && fields.concat([constant_1.FUNNEL_PERCENT, constant_1.FUNNEL_CONVERSATION]),
      mapping: {
        shape: shape,
        tooltip: formatter,
        color: color,
        style: funnelStyle
      },
      label: label,
      state: state
    }
  });
  var geo = utils_1.findGeometry(params.chart, 'interval');
  geo.adjust('symmetric');
  return params;
}
function transpose(params) {
  var chart = params.chart,
    options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: 'rect',
    actions: !isTransposed ? [['transpose'], ['scale', 1, -1]] : []
  });
  return params;
}
function conversionTag(params) {
  var options = params.options;
  var maxSize = options.maxSize;
  var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
    var percent = maxSize - (maxSize - datum[constant_1.FUNNEL_MAPPING_VALUE]) / 2;
    return tslib_1.__assign(tslib_1.__assign({}, initLineOption), {
      start: [datumIndex - 0.5, percent],
      end: [datumIndex - 0.5, percent + 0.05]
    });
  };
  common_1.conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function basicFunnel(params) {
  return utils_1.flow(field, geometry, transpose, conversionTag)(params);
}
exports.basicFunnel = basicFunnel;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLiquidData = void 0;
var CAT_VALUE = 'liquid';
function getLiquidData(percent) {
  return [{
    percent: percent,
    type: CAT_VALUE
  }];
}
exports.getLiquidData = getLiquidData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binHistogram = void 0;
var util_1 = __webpack_require__(0);

function getBinKey(value, binWidth, binNumber) {
  
  if (binNumber === 1) {
    return [0, binWidth];
  }
  var index = Math.floor(value / binWidth);
  return [binWidth * index, binWidth * (index + 1)];
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
function binHistogram(data, binField, binWidth, binNumber, stackField) {
  var originData_copy = util_1.clone(data);
  
  util_1.sortBy(originData_copy, binField);
  
  var values = util_1.valuesOfKey(originData_copy, binField);
  var range = util_1.getRange(values);
  var rangeWidth = range.max - range.min;
  
  var _binWidth = binWidth;
  if (!binWidth && binNumber) {
    _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range.max;
  }
  
  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values);
    _binWidth = rangeWidth / _defaultBinNumber;
  }
  
  var bins = {};
  var groups = util_1.groupBy(originData_copy, stackField);
  
  if (util_1.isEmpty(groups)) {
    util_1.each(originData_copy, function (data) {
      var value = data[binField];
      var bin = getBinKey(value, _binWidth, binNumber);
      var binKey = bin[0] + "-" + bin[1];
      if (!util_1.hasKey(bins, binKey)) {
        bins[binKey] = {
          range: bin,
          count: 0
        };
      }
      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function (groupKey) {
      util_1.each(groups[groupKey], function (data) {
        var value = data[binField];
        var bin = getBinKey(value, _binWidth, binNumber);
        var binKey = bin[0] + "-" + bin[1];
        var groupKeyBinKey = binKey + "-" + groupKey;
        if (!util_1.hasKey(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = {
            range: bin,
            count: 0
          };
          bins[groupKeyBinKey][stackField] = groupKey;
        }
        bins[groupKeyBinKey].count += 1;
      });
    });
  }
  
  var plotData = [];
  util_1.each(bins, function (bin) {
    plotData.push(bin);
  });
  return plotData;
}
exports.binHistogram = binHistogram;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.HISTOGRAM_Y_FIELD = exports.HISTOGRAM_X_FIELD = void 0;
var plot_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(15);
exports.HISTOGRAM_X_FIELD = 'range';
exports.HISTOGRAM_Y_FIELD = 'count';
exports.DEFAULT_OPTIONS = utils_1.deepAssign({}, plot_1.Plot.getDefaultOptions(), {
  columnStyle: {
    stroke: '#FFFFFF'
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{
    type: 'active-region'
  }]
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = exports.processData = void 0;
var tslib_1 = __webpack_require__(1);
var util_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(15);
var constant_1 = __webpack_require__(301);
function processData(data, xField, yField, newYField, total) {
  var _a;
  var newData = [];
  util_1.reduce(data, function (r, d) {
    var _a;
    
    utils_1.log(utils_1.LEVEL.WARN, util_1.isNumber(d[yField]), d[yField] + " is not a valid number");
    var value = util_1.isUndefined(d[yField]) ? null : d[yField];
    newData.push(tslib_1.__assign(tslib_1.__assign({}, d), (_a = {}, _a[newYField] = [r, r + value], _a)));
    return r + value;
  }, 0);
  
  if (newData.length && total) {
    var sum = util_1.get(newData, [[data.length - 1], newYField, [1]]);
    newData.push((_a = {}, _a[xField] = total.label, _a[yField] = sum, _a[newYField] = [0, sum], _a));
  }
  return newData;
}
exports.processData = processData;
function transformData(data, xField, yField, total) {
  var processed = processData(data, xField, yField, constant_1.Y_FIELD, total);
  return processed.map(function (d, dIdx) {
    var _a;
    if (!util_1.isObject(d)) {
      return d;
    }
    return tslib_1.__assign(tslib_1.__assign({}, d), (_a = {}, _a[constant_1.ABSOLUTE_FIELD] = d[constant_1.Y_FIELD][1], _a[constant_1.DIFF_FIELD] = d[constant_1.Y_FIELD][1] - d[constant_1.Y_FIELD][0], _a[constant_1.IS_TOTAL] = dIdx === data.length, _a));
  });
}
exports.transformData = transformData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));

(function (global, factory) {
  ( false ? undefined : (0, _typeof2.default)(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(void 0, function (exports) {
  'use strict';

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  
  
  
  function points(data, x, y, sort) {
    data = data.filter(function (d, i) {
      var u = x(d, i),
        v = y(d, i);
      return u != null && isFinite(u) && v != null && isFinite(v);
    });
    if (sort) {
      data.sort(function (a, b) {
        return x(a) - x(b);
      });
    }
    var n = data.length,
      X = new Float64Array(n),
      Y = new Float64Array(n); 

    var ux = 0,
      uy = 0,
      xv,
      yv,
      d;
    for (var i = 0; i < n;) {
      d = data[i];
      X[i] = xv = +x(d, i, data);
      Y[i] = yv = +y(d, i, data);
      ++i;
      ux += (xv - ux) / i;
      uy += (yv - uy) / i;
    } 

    for (var _i = 0; _i < n; ++_i) {
      X[_i] -= ux;
      Y[_i] -= uy;
    }
    return [X, Y, ux, uy];
  }
  function visitPoints(data, x, y, cb) {
    var iterations = 0;
    for (var i = 0, n = data.length; i < n; i++) {
      var d = data[i],
        dx = +x(d, i, data),
        dy = +y(d, i, data);
      if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
        cb(dx, dy, iterations++);
      }
    }
  }

  

  function determination(data, x, y, uY, predict) {
    var SSE = 0,
      SST = 0;
    visitPoints(data, x, y, function (dx, dy) {
      var sse = dy - predict(dx),
        sst = dy - uY;
      SSE += sse * sse;
      SST += sst * sst;
    });
    return 1 - SSE / SST;
  }

  
  function angle(line) {
    return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * 180 / Math.PI;
  } 

  function midpoint(line) {
    return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];
  }

  

  function interpose(xmin, xmax, predict) {
    var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
    var precision = 1 * Math.pow(10, -l / 2 - 1),
      maxIter = 1e4;
    var points = [px(xmin), px(xmax)],
      iter = 0;
    while (find(points) && iter < maxIter) {}
    return points;
    function px(x) {
      return [x, predict(x)];
    }
    function find(points) {
      iter++;
      var n = points.length;
      var found = false;
      for (var i = 0; i < n - 1; i++) {
        var p0 = points[i],
          p1 = points[i + 1],
          m = midpoint([p0, p1]),
          mp = px(m[0]),
          a0 = angle([p0, m]),
          a1 = angle([p0, mp]),
          a = Math.abs(a0 - a1);
        if (a > precision) {
          points.splice(i + 1, 0, mp);
          found = true;
        }
      }
      return found;
    }
  }

  
  
  
  function ols(uX, uY, uXY, uX2) {
    var delta = uX2 - uX * uX,
      slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
      intercept = uY - slope * uX;
    return [intercept, slope];
  }
  function exponential() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      domain;
    function exponential(data) {
      var n = 0,
        Y = 0,
        YL = 0,
        XY = 0,
        XYL = 0,
        X2Y = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        var ly = Math.log(dy),
          xy = dx * dy;
        ++n;
        Y += (dy - Y) / n;
        XY += (xy - XY) / n;
        X2Y += (dx * xy - X2Y) / n;
        YL += (dy * ly - YL) / n;
        XYL += (xy * ly - XYL) / n;
        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y),
        _ols2 = _slicedToArray(_ols, 2),
        a = _ols2[0],
        b = _ols2[1];
      a = Math.exp(a);
      var fn = function fn(x) {
          return a * Math.exp(b * x);
        },
        out = interpose(xmin, xmax, fn);
      out.a = a;
      out.b = b;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }
    exponential.domain = function (arr) {
      return arguments.length ? (domain = arr, exponential) : domain;
    };
    exponential.x = function (fn) {
      return arguments.length ? (x = fn, exponential) : x;
    };
    exponential.y = function (fn) {
      return arguments.length ? (y = fn, exponential) : y;
    };
    return exponential;
  }
  function linear() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      domain;
    function linear(data) {
      var n = 0,
        X = 0,
        
        Y = 0,
        
        XY = 0,
        
        X2 = 0,
        
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        ++n;
        X += (dx - X) / n;
        Y += (dy - Y) / n;
        XY += (dx * dy - XY) / n;
        X2 += (dx * dx - X2) / n;
        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var _ols = ols(X, Y, XY, X2),
        _ols2 = _slicedToArray(_ols, 2),
        intercept = _ols2[0],
        slope = _ols2[1],
        fn = function fn(x) {
          return slope * x + intercept;
        },
        out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];
      out.a = slope;
      out.b = intercept;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }
    linear.domain = function (arr) {
      return arguments.length ? (domain = arr, linear) : domain;
    };
    linear.x = function (fn) {
      return arguments.length ? (x = fn, linear) : x;
    };
    linear.y = function (fn) {
      return arguments.length ? (y = fn, linear) : y;
    };
    return linear;
  }

  
  function median(arr) {
    arr.sort(function (a, b) {
      return a - b;
    });
    var i = arr.length / 2;
    return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
  }
  var maxiters = 2,
    epsilon = 1e-12;
  function loess() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      bandwidth = .3;
    function loess(data) {
      var _points = points(data, x, y, true),
        _points2 = _slicedToArray(_points, 4),
        xv = _points2[0],
        yv = _points2[1],
        ux = _points2[2],
        uy = _points2[3],
        n = xv.length,
        bw = Math.max(2, ~~(bandwidth * n)),
        yhat = new Float64Array(n),
        residuals = new Float64Array(n),
        robustWeights = new Float64Array(n).fill(1);
      for (var iter = -1; ++iter <= maxiters;) {
        var interval = [0, bw - 1];
        for (var i = 0; i < n; ++i) {
          var dx = xv[i],
            i0 = interval[0],
            i1 = interval[1],
            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
          var W = 0,
            X = 0,
            Y = 0,
            XY = 0,
            X2 = 0,
            denom = 1 / Math.abs(xv[edge] - dx || 1); 

          for (var k = i0; k <= i1; ++k) {
            var xk = xv[k],
              yk = yv[k],
              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
              xkw = xk * w;
            W += w;
            X += xkw;
            Y += yk * w;
            XY += yk * xkw;
            X2 += xk * xkw;
          } 

          var _ols = ols(X / W, Y / W, XY / W, X2 / W),
            _ols2 = _slicedToArray(_ols, 2),
            a = _ols2[0],
            b = _ols2[1];
          yhat[i] = a + b * dx;
          residuals[i] = Math.abs(yv[i] - yhat[i]);
          updateInterval(xv, i + 1, interval);
        }
        if (iter === maxiters) {
          break;
        }
        var medianResidual = median(residuals);
        if (Math.abs(medianResidual) < epsilon) break;
        for (var _i = 0, arg, _w; _i < n; ++_i) {
          arg = residuals[_i] / (6 * medianResidual); 
          

          robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
        }
      }
      return output(xv, yhat, ux, uy);
    }
    loess.bandwidth = function (bw) {
      return arguments.length ? (bandwidth = bw, loess) : bandwidth;
    };
    loess.x = function (fn) {
      return arguments.length ? (x = fn, loess) : x;
    };
    loess.y = function (fn) {
      return arguments.length ? (y = fn, loess) : y;
    };
    return loess;
  } 

  function tricube(x) {
    return (x = 1 - x * x * x) * x * x;
  } 

  function updateInterval(xv, i, interval) {
    var val = xv[i],
      left = interval[0],
      right = interval[1] + 1;
    if (right >= xv.length) return; 
    

    while (i > left && xv[right] - val <= val - xv[left]) {
      interval[0] = ++left;
      interval[1] = right;
      ++right;
    }
  } 
  

  function output(xv, yhat, ux, uy) {
    var n = xv.length,
      out = [];
    var i = 0,
      cnt = 0,
      prev = [],
      v;
    for (; i < n; ++i) {
      v = xv[i] + ux;
      if (prev[0] === v) {
        
        prev[1] += (yhat[i] - prev[1]) / ++cnt;
      } else {
        
        cnt = 0;
        prev[1] += uy;
        prev = [v, yhat[i]];
        out.push(prev);
      }
    }
    prev[1] += uy;
    return out;
  }
  function logarithmic() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      base = Math.E,
      domain;
    function logarithmic(data) {
      var n = 0,
        X = 0,
        Y = 0,
        XY = 0,
        X2 = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity,
        lb = Math.log(base);
      visitPoints(data, x, y, function (dx, dy) {
        var lx = Math.log(dx) / lb;
        ++n;
        X += (lx - X) / n;
        Y += (dy - Y) / n;
        XY += (lx * dy - XY) / n;
        X2 += (lx * lx - X2) / n;
        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var _ols = ols(X, Y, XY, X2),
        _ols2 = _slicedToArray(_ols, 2),
        intercept = _ols2[0],
        slope = _ols2[1],
        fn = function fn(x) {
          return slope * Math.log(x) / lb + intercept;
        },
        out = interpose(xmin, xmax, fn);
      out.a = slope;
      out.b = intercept;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }
    logarithmic.domain = function (arr) {
      return arguments.length ? (domain = arr, logarithmic) : domain;
    };
    logarithmic.x = function (fn) {
      return arguments.length ? (x = fn, logarithmic) : x;
    };
    logarithmic.y = function (fn) {
      return arguments.length ? (y = fn, logarithmic) : y;
    };
    logarithmic.base = function (n) {
      return arguments.length ? (base = n, logarithmic) : base;
    };
    return logarithmic;
  }
  function quad() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      domain;
    function quadratic(data) {
      var _points = points(data, x, y),
        _points2 = _slicedToArray(_points, 4),
        xv = _points2[0],
        yv = _points2[1],
        ux = _points2[2],
        uy = _points2[3],
        n = xv.length;
      var X2 = 0,
        X3 = 0,
        X4 = 0,
        XY = 0,
        X2Y = 0,
        i,
        dx,
        dy,
        x2;
      for (i = 0; i < n;) {
        dx = xv[i];
        dy = yv[i++];
        x2 = dx * dx;
        X2 += (x2 - X2) / i;
        X3 += (x2 * dx - X3) / i;
        X4 += (x2 * x2 - X4) / i;
        XY += (dx * dy - XY) / i;
        X2Y += (x2 * dy - X2Y) / i;
      }
      var Y = 0,
        n0 = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        n0++;
        Y += (dy - Y) / n0;
        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var X2X2 = X4 - X2 * X2,
        d = X2 * X2X2 - X3 * X3,
        a = (X2Y * X2 - XY * X3) / d,
        b = (XY * X2X2 - X2Y * X3) / d,
        c = -a * X2,
        fn = function fn(x) {
          x = x - ux;
          return a * x * x + b * x + c + uy;
        };
      var out = interpose(xmin, xmax, fn);
      out.a = a;
      out.b = b - 2 * a * ux;
      out.c = c - b * ux + a * ux * ux + uy;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }
    quadratic.domain = function (arr) {
      return arguments.length ? (domain = arr, quadratic) : domain;
    };
    quadratic.x = function (fn) {
      return arguments.length ? (x = fn, quadratic) : x;
    };
    quadratic.y = function (fn) {
      return arguments.length ? (y = fn, quadratic) : y;
    };
    return quadratic;
  }

  
  
  
  
  

  function polynomial() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      order = 3,
      domain;
    function polynomial(data) {
      
      if (order === 1) {
        var o = linear().x(x).y(y).domain(domain)(data);
        o.coefficients = [o.b, o.a];
        delete o.a;
        delete o.b;
        return o;
      }
      if (order === 2) {
        var _o = quad().x(x).y(y).domain(domain)(data);
        _o.coefficients = [_o.c, _o.b, _o.a];
        delete _o.a;
        delete _o.b;
        delete _o.c;
        return _o;
      }
      var _points = points(data, x, y),
        _points2 = _slicedToArray(_points, 4),
        xv = _points2[0],
        yv = _points2[1],
        ux = _points2[2],
        uy = _points2[3],
        n = xv.length,
        lhs = [],
        rhs = [],
        k = order + 1;
      var Y = 0,
        n0 = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        ++n0;
        Y += (dy - Y) / n0;
        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var i, j, l, v, c;
      for (i = 0; i < k; ++i) {
        for (l = 0, v = 0; l < n; ++l) {
          v += Math.pow(xv[l], i) * yv[l];
        }
        lhs.push(v);
        c = new Float64Array(k);
        for (j = 0; j < k; ++j) {
          for (l = 0, v = 0; l < n; ++l) {
            v += Math.pow(xv[l], i + j);
          }
          c[j] = v;
        }
        rhs.push(c);
      }
      rhs.push(lhs);
      var coef = gaussianElimination(rhs),
        fn = function fn(x) {
          x -= ux;
          var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;
          for (i = 3; i < k; ++i) {
            y += coef[i] * Math.pow(x, i);
          }
          return y;
        },
        out = interpose(xmin, xmax, fn);
      out.coefficients = uncenter(k, coef, -ux, uy);
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }
    polynomial.domain = function (arr) {
      return arguments.length ? (domain = arr, polynomial) : domain;
    };
    polynomial.x = function (fn) {
      return arguments.length ? (x = fn, polynomial) : x;
    };
    polynomial.y = function (fn) {
      return arguments.length ? (y = fn, polynomial) : y;
    };
    polynomial.order = function (n) {
      return arguments.length ? (order = n, polynomial) : order;
    };
    return polynomial;
  }
  function uncenter(k, a, x, y) {
    var z = Array(k);
    var i, j, v, c; 

    for (i = 0; i < k; ++i) {
      z[i] = 0;
    } 

    for (i = k - 1; i >= 0; --i) {
      v = a[i];
      c = 1;
      z[i] += v;
      for (j = 1; j <= i; ++j) {
        c *= (i + 1 - j) / j; 

        z[i - j] += v * Math.pow(x, j) * c;
      }
    } 

    z[0] += y;
    return z;
  } 
  

  function gaussianElimination(matrix) {
    var n = matrix.length - 1,
      coef = [];
    var i, j, k, r, t;
    for (i = 0; i < n; ++i) {
      r = i; 

      for (j = i + 1; j < n; ++j) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
          r = j;
        }
      }
      for (k = i; k < n + 1; ++k) {
        t = matrix[k][i];
        matrix[k][i] = matrix[k][r];
        matrix[k][r] = t;
      }
      for (j = i + 1; j < n; ++j) {
        for (k = n; k >= i; k--) {
          matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
        }
      }
    }
    for (j = n - 1; j >= 0; --j) {
      t = 0;
      for (k = j + 1; k < n; ++k) {
        t += matrix[k][j] * coef[k];
      }
      coef[j] = (matrix[n][j] - t) / matrix[j][j];
    }
    return coef;
  }
  function power() {
    var x = function x(d) {
        return d[0];
      },
      y = function y(d) {
        return d[1];
      },
      domain;
    function power(data) {
      var n = 0,
        X = 0,
        Y = 0,
        XY = 0,
        X2 = 0,
        YS = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        var lx = Math.log(dx),
          ly = Math.log(dy);
        ++n;
        X += (lx - X) / n;
        Y += (ly - Y) / n;
        XY += (lx * ly - XY) / n;
        X2 += (lx * lx - X2) / n;
        YS += (dy - YS) / n;
        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var _ols = ols(X, Y, XY, X2),
        _ols2 = _slicedToArray(_ols, 2),
        a = _ols2[0],
        b = _ols2[1];
      a = Math.exp(a);
      var fn = function fn(x) {
          return a * Math.pow(x, b);
        },
        out = interpose(xmin, xmax, fn);
      out.a = a;
      out.b = b;
      out.predict = fn;
      out.rSquared = determination(data, x, y, YS, fn);
      return out;
    }
    power.domain = function (arr) {
      return arguments.length ? (domain = arr, power) : domain;
    };
    power.x = function (fn) {
      return arguments.length ? (x = fn, power) : x;
    };
    power.y = function (fn) {
      return arguments.length ? (y = fn, power) : y;
    };
    return power;
  }
  exports.regressionExp = exponential;
  exports.regressionLinear = linear;
  exports.regressionLoess = loess;
  exports.regressionLog = logarithmic;
  exports.regressionPoly = polynomial;
  exports.regressionPow = power;
  exports.regressionQuad = quad;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = void 0;
function transformData(options) {
  var data = options.data,
    xField = options.xField,
    measureField = options.measureField,
    rangeField = options.rangeField,
    targetField = options.targetField,
    layout = options.layout;
  var ds = [];
  var scales = [];
  data.forEach(function (item, index) {
    var _a;
    
    item[rangeField].sort(function (a, b) {
      return a - b;
    });
    item[rangeField].forEach(function (d, i) {
      var _a;
      var range = i === 0 ? d : item[rangeField][i] - item[rangeField][i - 1];
      ds.push((_a = {
        rKey: rangeField + "_" + i
      }, _a[xField] = xField ? item[xField] : String(index), _a[rangeField] = range, _a));
    });
    
    item[measureField].forEach(function (d, i) {
      var _a;
      ds.push((_a = {
        mKey: item[measureField].length > 1 ? measureField + "_" + i : "" + measureField
      }, _a[xField] = xField ? item[xField] : String(index), _a[measureField] = d, _a));
    });
    // 构建 title * target
    ds.push((_a = {
      tKey: "" + targetField
    }, _a[xField] = xField ? item[xField] : String(index), _a[targetField] = item[targetField], _a));
    // 为了取最大值和最小值，先存储
    scales.push(item[rangeField], item[measureField], item[targetField]);
  });
  // scales 是嵌套的需要拍平
  var min = Math.min.apply(Math, scales.flat(Infinity));
  var max = Math.max.apply(Math, scales.flat(Infinity));
  // min 大于 0 从 0 开始
  min = min > 0 ? 0 : min;
  // 垂直情况，需要反转数据
  if (layout === 'vertical') {
    ds.reverse();
  }
  return {
    min: min,
    max: max,
    ds: ds
  };
}
exports.transformData = transformData;

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick = pick;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
function pick(obj, keys) {
  var r = {};
  if (obj !== null && (0, _typeof2.default)(obj) === 'object') {
    keys.forEach(function (key) {
      var v = obj[key];
      if (v !== undefined) {
        r[key] = v;
      }
    });
  }
  return r;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LEVEL = void 0;
exports.invariant = invariant;
exports.log = log;
var _tslib = __webpack_require__(1);

var LEVEL;
exports.LEVEL = LEVEL;
(function (LEVEL) {
  LEVEL["ERROR"] = "error";
  LEVEL["WARN"] = "warn";
  LEVEL["INFO"] = "log";
})(LEVEL || (exports.LEVEL = LEVEL = {}));
var BRAND = 'AntV/G2Plot';
function getMessage(format) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var argIndex = 0;
  return BRAND + ": " + format.replace(/%s/g, function () {
    return "" + args[argIndex++];
  });
}
/**
 * invariant error
 * @param condition
 * @param format
 * @param args
 */
function invariant(condition, format) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (!condition) {
    var error = new Error(getMessage.apply(void 0, (0, _tslib.__spreadArrays)([format], args)));
    error.name = BRAND;
    // error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}
/**
 * 打印语句
 * @param level
 * @param condition
 * @param format
 * @param args
 */
function log(level, condition, format) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  if (!condition) {
    console[level](getMessage.apply(void 0, (0, _tslib.__spreadArrays)([format], args)));
  }
}

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findViewById = findViewById;
exports.getSiblingViews = getSiblingViews;
exports.getViews = getViews;
function findViewById(chart, id) {
  return chart.views.find(function (view) {
    return view.id === id;
  });
}
function getViews(view) {
  var parent = view.parent;
  return parent ? parent.views : [];
}
function getSiblingViews(view) {
  return getViews(view).filter(function (sub) {
    return sub !== view;
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepAssign = void 0;
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
var MAX_MIX_LEVEL = 5; 
var toString = {}.toString;

var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};
var isArray = function isArray(value) {
  return isType(value, 'Array');
};
var isObjectLike = function isObjectLike(value) {
    return (0, _typeof2.default)(value) === 'object' && value !== null;
};
var isPlainObject = function isPlainObject(value) {
    if (!isObjectLike(value) || !isType(value, 'Object')) {
    return false;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var deep = function deep(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      var value = src[key];
      if (!value) {
        
        dist[key] = value;
      } else {
        if (isPlainObject(value)) {
          if (!isPlainObject(dist[key])) {
            dist[key] = {};
          }
          if (level < maxLevel) {
            deep(dist[key], value, level + 1, maxLevel);
          } else {
            
            dist[key] = src[key];
          }
        } else if (isArray(value)) {
          dist[key] = [];
          dist[key] = dist[key].concat(value);
        } else {
          dist[key] = value;
        }
      }
    }
  }
};
var deepAssign = function deepAssign(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};
exports.deepAssign = deepAssign;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapteStyle = adapteStyle;
exports.renderStatistic = exports.renderGaugeStatistic = void 0;
exports.setStatisticContainerStyle = setStatisticContainerStyle;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _ = __webpack_require__(7);
function adapteStyle(style) {
  var styleObject = {
    overflow: 'hidden',
    'white-space': 'nowrap',
    'text-overflow': 'ellipsis',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center'
  };
  var shapeStyleKeys = ['stroke', 'lineWidth', 'shadowColor', 'strokeOpacity', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'fill'];
  
  if ((0, _util.get)(style, 'fill')) {
    styleObject['color'] = style['fill'];
  }
  var _a = (0, _.pick)(style, shapeStyleKeys),
    shadowColor = _a.shadowColor,
    _b = _a.shadowBlur,
    shadowBlur = _b === void 0 ? 0 : _b,
    _c = _a.shadowOffsetX,
    shadowOffsetX = _c === void 0 ? 0 : _c,
    _d = _a.shadowOffsetY,
    shadowOffsetY = _d === void 0 ? 0 : _d;
  styleObject['text-shadow'] = "" + [shadowColor, shadowOffsetX + "px", shadowOffsetY + "px", shadowBlur + "px"].join(' ');
  var _e = (0, _.pick)(style, shapeStyleKeys),
    stroke = _e.stroke,
    _f = _e.lineWidth,
    lineWidth = _f === void 0 ? 0 : _f;
  styleObject['-webkit-text-stroke'] = "" + [lineWidth + "px", stroke].join(' ');
  
  (0, _util.each)(style, function (v, k) {
    
    if (['fontSize'].includes(k) && (0, _util.isNumber)(v)) {
      styleObject[(0, _.kebabCase)(k)] = v + "px";
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[(0, _.kebabCase)(k)] = "" + v;
    }
  });
  return styleObject;
}
/**
 * @desc 设置 html-statistic 容器的默认样式
 *
 * - 默认事件穿透
 */
function setStatisticContainerStyle(container, style) {
  container.style['pointer-events'] = 'none';
  (0, _util.each)(style, function (v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}
/**
 * 渲染环图 html-annotation（默认 position 居中 [50%, 50%]）
 * @param chart
 * @param options
 * @param meta 字段元信息
 * @param {optional} datum 当前的元数据
 */
var renderStatistic = function renderStatistic(chart, options, datum) {
  var statistic = options.statistic,
    plotType = options.plotType;
  var titleOpt = statistic.title,
    contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option, idx) {
    if (!option) {
      return;
    }
    var transform = '';
    if (idx === 0) {
      transform = contentOpt ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
    } else {
      transform = titleOpt ? 'translate(-50%, 0)' : 'translate(-50%, -50%)';
    }
    var style = (0, _util.isFunction)(option.style) ? option.style(datum) : option.style;
    chart.annotation().html((0, _tslib.__assign)({
      position: ['50%', '50%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate();
        var containerW = 0;
        if (plotType === 'pie' || plotType === 'ring-progress') {
          containerW = coordinate.getRadius() * coordinate.innerRadius * 2;
        } else if (plotType === 'liquid') {
          var liquidShape = (0, _util.get)(view.geometries, [0, 'elements', 0, 'shape']);
          if (liquidShape) {
            // 获取到水波图边框大小
            var path = liquidShape.find(function (t) {
              return t.get('name') === 'wrap';
            });
            var width = path.getCanvasBBox().width;
            containerW = width;
          }
        } else if (!containerW) {
          // 保底方案
          containerW = coordinate.getWidth();
        }
        setStatisticContainerStyle(container, (0, _tslib.__assign)({
          width: containerW + "px",
          transform: transform
        }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text = option.content;
        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        }
        
        return text ? (0, _util.isString)(text) ? text : "" + text : '<div></div>';
      },
      // @ts-ignore
      key: (idx === 0 ? 'top' : 'bottom') + "-statistic"
    }, (0, _.pick)(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter']) ));
  });
};
exports.renderStatistic = renderStatistic;
var renderGaugeStatistic = function renderGaugeStatistic(chart, options, datum) {
  var statistic = options.statistic;
  var titleOpt = statistic.title,
    contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option) {
    if (!option) {
      return;
    }
    var style = (0, _util.isFunction)(option.style) ? option.style(datum) : option.style;
    chart.annotation().html((0, _tslib.__assign)({
      position: ['50%', '100%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate();
        
        var polarCoord = view.views[0].getCoordinate();
        var polarCenter = polarCoord.getCenter();
        var polarRadius = polarCoord.getRadius();
        var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
        var offsetY = polarCenter.y + polarMaxY - coordinate.y.start - parseFloat((0, _util.get)(style, 'fontSize', 0));
        var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
        setStatisticContainerStyle(container, (0, _tslib.__assign)({
          width: containerWidth + "px",
          transform: "translate(-50%, " + offsetY + "px)"
        }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text = option.content;
        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        }
        
        return text ? (0, _util.isString)(text) ? text : "" + text : '<div></div>';
      }
    }, (0, _.pick)(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter']) /** 透传配置 */));
  });
};
exports.renderGaugeStatistic = renderGaugeStatistic;

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLOBAL = void 0;
exports.setGlobal = setGlobal;
var _util = __webpack_require__(0);
var GLOBAL = {
    locale: 'en-US'
};
exports.GLOBAL = GLOBAL;
function setGlobal(datum) {
  (0, _util.each)(datum, function (v, k) {
    return GLOBAL[k] = v;
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Line = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _adaptor = __webpack_require__(303);
var _constants = __webpack_require__(1192);
__webpack_require__(1193);
var Line = function (_super) {
  (0, _tslib.__extends)(Line, _super);
  function Line() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'line';
    return _this;
  }
    Line.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    Line.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    this.chart.changeData(data);
  };
    Line.prototype.getDefaultOptions = function () {
    return Line.getDefaultOptions();
  };
    Line.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Line;
}(_plot.Plot);
exports.Line = Line;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCanvasPattern = getCanvasPattern;
var _dot = __webpack_require__(1183);
var _line = __webpack_require__(1184);
var _square = __webpack_require__(1185);
function getCanvasPattern(options) {
  var type = options.type,
    cfg = options.cfg;
  var pattern;
  switch (type) {
    case 'dot':
      pattern = (0, _dot.createDotPattern)(cfg);
      break;
    case 'line':
      pattern = (0, _line.createLinePattern)(cfg);
      break;
    case 'square':
      pattern = (0, _square.createSquarePattern)(cfg);
      break;
    default:
      break;
  }
  return pattern;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = point;
var _tslib = __webpack_require__(1);
var _tooltip = __webpack_require__(65);
var _utils = __webpack_require__(7);
var _base = __webpack_require__(49);
function point(params) {
  var options = params.options;
  var point = options.point,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField,
    sizeField = options.sizeField,
    shapeField = options.shapeField,
    tooltip = options.tooltip;
  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField, sizeField, shapeField]),
    fields = _a.fields,
    formatter = _a.formatter;
  return point ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'point',
      colorField: seriesField,
      shapeField: shapeField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        tooltip: formatter
      }, point)
    }
  })) : params;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polygon = polygon;
var _tslib = __webpack_require__(1);
var _tooltip = __webpack_require__(65);
var _utils = __webpack_require__(7);
var _base = __webpack_require__(49);
function polygon(params) {
  var options = params.options;
  var polygon = options.polygon,
    xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField,
    tooltip = options.tooltip;
  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField]),
    fields = _a.fields,
    formatter = _a.formatter;
  return polygon ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'polygon',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        tooltip: formatter
      }, polygon)
    }
  })) : params;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Area = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _percent = __webpack_require__(123);
var _adaptor = __webpack_require__(549);
var _constants = __webpack_require__(1195);
var Area = function (_super) {
  (0, _tslib.__extends)(Area, _super);
  function Area() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'area';
    return _this;
  }
    Area.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    Area.prototype.getDefaultOptions = function () {
    return Area.getDefaultOptions();
  };
    Area.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
      isPercent = _a.isPercent,
      xField = _a.xField,
      yField = _a.yField;
    var _b = this,
      chart = _b.chart,
      options = _b.options;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    this.chart.changeData((0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent));
  };
    Area.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Area;
}(_plot.Plot);
exports.Area = Area;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
Object.defineProperty(exports, "meta", {
  enumerable: true,
  get: function get() {
    return _adaptor.meta;
  }
});
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _common = __webpack_require__(22);
var _utils = __webpack_require__(7);
var _geometries = __webpack_require__(30);
var _percent = __webpack_require__(123);
var _adaptor = __webpack_require__(303);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    areaStyle = options.areaStyle,
    color = options.color,
    pointMapping = options.point,
    lineMapping = options.line,
    isPercent = options.isPercent,
    xField = options.xField,
    yField = options.yField,
    tooltip = options.tooltip,
    seriesField = options.seriesField,
    startOnZero = options.startOnZero;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var chartData = (0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent);
  chart.data(chartData);
  
  var tooltipOptions = isPercent ? (0, _tslib.__assign)({
    formatter: function formatter(datum) {
      return {
        name: datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      area: {
        color: color,
        style: areaStyle
      },
      
      
      line: lineMapping && (0, _tslib.__assign)({
        color: color
      }, lineMapping),
      point: pointMapping && (0, _tslib.__assign)({
        color: color
      }, pointMapping),
      tooltip: tooltipOptions,
      
      label: undefined,
      args: {
        startOnZero: startOnZero
      }
    }
  });
  
  var lineParams = (0, _utils.deepAssign)({
    options: {
      line: {
        size: 2
      }
    }
  }, primary, {
    options: {
      sizeField: seriesField,
      tooltip: false
    }
  });
  var pointParams = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  
  (0, _geometries.area)(primary);
  (0, _geometries.line)(lineParams);
  (0, _geometries.point)(pointParams);
  return params;
}
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    yField = options.yField;
  var areaGeometry = (0, _utils.findGeometry)(chart, 'area');
  
  if (!label) {
    areaGeometry.label(false);
  } else {
    var callback = label.callback,
      cfg = (0, _tslib.__rest)(label, ["callback"]);
    areaGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _tslib.__assign)({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, (0, _utils.transformLabel)(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart,
    options = params.options;
  var isStack = options.isStack,
    isPercent = options.isPercent,
    seriesField = options.seriesField;
  if ((isPercent || isStack) && seriesField) {
    (0, _util.each)(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }
  return params;
}
function adaptor(params) {
  
  return (0, _utils.flow)(_common.theme, (0, _common.pattern)('areaStyle'), geometry, _adaptor.meta, adjust, _adaptor.axis, _adaptor.legend, _common.tooltip, label, _common.slider, (0, _common.annotation)(), _common.interaction, _common.animation, _common.limitInPlot)(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Column = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _percent = __webpack_require__(123);
var _adaptor = __webpack_require__(198);
var _constants = __webpack_require__(1200);
var Column = function (_super) {
  (0, _tslib.__extends)(Column, _super);
  function Column() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'column';
    return _this;
  }
    Column.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    Column.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
      yField = _a.yField,
      xField = _a.xField,
      isPercent = _a.isPercent;
    var _b = this,
      chart = _b.chart,
      options = _b.options;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    this.chart.changeData((0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent));
  };
    Column.prototype.getDefaultOptions = function () {
    return Column.getDefaultOptions();
  };
    Column.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Column;
}(_plot.Plot);
exports.Column = Column;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagFormatter = conversionTagFormatter;
var _util = __webpack_require__(0);
function conversionTagFormatter(prev, next) {
  if (!(0, _util.isNumber)(prev) || !(0, _util.isNumber)(next)) {
    return '-';
  }
  if (prev === next) {
    return '100%';
  }
  if (prev === 0) {
    return '∞';
  }
  if (next === 0) {
    return '-∞';
  }
  return (100 * next / prev).toFixed(2) + "%";
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brushInteraction = brushInteraction;
var _util = __webpack_require__(0);
var _brush = __webpack_require__(1198);
var _utils = __webpack_require__(7);

var BRUSH_TYPES = ['brush', 'brush-x', 'brush-y', 'brush-highlight', 'brush-x-highlight', 'brush-y-highlight'];
function brushInteraction(params) {
  var options = params.options;
  var brush = options.brush;
  
  var interactions = (0, _util.filter)(options.interactions || [], function (i) {
    return BRUSH_TYPES.indexOf(i.type) === -1;
  });
  
  if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
    BRUSH_TYPES.forEach(function (type) {
      var _a;
      var enable = false;
      switch (brush.type) {
        case 'x-rect':
          enable = type === (brush.action === 'highlight' ? 'brush-x-highlight' : 'brush-x');
          break;
        case 'y-rect':
          enable = type === (brush.action === 'highlight' ? 'brush-y-highlight' : 'brush-y');
          break;
        default:
          enable = type === (brush.action === 'highlight' ? 'brush-highlight' : 'brush');
          break;
      }
      var obj = {
        type: type,
        enable: enable
      };
      if (((_a = brush.mask) === null || _a === void 0 ? void 0 : _a.style) || brush.type) {
        obj.cfg = (0, _brush.getInteractionCfg)(type, brush.type, brush.mask);
      }
      interactions.push(obj);
    });
    
    if ((brush === null || brush === void 0 ? void 0 : brush.action) !== 'highlight') {
      interactions.push({
        type: 'filter-action',
        cfg: {
          buttonConfig: brush.button
        }
      });
    }
  }
  return (0, _utils.deepAssign)({}, params, {
    options: {
      interactions: interactions
    }
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bar = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _percent = __webpack_require__(123);
var _adaptor = __webpack_require__(554);
var _constants = __webpack_require__(1201);
var _utils = __webpack_require__(555);
var Bar = function (_super) {
  (0, _tslib.__extends)(Bar, _super);
  function Bar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'bar';
    return _this;
  }
    Bar.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    Bar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    var xField = options.xField,
      yField = options.yField,
      isPercent = options.isPercent;
    var switchedFieldOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
      xField: yField,
      yField: xField
    });
    (0, _adaptor.meta)({
      chart: chart,
      options: switchedFieldOptions
    });
    chart.changeData((0, _percent.getDataWhetherPecentage)((0, _utils.transformBarData)(data), xField, yField, xField, isPercent));
  };
    Bar.prototype.getDefaultOptions = function () {
    return Bar.getDefaultOptions();
  };
    Bar.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Bar;
}(_plot.Plot);
exports.Bar = Bar;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
Object.defineProperty(exports, "meta", {
  enumerable: true,
  get: function get() {
    return _adaptor.meta;
  }
});
var _tslib = __webpack_require__(1);
var _adaptor = __webpack_require__(198);
var _utils = __webpack_require__(555);
function adaptor(params) {
  var chart = params.chart,
    options = params.options;
  var xField = options.xField,
    yField = options.yField,
    xAxis = options.xAxis,
    yAxis = options.yAxis,
    barStyle = options.barStyle,
    barWidthRatio = options.barWidthRatio,
    label = options.label,
    data = options.data,
    seriesField = options.seriesField,
    isStack = options.isStack,
    minBarWidth = options.minBarWidth,
    maxBarWidth = options.maxBarWidth;
  
  if (label && !label.position) {
    label.position = 'left';
    
    if (!label.layout) {
      label.layout = [{
        type: 'interval-adjust-position'
      }, {
        type: 'interval-hide-overlap'
      }, {
        type: 'adjust-color'
      }, {
        type: 'limit-in-plot',
        cfg: {
          action: 'hide'
        }
      }];
    }
  }
  
  var legend = options.legend;
  if (seriesField) {
    if (legend !== false) {
      legend = (0, _tslib.__assign)({
        position: isStack ? 'top-left' : 'right-top',
        reversed: isStack ? false : true
      }, legend || {});
    }
  } else {
    legend = false;
  }
  
  params.options.legend = legend;
  
  var tooltip = options.tooltip;
  if (seriesField) {
    if (tooltip !== false) {
      tooltip = (0, _tslib.__assign)({
        reversed: isStack ? false : true
      }, tooltip || {});
    }
  }
  
  params.options.tooltip = tooltip;
  
  chart.coordinate().transpose();
  return (0, _adaptor.adaptor)({
    chart: chart,
    options: (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
      label: label,
      
      xField: yField,
      yField: xField,
      xAxis: yAxis,
      yAxis: xAxis,
      
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: options.barBackground,
      
      data: (0, _utils.transformBarData)(data)
    })
  }, true);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformBarData = transformBarData;
function transformBarData(data) {
  return data ? data.slice().reverse() : data;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pie = void 0;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var _adaptor = __webpack_require__(557);
var _contants = __webpack_require__(558);
var _utils2 = __webpack_require__(559);
__webpack_require__(560);
var Pie = function (_super) {
  (0, _tslib.__extends)(Pie, _super);
  function Pie() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'pie';
    return _this;
  }
    Pie.getDefaultOptions = function () {
    return _contants.DEFAULT_OPTIONS;
  };
    Pie.prototype.changeData = function (data) {
    this.chart.emit(_g.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _g.Event.fromData(this.chart, _g.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    var prevOptions = this.options;
    var angleField = this.options.angleField;
    var prevData = (0, _utils.processIllegalData)(prevOptions.data, angleField);
    var curData = (0, _utils.processIllegalData)(data, angleField);
    
    if ((0, _utils2.isAllZero)(prevData, angleField) || (0, _utils2.isAllZero)(curData, angleField)) {
      this.update({
        data: data
      });
    } else {
      this.updateOption({
        data: data
      });
      this.chart.data(curData);
      
      (0, _adaptor.pieAnnotation)({
        chart: this.chart,
        options: this.options
      });
      this.chart.render(true);
    }
    this.chart.emit(_g.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, _g.Event.fromData(this.chart, _g.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
    Pie.prototype.getDefaultOptions = function () {
    return Pie.getDefaultOptions();
  };
    Pie.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Pie;
}(_plot.Plot);
exports.Pie = Pie;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.interaction = interaction;
exports.pieAnnotation = pieAnnotation;
exports.transformStatisticOptions = transformStatisticOptions;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _common = __webpack_require__(22);
var _base = __webpack_require__(49);
var _geometries = __webpack_require__(30);
var _pattern = __webpack_require__(122);
var _locale = __webpack_require__(196);
var _utils = __webpack_require__(7);
var _contants = __webpack_require__(558);
var _utils2 = __webpack_require__(559);
var _interactions = __webpack_require__(560);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    angleField = options.angleField,
    colorField = options.colorField,
    color = options.color,
    pieStyle = options.pieStyle;
  
  var processData = (0, _utils.processIllegalData)(data, angleField);
  if ((0, _utils2.isAllZero)(processData, angleField)) {
    
    var percentageField_1 = '$$percentage$$';
    processData = processData.map(function (d) {
      var _a;
      return (0, _tslib.__assign)((0, _tslib.__assign)({}, d), (_a = {}, _a[percentageField_1] = 1 / processData.length, _a));
    });
    chart.data(processData);
    var p = (0, _utils.deepAssign)({}, params, {
      options: {
        xField: '1',
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    (0, _geometries.interval)(p);
  } else {
    chart.data(processData);
    var p = (0, _utils.deepAssign)({}, params, {
      options: {
        xField: '1',
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    (0, _geometries.interval)(p);
  }
  return params;
}
function meta(params) {
  var _a;
  var chart = params.chart,
    options = params.options;
  var meta = options.meta,
    colorField = options.colorField;
  
  var scales = (0, _utils.deepAssign)({}, meta);
  chart.scale(scales, (_a = {}, _a[colorField] = {
    type: 'cat'
  }, _a));
  return params;
}
function coordinate(params) {
  var chart = params.chart,
    options = params.options;
  var radius = options.radius,
    innerRadius = options.innerRadius,
    startAngle = options.startAngle,
    endAngle = options.endAngle;
  chart.coordinate({
    type: 'theta',
    cfg: {
      radius: radius,
      innerRadius: innerRadius,
      startAngle: startAngle,
      endAngle: endAngle
    }
  });
  return params;
}
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    colorField = options.colorField,
    angleField = options.angleField;
  var geometry = chart.geometries[0];
  
  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
      cfg = (0, _tslib.__rest)(label, ["callback"]);
    var labelCfg = (0, _utils.transformLabel)(cfg);
    
    if (labelCfg.content) {
      var content_1 = labelCfg.content;
      labelCfg.content = function (data, dataum, index) {
        var name = data[colorField];
        var value = data[angleField];
        
        var angleScale = chart.getScaleByField(angleField);
        var percent = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value);
        return (0, _util.isFunction)(content_1) ?
        
        content_1((0, _tslib.__assign)((0, _tslib.__assign)({}, data), {
          percent: percent
        }), dataum, index) : (0, _util.isString)(content_1) ? (0, _utils.template)(content_1, {
          value: value,
          name: name,
          
          percentage: (0, _util.isNumber)(percent) && !(0, _util.isNil)(value) ? (percent * 100).toFixed(2) + "%" : null
        }) : content_1;
      };
    }
    var LABEL_LAYOUT_TYPE_MAP = {
      inner: '',
      outer: 'pie-outer',
      spider: 'pie-spider'
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : 'pie-outer';
    var labelLayoutCfg = labelCfg.layout ? !(0, _util.isArray)(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{
      type: labelLayoutType
    }] : []).concat(labelLayoutCfg);
    geometry.label({
      
      fields: colorField ? [angleField, colorField] : [angleField],
      callback: callback,
      cfg: (0, _tslib.__assign)((0, _tslib.__assign)({}, labelCfg), {
        offset: (0, _utils2.adaptOffset)(labelCfg.type, labelCfg.offset),
        type: 'pie'
      })
    });
  }
  return params;
}
function transformStatisticOptions(options) {
  var innerRadius = options.innerRadius,
    statistic = options.statistic,
    angleField = options.angleField,
    colorField = options.colorField,
    meta = options.meta,
    locale = options.locale;
  var i18n = (0, _locale.getLocale)(locale);
  if (innerRadius && statistic) {
    var _a = (0, _utils.deepAssign)({}, _contants.DEFAULT_OPTIONS.statistic, statistic),
      titleOpt_1 = _a.title,
      contentOpt_1 = _a.content;
    if (titleOpt_1 !== false) {
      titleOpt_1 = (0, _utils.deepAssign)({}, {
        formatter: function formatter(datum) {
          
          if (datum) {
            return datum[colorField];
          }
          return !(0, _util.isNil)(titleOpt_1.content) ? titleOpt_1.content : i18n.get(['statistic', 'total']);
        }
      }, titleOpt_1);
    }
    if (contentOpt_1 !== false) {
      contentOpt_1 = (0, _utils.deepAssign)({}, {
        formatter: function formatter(datum, data) {
          var dataValue = datum ? datum[angleField] : (0, _utils2.getTotalValue)(data, angleField);
          var metaFormatter = (0, _util.get)(meta, [angleField, 'formatter']) || function (v) {
            return v;
          };
          
          if (datum) {
            return metaFormatter(dataValue);
          }
          return !(0, _util.isNil)(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
        }
      }, contentOpt_1);
    }
    return (0, _utils.deepAssign)({}, {
      statistic: {
        title: titleOpt_1,
        content: contentOpt_1
      }
    }, options);
  }
  return options;
}
function pieAnnotation(params) {
  var chart = params.chart,
    options = params.options;
  var _a = transformStatisticOptions(options),
    innerRadius = _a.innerRadius,
    statistic = _a.statistic;
  
  chart.getController('annotation').clear(true);
  
  (0, _utils.flow)((0, _common.annotation)())(params);
    if (innerRadius && statistic) {
    (0, _utils.renderStatistic)(chart, {
      statistic: statistic,
      plotType: 'pie'
    });
  }
  return params;
}
function tooltip(params) {
  var chart = params.chart,
    options = params.options;
  var tooltip = options.tooltip,
    colorField = options.colorField,
    angleField = options.angleField,
    data = options.data;
  if (tooltip === false) {
    chart.tooltip(tooltip);
  } else {
    chart.tooltip((0, _utils.deepAssign)({}, tooltip, {
      shared: false
    }));
    
    if ((0, _utils2.isAllZero)(data, angleField)) {
      var fields = (0, _util.get)(tooltip, 'fields');
      var formatter = (0, _util.get)(tooltip, 'formatter');
      if ((0, _util.isEmpty)((0, _util.get)(tooltip, 'fields'))) {
        fields = [colorField, angleField];
        formatter = formatter || function (datum) {
          return {
            name: datum[colorField],
            value: (0, _util.toString)(datum[angleField])
          };
        };
      }
      chart.geometries[0].tooltip(fields.join('*'), (0, _base.getMappingFunction)(fields, formatter));
    }
  }
  return params;
}
function interaction(params) {
  var chart = params.chart,
    options = params.options;
  var _a = transformStatisticOptions(options),
    interactions = _a.interactions,
    statistic = _a.statistic,
    annotations = _a.annotations;
  (0, _util.each)(interactions, function (i) {
    var _a, _b;
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else if (i.type === 'pie-statistic-active') {
      
      var startStages_1 = [];
      if (!((_a = i.cfg) === null || _a === void 0 ? void 0 : _a.start)) {
        startStages_1 = [{
          trigger: 'element:mouseenter',
          action: _interactions.PIE_STATISTIC + ":change",
          arg: {
            statistic: statistic,
            annotations: annotations
          }
        }];
      }
      (0, _util.each)((_b = i.cfg) === null || _b === void 0 ? void 0 : _b.start, function (stage) {
        startStages_1.push((0, _tslib.__assign)((0, _tslib.__assign)({}, stage), {
          arg: {
            statistic: statistic,
            annotations: annotations
          }
        }));
      });
      chart.interaction(i.type, (0, _utils.deepAssign)({}, i.cfg, {
        start: startStages_1
      }));
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function adaptor(params) {
  
  return (0, _utils.flow)((0, _pattern.pattern)('pieStyle'), geometry, meta, _common.theme, coordinate, _common.legend, tooltip, label, _common.state,   pieAnnotation, interaction, _common.animation)(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  legend: {
    position: 'right'
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: {
      type: 'limit-in-plot',
      cfg: {
        action: 'ellipsis'
      }
    }
  },
    pieStyle: {
    stroke: 'white',
    lineWidth: 1
  },
    statistic: {
    title: {
      style: {
        fontWeight: 300,
        color: '#4B535E',
        textAlign: 'center',
        fontSize: '20px',
        lineHeight: 1
      }
    },
    content: {
      style: {
        fontWeight: 'bold',
        color: 'rgba(44,53,66,0.85)',
        textAlign: 'center',
        fontSize: '32px',
        lineHeight: 1
      }
    }
  },
    theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptOffset = adaptOffset;
exports.getTotalValue = getTotalValue;
exports.isAllZero = isAllZero;
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
function getTotalValue(data, field) {
  var total = null;
  (0, _util.each)(data, function (item) {
    if (typeof item[field] === 'number') {
      total += item[field];
    }
  });
  return total;
}
function adaptOffset(type, offset) {
  var defaultOffset;
  switch (type) {
    case 'inner':
      defaultOffset = '-30%';
      if ((0, _util.isString)(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }
      return offset < 0 ? offset : defaultOffset;
    case 'outer':
      defaultOffset = 12;
      if ((0, _util.isString)(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }
      return offset > 0 ? offset : defaultOffset;
    default:
      return offset;
  }
}
function isAllZero(data, angleField) {
  return (0, _util.every)((0, _utils.processIllegalData)(data, angleField), function (d) {
    return d[angleField] === 0;
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PIE_STATISTIC = void 0;
var _g = __webpack_require__(14);
var _legendActive = __webpack_require__(1202);
var _statisticActive = __webpack_require__(1203);
var PIE_STATISTIC = 'pie-statistic';
exports.PIE_STATISTIC = PIE_STATISTIC;
(0, _g.registerAction)(PIE_STATISTIC, _statisticActive.StatisticAction);
(0, _g.registerInteraction)('pie-statistic-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'pie-statistic:change'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'pie-statistic:reset'
  }]
});
(0, _g.registerAction)('pie-legend', _legendActive.PieLegendAction);
(0, _g.registerInteraction)('pie-legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: 'pie-legend:active'
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: 'pie-legend:reset'
  }]
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = transform;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function transform(actions, matrix) {
  var ulMatrix = matrix ? (0, _tslib.__spreadArrays)(matrix) : (0, _tslib.__spreadArrays)(ORIGIN_MATRIX);
  return _g.Util.transform(ulMatrix, actions);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFontSizeMapping = getFontSizeMapping;
exports.getSingleKeyValues = getSingleKeyValues;
exports.getSize = getSize;
exports.processImageMask = processImageMask;
exports.transform = transform;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _padding = __webpack_require__(121);
var _utils = __webpack_require__(7);
var _wordCloud = __webpack_require__(1210);
function transform(params) {
  var rawOptions = params.options,
    chart = params.chart;
  var _a = chart,
    width = _a.width,
    height = _a.height,
    chartPadding = _a.padding,
    appendPadding = _a.appendPadding,
    ele = _a.ele;
  var data = rawOptions.data,
    imageMask = rawOptions.imageMask,
    wordField = rawOptions.wordField,
    weightField = rawOptions.weightField,
    colorField = rawOptions.colorField,
    wordStyle = rawOptions.wordStyle,
    timeInterval = rawOptions.timeInterval,
    random = rawOptions.random,
    spiral = rawOptions.spiral,
    _b = rawOptions.autoFit,
    autoFit = _b === void 0 ? true : _b,
    placementStrategy = rawOptions.placementStrategy;
  if (!data || !data.length) {
    return [];
  }
  var fontFamily = wordStyle.fontFamily,
    fontWeight = wordStyle.fontWeight,
    padding = wordStyle.padding,
    fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data, weightField);
  var range = [min(arr), max(arr)];
  
  var words = data.map(function (datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum: datum
    };
  });
  var options = {
    imageMask: imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range),
    fontWeight: fontWeight,
    
    size: getSize({
      width: width,
      height: height,
      padding: chartPadding,
      appendPadding: appendPadding,
      autoFit: autoFit,
      container: ele
    }),
    padding: padding,
    timeInterval: timeInterval,
    random: random,
    spiral: spiral,
    rotate: getRotate(rawOptions)
  };
  
  if ((0, _util.isFunction)(placementStrategy)) {
    var result = words.map(function (word, index, words) {
      return (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, word), {
        hasText: !!word.text,
        font: (0, _wordCloud.functor)(options.font)(word, index, words),
        weight: (0, _wordCloud.functor)(options.fontWeight)(word, index, words),
        rotate: (0, _wordCloud.functor)(options.rotate)(word, index, words),
        size: (0, _wordCloud.functor)(options.fontSize)(word, index, words),
        style: 'normal'
      }), placementStrategy.call(chart, word, index, words));
    });
    
    result.push({
      text: '',
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: '',
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  }
  // 数据准备在外部做，wordCloud 单纯就是做布局
  return (0, _wordCloud.wordCloud)(words, options);
}
/**
 * 获取最终的实际绘图尺寸：[width, height]
 * @param chart
 */
function getSize(options) {
  var width = options.width,
    height = options.height;
  var container = options.container,
    autoFit = options.autoFit,
    padding = options.padding,
    appendPadding = options.appendPadding;
  // 由于词云图每个词语的坐标都是先通过 DataSet 根据图表宽高计算出来的，
  // 也就是说，如果一开始提供给 DataSet 的宽高信息和最终显示的宽高不相同，
  // 那么就会出现布局错乱的情况，所以这里处理的目的就是让一开始提供给 DataSet 的
  // 宽高信息与最终显示的宽高信息相同，避免显示错乱。
  if (autoFit) {
    var containerSize = (0, _utils.getContainerSize)(container);
    width = containerSize.width;
    height = containerSize.height;
  }
  // 宽高不能为 0，否则会造成死循环
  width = width || 400;
  height = height || 400;
  var _a = resolvePadding({
      padding: padding,
      appendPadding: appendPadding
    }),
    top = _a[0],
    right = _a[1],
    bottom = _a[2],
    left = _a[3];
  var result = [width - (left + right), height - (top + bottom)];
  return result;
}
/**
 * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding
 * @param chart
 */
function resolvePadding(options) {
  var padding = (0, _padding.normalPadding)(options.padding);
  var appendPadding = (0, _padding.normalPadding)(options.appendPadding);
  var top = padding[0] + appendPadding[0];
  var right = padding[1] + appendPadding[1];
  var bottom = padding[2] + appendPadding[2];
  var left = padding[3] + appendPadding[3];
  return [top, right, bottom, left];
}
/**
 * 处理 imageMask 可能为 url 字符串的情况
 * @param  {HTMLImageElement | string} img
 * @return {Promise}
 */
function processImageMask(img) {
  return new Promise(function (res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if ((0, _util.isString)(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = 'anonymous';
      image_1.src = img;
      image_1.onload = function () {
        res(image_1);
      };
      image_1.onerror = function () {
        (0, _utils.log)(_utils.LEVEL.ERROR, false, 'image %s load failed !!!', img);
        rej();
      };
      return;
    }
    (0, _utils.log)(_utils.LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');
    rej();
  });
}
function getFontSizeMapping(fontSize, range) {
  if ((0, _util.isFunction)(fontSize)) {
    return fontSize;
  }
  if ((0, _util.isArray)(fontSize)) {
    var fMin_1 = fontSize[0],
      fMax_1 = fontSize[1];
    if (!range) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    var min_1 = range[0],
      max_1 = range[1];
    if (max_1 === min_1) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    return function fontSize(_a) {
      var value = _a.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value - min_1) + fMin_1;
    };
  }
  return function () {
    return fontSize;
  };
}
function getSingleKeyValues(data, key) {
  return data.map(function (v) {
    return v[key];
  }).filter(function (v) {
    
    if (typeof v === 'number' && !isNaN(v)) return true;
    return false;
  });
}
function getRotate(options) {
  var _a = resolveRotate(options),
    rotation = _a.rotation,
    rotationSteps = _a.rotationSteps;
  if (!(0, _util.isArray)(rotation)) return rotation;
  var min = rotation[0];
  var max = rotation[1];
  
  var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);
  return function rotate() {
    if (max === min) return max;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;
  if (rotationSteps < 1) {
    (0, _utils.log)(_utils.LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');
    rotationSteps = 1;
  }
  return {
    rotation: options.wordStyle.rotation,
    rotationSteps: rotationSteps
  };
}
function min(numbers) {
  return Math.min.apply(Math, numbers);
}
function max(numbers) {
  return Math.max.apply(Math, numbers);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WORD_CLOUD_COLOR_FIELD = exports.DEFAULT_OPTIONS = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var WORD_CLOUD_COLOR_FIELD = 'color';
exports.WORD_CLOUD_COLOR_FIELD = WORD_CLOUD_COLOR_FIELD;
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  timeInterval: 2000,
  legend: false,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: false,
    fields: ['text', 'value', WORD_CLOUD_COLOR_FIELD],
    formatter: function formatter(datum) {
      return {
        name: datum.text,
        value: datum.value
      };
    }
  },
  wordStyle: {
    fontFamily: 'Verdana',
    fontWeight: 'normal',
    padding: 1,
    fontSize: [12, 60],
    rotation: [0, 90],
    rotationSteps: 2,
    rotateRatio: 0.5
  }
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scatter = void 0;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var _adaptor = __webpack_require__(565);
var _constant = __webpack_require__(1213);
__webpack_require__(1214);
var Scatter = function (_super) {
  (0, _tslib.__extends)(Scatter, _super);
  function Scatter(container, options) {
    var _this = _super.call(this, container, options) || this;
        _this.type = 'scatter';
    
    _this.on(_g.VIEW_LIFE_CIRCLE.BEFORE_RENDER, function (evt) {
      var _a, _b;
      
      var _c = _this,
        options = _c.options,
        chart = _c.chart;
      if (((_a = evt.data) === null || _a === void 0 ? void 0 : _a.source) === _g.BRUSH_FILTER_EVENTS.FILTER) {
        var filteredData = _this.chart.filterData(_this.chart.getData());
        (0, _adaptor.meta)({
          chart: chart,
          options: (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
            data: filteredData
          })
        });
      }
      if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === _g.BRUSH_FILTER_EVENTS.RESET) {
        (0, _adaptor.meta)({
          chart: chart,
          options: options
        });
      }
    });
    return _this;
  }
    Scatter.getDefaultOptions = function () {
    return _constant.DEFAULT_OPTIONS;
  };
    Scatter.prototype.changeData = function (data) {
    this.updateOption((0, _adaptor.transformOptions)((0, _utils.deepAssign)({}, this.options, {
      data: data
    })));
    var _a = this,
      options = _a.options,
      chart = _a.chart;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    this.chart.changeData(data);
  };
    Scatter.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  Scatter.prototype.getDefaultOptions = function () {
    return Scatter.getDefaultOptions();
  };
  return Scatter;
}(_plot.Plot);
exports.Scatter = Scatter;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.meta = meta;
exports.tooltip = tooltip;
exports.transformOptions = transformOptions;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
var _geometries = __webpack_require__(30);
var _brush = __webpack_require__(552);
var _common = __webpack_require__(22);
var _util2 = __webpack_require__(1212);
function transformOptions(options) {
  var _a = options.data,
    data = _a === void 0 ? [] : _a,
    xField = options.xField,
    yField = options.yField;
  if (data.length) {
    
    var isOneX = true;
    var isOneY = true;
    var prev = data[0];
    var curr = void 0;
    for (var i = 1; i < data.length; i++) {
      curr = data[i];
      if (prev[xField] !== curr[xField]) {
        isOneX = false;
      }
      if (prev[yField] !== curr[yField]) {
        isOneY = false;
      }
      
      if (!isOneX && !isOneY) {
        break;
      }
      prev = curr;
    }
    var keys = [];
    isOneX && keys.push(xField);
    isOneY && keys.push(yField);
    var meta_1 = (0, _utils.pick)((0, _util2.getMeta)(options), keys);
    return (0, _utils.deepAssign)({}, options, {
      meta: meta_1
    });
  }
  return options;
}
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    type = options.type,
    color = options.color,
    shape = options.shape,
    pointStyle = options.pointStyle,
    shapeField = options.shapeField,
    colorField = options.colorField,
    xField = options.xField,
    yField = options.yField,
    sizeField = options.sizeField;
  var size = options.size;
  var tooltip = options.tooltip;
  if (sizeField) {
    if (!size) {
      size = [2, 8];
    }
    if ((0, _util.isNumber)(size)) {
      size = [size, size];
    }
  }
  if (tooltip && !tooltip.fields) {
    tooltip = (0, _tslib.__assign)((0, _tslib.__assign)({}, tooltip), {
      fields: [xField, yField, colorField, sizeField, shapeField]
    });
  }
  
  chart.data(data);
  
  (0, _geometries.point)((0, _utils.deepAssign)({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color,
        shape: shape,
        size: size,
        style: pointStyle
      },
      tooltip: tooltip
    }
  }));
  var geometry = (0, _utils.findGeometry)(chart, 'point');
  
  if (type) {
    geometry.adjust(type);
  }
  return params;
}
function meta(params) {
  var _a;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField;
  var newOptions = transformOptions(options);
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))((0, _utils.deepAssign)({}, params, {
    options: newOptions
  }));
}
function axis(params) {
  var chart = params.chart,
    options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis,
    xField = options.xField,
    yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function legend(params) {
  var chart = params.chart,
    options = params.options;
  var legend = options.legend,
    colorField = options.colorField,
    shapeField = options.shapeField,
    sizeField = options.sizeField,
    shapeLegend = options.shapeLegend,
    sizeLegend = options.sizeLegend;
    var showLegend = legend !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend : false);
  }
  
  if (shapeField) {
    if (shapeLegend) {
      chart.legend(shapeField, shapeLegend);
    } else {
      chart.legend(shapeField, shapeLegend === false ? false : legend);
    }
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend ? sizeLegend : false);
  }
      if (!showLegend && !shapeLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label,
    yField = options.yField;
  var scatterGeometry = (0, _utils.findGeometry)(chart, 'point');
  
  if (!label) {
    scatterGeometry.label(false);
  } else {
    var callback = label.callback,
      cfg = (0, _tslib.__rest)(label, ["callback"]);
    scatterGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }
  return params;
}
function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];
  if (quadrant) {
    var _a = quadrant.xBaseline,
      xBaseline = _a === void 0 ? 0 : _a,
      _b = quadrant.yBaseline,
      yBaseline = _b === void 0 ? 0 : _b,
      labels_1 = quadrant.labels,
      regionStyle_1 = quadrant.regionStyle,
      lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = (0, _util2.getQuadrantDefaultConfig)(xBaseline, yBaseline);
    
    var quadrants = new Array(4).join(',').split(',');
    quadrants.forEach(function (_, index) {
      annotationOptions.push((0, _tslib.__assign)((0, _tslib.__assign)({
        type: 'region',
        top: false
      }, defaultConfig_1.regionStyle[index].position), {
        style: (0, _utils.deepAssign)({}, defaultConfig_1.regionStyle[index].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index])
      }), (0, _tslib.__assign)({
        type: 'text',
        top: true
      }, (0, _utils.deepAssign)({}, defaultConfig_1.labelStyle[index], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index])));
    });
    
    annotationOptions.push({
      type: 'line',
      top: false,
      start: ['min', yBaseline],
      end: ['max', yBaseline],
      style: (0, _utils.deepAssign)({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: 'line',
      top: false,
      start: [xBaseline, 'min'],
      end: [xBaseline, 'max'],
      style: (0, _utils.deepAssign)({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }
  return (0, _utils.flow)((0, _common.annotation)(annotationOptions))(params);
}

function regressionLine(params) {
  var options = params.options,
    chart = params.chart;
  var regressionLine = options.regressionLine;
  if (regressionLine) {
    var style_1 = regressionLine.style,
      _a = regressionLine.top,
      top_1 = _a === void 0 ? false : _a;
    var defaultStyle_1 = {
      stroke: '#9ba29a',
      lineWidth: 2,
      opacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function render(container, view) {
        var group = container.addGroup({
          id: chart.id + "-regression-line",
          name: 'regression-line-group'
        });
        var path = (0, _util2.getPath)({
          view: view,
          options: options
        });
        group.addShape('path', {
          name: 'regression-line',
          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({
            path: path
          }, defaultStyle_1), style_1)
        });
      }
    });
  }
  return params;
}
function tooltip(params) {
  var chart = params.chart,
    options = params.options;
  var tooltip = options.tooltip;
  if (tooltip) {
    chart.tooltip(tooltip);
  } else if (tooltip === false) {
    chart.tooltip(false);
  }
  return params;
}
function adaptor(params) {
  
  return (0, _utils.flow)(geometry, meta, axis, legend, tooltip, label,
  
  _brush.brushInteraction, _common.interaction, scatterAnnotation, _common.animation, _common.theme, regressionLine)(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(14);
(0, _g.registerInteraction)('drag-move', {
  start: [{
    trigger: 'plot:mousedown',
    action: 'scale-translate:start'
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: 'scale-translate:translate',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: 'scale-translate:end'
  }]
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DualAxesGeometry = exports.AxisType = void 0;
var AxisType;
exports.AxisType = AxisType;
(function (AxisType) {
  AxisType["Left"] = "Left";
  AxisType["Right"] = "Right";
})(AxisType || (exports.AxisType = AxisType = {}));
var DualAxesGeometry;
exports.DualAxesGeometry = DualAxesGeometry;
(function (DualAxesGeometry) {
  DualAxesGeometry["Line"] = "line";
  DualAxesGeometry["Column"] = "column";
})(DualAxesGeometry || (exports.DualAxesGeometry = DualAxesGeometry = {}));

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RIGHT_AXES_VIEW = exports.LEFT_AXES_VIEW = exports.DEFAULT_YAXIS_CONFIG = exports.DEFAULT_RIGHT_YAXIS_CONFIG = exports.DEFAULT_LEFT_YAXIS_CONFIG = void 0;
var _tslib = __webpack_require__(1);
var LEFT_AXES_VIEW = 'left-axes-view';
exports.LEFT_AXES_VIEW = LEFT_AXES_VIEW;
var RIGHT_AXES_VIEW = 'right-axes-view';
exports.RIGHT_AXES_VIEW = RIGHT_AXES_VIEW;
var DEFAULT_YAXIS_CONFIG = {
  nice: true,
  label: {
    autoHide: true,
    autoRotate: false
  }
};
exports.DEFAULT_YAXIS_CONFIG = DEFAULT_YAXIS_CONFIG;
var DEFAULT_LEFT_YAXIS_CONFIG = (0, _tslib.__assign)((0, _tslib.__assign)({}, DEFAULT_YAXIS_CONFIG), {
  position: 'left'
});
exports.DEFAULT_LEFT_YAXIS_CONFIG = DEFAULT_LEFT_YAXIS_CONFIG;
var DEFAULT_RIGHT_YAXIS_CONFIG = (0, _tslib.__assign)((0, _tslib.__assign)({}, DEFAULT_YAXIS_CONFIG), {
  position: 'right',
  grid: null
});
exports.DEFAULT_RIGHT_YAXIS_CONFIG = DEFAULT_RIGHT_YAXIS_CONFIG;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyLine = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _adaptor = __webpack_require__(570);
var _constants = __webpack_require__(156);
var _utils = __webpack_require__(124);
var TinyLine = function (_super) {
  (0, _tslib.__extends)(TinyLine, _super);
  function TinyLine() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'tiny-line';
    return _this;
  }
    TinyLine.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    TinyLine.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    chart.changeData((0, _utils.getTinyData)(data));
  };
  TinyLine.prototype.getDefaultOptions = function () {
    return TinyLine.getDefaultOptions();
  };
    TinyLine.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return TinyLine;
}(_plot.Plot);
exports.TinyLine = TinyLine;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
Object.defineProperty(exports, "meta", {
  enumerable: true,
  get: function get() {
    return _adaptor.meta;
  }
});
var _utils = __webpack_require__(7);
var _common = __webpack_require__(22);
var _geometries = __webpack_require__(30);
var _adaptor = __webpack_require__(199);
var _utils2 = __webpack_require__(124);
var _constants = __webpack_require__(156);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    color = options.color,
    lineStyle = options.lineStyle,
    pointMapping = options.point;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var seriesData = (0, _utils2.getTinyData)(data);
  chart.data(seriesData);
  
  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constants.X_FIELD,
      yField: _constants.Y_FIELD,
      line: {
        color: color,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var pointParams = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false,
      state: pointState
    }
  });
  (0, _geometries.line)(primary);
  (0, _geometries.point)(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function adaptor(params) {
  return (0, _utils.flow)(geometry, _adaptor.meta, _common.theme, _common.tooltip, _common.animation, (0, _common.annotation)())(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyColumn = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(124);
var _adaptor = __webpack_require__(572);
var _constants = __webpack_require__(1224);
var TinyColumn = function (_super) {
  (0, _tslib.__extends)(TinyColumn, _super);
  function TinyColumn() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'tiny-column';
    return _this;
  }
    TinyColumn.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    TinyColumn.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    chart.changeData((0, _utils.getTinyData)(data));
  };
  TinyColumn.prototype.getDefaultOptions = function () {
    return TinyColumn.getDefaultOptions();
  };
    TinyColumn.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return TinyColumn;
}(_plot.Plot);
exports.TinyColumn = TinyColumn;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
Object.defineProperty(exports, "meta", {
  enumerable: true,
  get: function get() {
    return _adaptor.meta;
  }
});
var _common = __webpack_require__(22);
var _utils = __webpack_require__(7);
var _geometries = __webpack_require__(30);
var _constants = __webpack_require__(156);
var _utils2 = __webpack_require__(124);
var _adaptor = __webpack_require__(199);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    color = options.color,
    columnStyle = options.columnStyle,
    columnWidthRatio = options.columnWidthRatio;
  var seriesData = (0, _utils2.getTinyData)(data);
  chart.data(seriesData);
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constants.X_FIELD,
      yField: _constants.Y_FIELD,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color
      }
    }
  });
  (0, _geometries.interval)(p);
  chart.axis(false);
  chart.legend(false);
  chart.interaction('element-active');
  return params;
}
function adaptor(params) {
  return (0, _utils.flow)(_common.theme, (0, _common.pattern)('columnStyle'), geometry, _adaptor.meta, _common.tooltip, _common.animation, (0, _common.annotation)())(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyArea = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(124);
var _adaptor = __webpack_require__(199);
var _constants = __webpack_require__(1225);
var TinyArea = function (_super) {
  (0, _tslib.__extends)(TinyArea, _super);
  function TinyArea() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'tiny-area';
    return _this;
  }
    TinyArea.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    TinyArea.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this,
      chart = _a.chart,
      options = _a.options;
    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    chart.changeData((0, _utils.getTinyData)(data));
  };
  TinyArea.prototype.getDefaultOptions = function () {
    return TinyArea.getDefaultOptions();
  };
    TinyArea.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return TinyArea;
}(_plot.Plot);
exports.TinyArea = TinyArea;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Histogram = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _histogram = __webpack_require__(575);
var _adaptor = __webpack_require__(576);
var _constant = __webpack_require__(577);
var Histogram = function (_super) {
  (0, _tslib.__extends)(Histogram, _super);
  function Histogram() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'histogram';
    return _this;
  }
    Histogram.getDefaultOptions = function () {
    return _constant.DEFAULT_OPTIONS;
  };
  Histogram.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
      binField = _a.binField,
      binNumber = _a.binNumber,
      binWidth = _a.binWidth,
      stackField = _a.stackField;
    this.chart.changeData((0, _histogram.binHistogram)(data, binField, binWidth, binNumber, stackField));
  };
    Histogram.prototype.getDefaultOptions = function () {
    return Histogram.getDefaultOptions();
  };
    Histogram.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Histogram;
}(_plot.Plot);
exports.Histogram = Histogram;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binHistogram = binHistogram;
var _util = __webpack_require__(0);

function getBinKey(value, binWidth, binNumber) {
  
  if (binNumber === 1) {
    return [0, binWidth];
  }
  var index = Math.floor(value / binWidth);
  return [binWidth * index, binWidth * (index + 1)];
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
function binHistogram(data, binField, binWidth, binNumber, stackField) {
  var originData_copy = (0, _util.clone)(data);
  
  (0, _util.sortBy)(originData_copy, binField);
  
  var values = (0, _util.valuesOfKey)(originData_copy, binField);
  var range = (0, _util.getRange)(values);
  var rangeWidth = range.max - range.min;
  
  var _binWidth = binWidth;
  if (!binWidth && binNumber) {
    _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range.max;
  }
  
  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values);
    _binWidth = rangeWidth / _defaultBinNumber;
  }
  
  var bins = {};
  var groups = (0, _util.groupBy)(originData_copy, stackField);
  
  if ((0, _util.isEmpty)(groups)) {
    (0, _util.each)(originData_copy, function (data) {
      var value = data[binField];
      var bin = getBinKey(value, _binWidth, binNumber);
      var binKey = bin[0] + "-" + bin[1];
      if (!(0, _util.hasKey)(bins, binKey)) {
        bins[binKey] = {
          range: bin,
          count: 0
        };
      }
      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function (groupKey) {
      (0, _util.each)(groups[groupKey], function (data) {
        var value = data[binField];
        var bin = getBinKey(value, _binWidth, binNumber);
        var binKey = bin[0] + "-" + bin[1];
        var groupKeyBinKey = binKey + "-" + groupKey;
        if (!(0, _util.hasKey)(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = {
            range: bin,
            count: 0
          };
          bins[groupKeyBinKey][stackField] = groupKey;
        }
        bins[groupKeyBinKey].count += 1;
      });
    });
  }
  
  var plotData = [];
  (0, _util.each)(bins, function (bin) {
    plotData.push(bin);
  });
  return plotData;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
var _tslib = __webpack_require__(1);
var _common = __webpack_require__(22);
var _pattern = __webpack_require__(122);
var _utils = __webpack_require__(7);
var _geometries = __webpack_require__(30);
var _histogram = __webpack_require__(575);
var _constant = __webpack_require__(577);
function geometry(params) {
  var chart = params.chart,
    options = params.options;
  var data = options.data,
    binField = options.binField,
    binNumber = options.binNumber,
    binWidth = options.binWidth,
    color = options.color,
    stackField = options.stackField,
    legend = options.legend,
    columnStyle = options.columnStyle;
  
  var plotData = (0, _histogram.binHistogram)(data, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constant.HISTOGRAM_X_FIELD,
      yField: _constant.HISTOGRAM_Y_FIELD,
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color,
        style: columnStyle
      }
    }
  });
  (0, _geometries.interval)(p);
  
  if (legend && stackField) {
    chart.legend(stackField, legend);
  }
  return params;
}
function meta(params) {
  var _a;
  var options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[_constant.HISTOGRAM_X_FIELD] = xAxis, _a[_constant.HISTOGRAM_Y_FIELD] = yAxis, _a)))(params);
}
function axis(params) {
  var chart = params.chart,
    options = params.options;
  var xAxis = options.xAxis,
    yAxis = options.yAxis;
  
  if (xAxis === false) {
    chart.axis(_constant.HISTOGRAM_X_FIELD, false);
  } else {
    chart.axis(_constant.HISTOGRAM_X_FIELD, xAxis);
  }
  if (yAxis === false) {
    chart.axis(_constant.HISTOGRAM_Y_FIELD, false);
  } else {
    chart.axis(_constant.HISTOGRAM_Y_FIELD, yAxis);
  }
  return params;
}
function label(params) {
  var chart = params.chart,
    options = params.options;
  var label = options.label;
  var geometry = (0, _utils.findGeometry)(chart, 'interval');
  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
      cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: [_constant.HISTOGRAM_Y_FIELD],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }
  return params;
}
function adaptor(params) {
  
  return (0, _utils.flow)(_common.theme, (0, _pattern.pattern)('columnStyle'), geometry, meta, axis, _common.state, label, _common.tooltip, _common.interaction, _common.animation)(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HISTOGRAM_Y_FIELD = exports.HISTOGRAM_X_FIELD = exports.DEFAULT_OPTIONS = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var HISTOGRAM_X_FIELD = 'range';
exports.HISTOGRAM_X_FIELD = HISTOGRAM_X_FIELD;
var HISTOGRAM_Y_FIELD = 'count';
exports.HISTOGRAM_Y_FIELD = HISTOGRAM_Y_FIELD;
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  columnStyle: {
    stroke: '#FFFFFF'
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{
    type: 'active-region'
  }]
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Progress = void 0;
var _tslib = __webpack_require__(1);
var _plot = __webpack_require__(19);
var _adaptor = __webpack_require__(306);
var _constants = __webpack_require__(579);
var _utils = __webpack_require__(307);
var Progress = function (_super) {
  (0, _tslib.__extends)(Progress, _super);
  function Progress() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'process';
    return _this;
  }
    Progress.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    Progress.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.changeData((0, _utils.getProgressData)(percent));
  };
  Progress.prototype.getDefaultOptions = function () {
    return Progress.getDefaultOptions();
  };
    Progress.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return Progress;
}(_plot.Plot);
exports.Progress = Progress;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = exports.DEFAULT_COLOR = void 0;
var DEFAULT_COLOR = ['#FAAD14', '#E8EDF3'];
exports.DEFAULT_COLOR = DEFAULT_COLOR;
var DEFAULT_OPTIONS = {
  percent: 0.2,
  color: DEFAULT_COLOR,
  animation: {}
};
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingProgress = void 0;
var _tslib = __webpack_require__(1);
var _g = __webpack_require__(14);
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(307);
var _adaptor = __webpack_require__(581);
var _constants = __webpack_require__(1226);
var RingProgress = function (_super) {
  (0, _tslib.__extends)(RingProgress, _super);
  function RingProgress() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'ring-process';
    return _this;
  }
    RingProgress.getDefaultOptions = function () {
    return _constants.DEFAULT_OPTIONS;
  };
    RingProgress.prototype.changeData = function (percent) {
    this.chart.emit(_g.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _g.Event.fromData(this.chart, _g.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({
      percent: percent
    });
    this.chart.data((0, _utils.getProgressData)(percent));
    
    (0, _adaptor.statistic)({
      chart: this.chart,
      options: this.options
    }, true);
    this.chart.emit(_g.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, _g.Event.fromData(this.chart, _g.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  RingProgress.prototype.getDefaultOptions = function () {
    return RingProgress.getDefaultOptions();
  };
    RingProgress.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  return RingProgress;
}(_plot.Plot);
exports.RingProgress = RingProgress;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.statistic = statistic;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _utils = __webpack_require__(7);
var _common = __webpack_require__(22);
var _adaptor = __webpack_require__(306);
function coordinate(params) {
  var chart = params.chart,
    options = params.options;
  var innerRadius = options.innerRadius,
    radius = options.radius;
  
  chart.coordinate('theta', {
    innerRadius: innerRadius,
    radius: radius
  });
  return params;
}
function statistic(params, updated) {
  var chart = params.chart,
    options = params.options;
  var innerRadius = options.innerRadius,
    statistic = options.statistic,
    percent = options.percent,
    meta = options.meta;
  
  chart.getController('annotation').clear(true);
    if (innerRadius && statistic) {
    var metaFormatter = (0, _util.get)(meta, ['percent', 'formatter']) || function (v) {
      return (v * 100).toFixed(2) + "%";
    };
    var contentOpt = statistic.content;
    if (contentOpt) {
      contentOpt = (0, _utils.deepAssign)({}, contentOpt, {
        content: !(0, _util.isNil)(contentOpt.content) ? contentOpt.content : metaFormatter(percent)
      });
    }
    (0, _utils.renderStatistic)(chart, {
      statistic: (0, _tslib.__assign)((0, _tslib.__assign)({}, statistic), {
        content: contentOpt
      }),
      plotType: 'ring-progress'
    }, {
      percent: percent
    });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor(params) {
  return (0, _utils.flow)(_adaptor.geometry, (0, _common.scale)({}), coordinate, statistic, _common.animation, _common.theme, (0, _common.annotation)())(params);
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = void 0;
var _util = __webpack_require__(0);
var _constant = __webpack_require__(308);
var transformData = function transformData(data, yField) {
  var newData = data;
  
  if (Array.isArray(yField)) {
    var low_1 = yField[0],
      q1_1 = yField[1],
      median_1 = yField[2],
      q3_1 = yField[3],
      high_1 = yField[4];
    newData = (0, _util.map)(data, function (obj) {
      obj[_constant.BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
      return obj;
    });
  }
  return newData;
};
exports.transformData = transformData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformViolinData = exports.toViolinValue = exports.toBoxValue = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _pdfast = _interopRequireDefault(__webpack_require__(1236));
var _quantile = __webpack_require__(1238);
var toBoxValue = function toBoxValue(values) {
  return {
    low: (0, _util.min)(values),
    high: (0, _util.max)(values),
    q1: (0, _quantile.quantile)(values, 0.25),
    q3: (0, _quantile.quantile)(values, 0.75),
    median: (0, _quantile.quantile)(values, [0.5]),
    minMax: [(0, _util.min)(values), (0, _util.max)(values)],
    quantile: [(0, _quantile.quantile)(values, 0.25), (0, _quantile.quantile)(values, 0.75)]
  };
};
exports.toBoxValue = toBoxValue;
var toViolinValue = function toViolinValue(values, pdfOptions) {
  var pdfResults = _pdfast.default.create(values, pdfOptions);
  return {
    violinSize: pdfResults.map(function (result) {
      return result.y;
    }),
    violinY: pdfResults.map(function (result) {
      return result.x;
    })
  };
};
exports.toViolinValue = toViolinValue;
var transformViolinData = function transformViolinData(options) {
  var xField = options.xField,
    yField = options.yField,
    seriesField = options.seriesField,
    data = options.data,
    kde = options.kde;
    var pdfOptions = {
    min: kde.min,
    max: kde.max,
    size: kde.sampleSize,
    width: kde.width
  };
  
  if (!seriesField) {
    var group_1 = (0, _util.groupBy)(data, xField);
    return Object.keys(group_1).map(function (x) {
      var records = group_1[x];
      var values = records.map(function (record) {
        return record[yField];
      });
      return (0, _tslib.__assign)((0, _tslib.__assign)({
        x: x
      }, toViolinValue(values, pdfOptions)), toBoxValue(values));
    });
  }
  
  var resultList = [];
  var seriesGroup = (0, _util.groupBy)(data, seriesField);
  Object.keys(seriesGroup).forEach(function (series) {
    var group = (0, _util.groupBy)(seriesGroup[series], xField);
    return Object.keys(group).forEach(function (key) {
      var _a;
      var records = group[key];
      var values = records.map(function (record) {
        return record[yField];
      });
      resultList.push((0, _tslib.__assign)((0, _tslib.__assign)((_a = {
        x: key
      }, _a[seriesField] = series, _a), toViolinValue(values, pdfOptions)), toBoxValue(values)));
    });
  });
  return resultList;
};
exports.transformViolinData = transformViolinData;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.X_FIELD = exports.VIOLIN_Y_FIELD = exports.VIOLIN_VIEW_ID = exports.VIOLIN_SIZE_FIELD = exports.QUANTILE_VIEW_ID = exports.QUANTILE_FIELD = exports.MIN_MAX_VIEW_ID = exports.MIN_MAX_FIELD = exports.MEDIAN_VIEW_ID = exports.MEDIAN_FIELD = exports.DEFAULT_OPTIONS = void 0;
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var X_FIELD = 'x';
exports.X_FIELD = X_FIELD;
var VIOLIN_Y_FIELD = 'violinY';
exports.VIOLIN_Y_FIELD = VIOLIN_Y_FIELD;
var VIOLIN_SIZE_FIELD = 'violinSize';
exports.VIOLIN_SIZE_FIELD = VIOLIN_SIZE_FIELD;
var MIN_MAX_FIELD = 'minMax';
exports.MIN_MAX_FIELD = MIN_MAX_FIELD;
var QUANTILE_FIELD = 'quantile';
exports.QUANTILE_FIELD = QUANTILE_FIELD;
var MEDIAN_FIELD = 'median';
exports.MEDIAN_FIELD = MEDIAN_FIELD;
var VIOLIN_VIEW_ID = 'violin_view';
exports.VIOLIN_VIEW_ID = VIOLIN_VIEW_ID;
var MIN_MAX_VIEW_ID = 'min_max_view';
exports.MIN_MAX_VIEW_ID = MIN_MAX_VIEW_ID;
var QUANTILE_VIEW_ID = 'quantile_view';
exports.QUANTILE_VIEW_ID = QUANTILE_VIEW_ID;
var MEDIAN_VIEW_ID = 'median_view';
exports.MEDIAN_VIEW_ID = MEDIAN_VIEW_ID;
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  
  syncViewPadding: true,
  
  kde: {
    type: 'triangular',
    sampleSize: 32,
    width: 3
  },
  
  violinStyle: {
    lineWidth: 1,
    fillOpacity: 0.3,
    strokeOpacity: 0.75
  },
  
  xAxis: {
    grid: {
      line: null
    },
    tickLine: {
      alignTick: false
    }
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineWidth: 0.5,
          lineDash: [4, 4]
        }
      }
    }
  },
  
  legend: {
    position: 'top-left'
  },
  
  tooltip: {
    showMarkers: false
  }
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _interopRequireDefault = __webpack_require__(2);
var _typeof2 = _interopRequireDefault(__webpack_require__(6));
(function (global, factory) {
  ( false ? undefined : (0, _typeof2.default)(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(void 0, function (exports) {
  'use strict';

    function bisect(f, a, b, parameters) {
    parameters = parameters || {};
    var maxIterations = parameters.maxIterations || 100,
      tolerance = parameters.tolerance || 1e-10,
      fA = f(a),
      fB = f(b),
      delta = b - a;
    if (fA * fB > 0) {
      throw "Initial bisect points must have opposite signs";
    }
    if (fA === 0) return a;
    if (fB === 0) return b;
    for (var i = 0; i < maxIterations; ++i) {
      delta /= 2;
      var mid = a + delta,
        fMid = f(mid);
      if (fMid * fA >= 0) {
        a = mid;
      }
      if (Math.abs(delta) < tolerance || fMid === 0) {
        return mid;
      }
    }
    return a + delta;
  }

  
  
  function zeros(x) {
    var r = new Array(x);
    for (var i = 0; i < x; ++i) {
      r[i] = 0;
    }
    return r;
  }
  function zerosM(x, y) {
    return zeros(x).map(function () {
      return zeros(y);
    });
  }
  function dot(a, b) {
    var ret = 0;
    for (var i = 0; i < a.length; ++i) {
      ret += a[i] * b[i];
    }
    return ret;
  }
  function norm2(a) {
    return Math.sqrt(dot(a, a));
  }
  function scale(ret, value, c) {
    for (var i = 0; i < value.length; ++i) {
      ret[i] = value[i] * c;
    }
  }
  function weightedSum(ret, w1, v1, w2, v2) {
    for (var j = 0; j < ret.length; ++j) {
      ret[j] = w1 * v1[j] + w2 * v2[j];
    }
  }

    function nelderMead(f, x0, parameters) {
    parameters = parameters || {};
    var maxIterations = parameters.maxIterations || x0.length * 200,
      nonZeroDelta = parameters.nonZeroDelta || 1.05,
      zeroDelta = parameters.zeroDelta || 0.001,
      minErrorDelta = parameters.minErrorDelta || 1e-6,
      minTolerance = parameters.minErrorDelta || 1e-5,
      rho = parameters.rho !== undefined ? parameters.rho : 1,
      chi = parameters.chi !== undefined ? parameters.chi : 2,
      psi = parameters.psi !== undefined ? parameters.psi : -0.5,
      sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,
      maxDiff;

    
    var N = x0.length,
      simplex = new Array(N + 1);
    simplex[0] = x0;
    simplex[0].fx = f(x0);
    simplex[0].id = 0;
    for (var i = 0; i < N; ++i) {
      var point = x0.slice();
      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
      simplex[i + 1] = point;
      simplex[i + 1].fx = f(point);
      simplex[i + 1].id = i + 1;
    }
    function updateSimplex(value) {
      for (var i = 0; i < value.length; i++) {
        simplex[N][i] = value[i];
      }
      simplex[N].fx = value.fx;
    }
    var sortOrder = function sortOrder(a, b) {
      return a.fx - b.fx;
    };
    var centroid = x0.slice(),
      reflected = x0.slice(),
      contracted = x0.slice(),
      expanded = x0.slice();
    for (var iteration = 0; iteration < maxIterations; ++iteration) {
      simplex.sort(sortOrder);
      if (parameters.history) {
        
        
        var sortedSimplex = simplex.map(function (x) {
          var state = x.slice();
          state.fx = x.fx;
          state.id = x.id;
          return state;
        });
        sortedSimplex.sort(function (a, b) {
          return a.id - b.id;
        });
        parameters.history.push({
          x: simplex[0].slice(),
          fx: simplex[0].fx,
          simplex: sortedSimplex
        });
      }
      maxDiff = 0;
      for (i = 0; i < N; ++i) {
        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
      }
      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
        break;
      }

      
      for (i = 0; i < N; ++i) {
        centroid[i] = 0;
        for (var j = 0; j < N; ++j) {
          centroid[i] += simplex[j][i];
        }
        centroid[i] /= N;
      }

      
      
      var worst = simplex[N];
      weightedSum(reflected, 1 + rho, centroid, -rho, worst);
      reflected.fx = f(reflected);

      
      if (reflected.fx < simplex[0].fx) {
        weightedSum(expanded, 1 + chi, centroid, -chi, worst);
        expanded.fx = f(expanded);
        if (expanded.fx < reflected.fx) {
          updateSimplex(expanded);
        } else {
          updateSimplex(reflected);
        }
      }

      
      
      else if (reflected.fx >= simplex[N - 1].fx) {
        var shouldReduce = false;
        if (reflected.fx > worst.fx) {
          
          weightedSum(contracted, 1 + psi, centroid, -psi, worst);
          contracted.fx = f(contracted);
          if (contracted.fx < worst.fx) {
            updateSimplex(contracted);
          } else {
            shouldReduce = true;
          }
        } else {
          
          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
          contracted.fx = f(contracted);
          if (contracted.fx < reflected.fx) {
            updateSimplex(contracted);
          } else {
            shouldReduce = true;
          }
        }
        if (shouldReduce) {
          
          if (sigma >= 1) break;

          
          for (i = 1; i < simplex.length; ++i) {
            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
            simplex[i].fx = f(simplex[i]);
          }
        }
      } else {
        updateSimplex(reflected);
      }
    }
    simplex.sort(sortOrder);
    return {
      fx: simplex[0].fx,
      x: simplex[0]
    };
  }

  
  
  
  
  
  
  
  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
    var phi0 = current.fx,
      phiPrime0 = dot(current.fxprime, pk),
      phi = phi0,
      phi_old = phi0,
      phiPrime = phiPrime0,
      a0 = 0;
    a = a || 1;
    c1 = c1 || 1e-6;
    c2 = c2 || 0.1;
    function zoom(a_lo, a_high, phi_lo) {
      for (var iteration = 0; iteration < 16; ++iteration) {
        a = (a_lo + a_high) / 2;
        weightedSum(next.x, 1.0, current.x, a, pk);
        phi = next.fx = f(next.x, next.fxprime);
        phiPrime = dot(next.fxprime, pk);
        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {
          a_high = a;
        } else {
          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
            return a;
          }
          if (phiPrime * (a_high - a_lo) >= 0) {
            a_high = a_lo;
          }
          a_lo = a;
          phi_lo = phi;
        }
      }
      return 0;
    }
    for (var iteration = 0; iteration < 10; ++iteration) {
      weightedSum(next.x, 1.0, current.x, a, pk);
      phi = next.fx = f(next.x, next.fxprime);
      phiPrime = dot(next.fxprime, pk);
      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {
        return zoom(a0, a, phi_old);
      }
      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
        return a;
      }
      if (phiPrime >= 0) {
        return zoom(a, a0, phi);
      }
      phi_old = phi;
      a0 = a;
      a *= 2;
    }
    return a;
  }
  function conjugateGradient(f, initial, params) {
    
    
    var current = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      },
      next = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      },
      yk = initial.slice(),
      pk,
      temp,
      a = 1,
      maxIterations;
    params = params || {};
    maxIterations = params.maxIterations || initial.length * 20;
    current.fx = f(current.x, current.fxprime);
    pk = current.fxprime.slice();
    scale(pk, current.fxprime, -1);
    for (var i = 0; i < maxIterations; ++i) {
      a = wolfeLineSearch(f, pk, current, next, a);

      
      if (params.history) {
        params.history.push({
          x: current.x.slice(),
          fx: current.fx,
          fxprime: current.fxprime.slice(),
          alpha: a
        });
      }
      if (!a) {
        
        
        scale(pk, current.fxprime, -1);
      } else {
        
        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
        var delta_k = dot(current.fxprime, current.fxprime),
          beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);
        weightedSum(pk, beta_k, pk, -1, next.fxprime);
        temp = current;
        current = next;
        next = temp;
      }
      if (norm2(current.fxprime) <= 1e-5) {
        break;
      }
    }
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a
      });
    }
    return current;
  }
  function gradientDescent(f, initial, params) {
    params = params || {};
    var maxIterations = params.maxIterations || initial.length * 100,
      learnRate = params.learnRate || 0.001,
      current = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      };
    for (var i = 0; i < maxIterations; ++i) {
      current.fx = f(current.x, current.fxprime);
      if (params.history) {
        params.history.push({
          x: current.x.slice(),
          fx: current.fx,
          fxprime: current.fxprime.slice()
        });
      }
      weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
      if (norm2(current.fxprime) <= 1e-5) {
        break;
      }
    }
    return current;
  }
  function gradientDescentLineSearch(f, initial, params) {
    params = params || {};
    var current = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      },
      next = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      },
      maxIterations = params.maxIterations || initial.length * 100,
      learnRate = params.learnRate || 1,
      pk = initial.slice(),
      c1 = params.c1 || 1e-3,
      c2 = params.c2 || 0.1,
      temp,
      functionCalls = [];
    if (params.history) {
      
      var inner = f;
      f = function f(x, fxprime) {
        functionCalls.push(x.slice());
        return inner(x, fxprime);
      };
    }
    current.fx = f(current.x, current.fxprime);
    for (var i = 0; i < maxIterations; ++i) {
      scale(pk, current.fxprime, -1);
      learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);
      if (params.history) {
        params.history.push({
          x: current.x.slice(),
          fx: current.fx,
          fxprime: current.fxprime.slice(),
          functionCalls: functionCalls,
          learnRate: learnRate,
          alpha: learnRate
        });
        functionCalls = [];
      }
      temp = current;
      current = next;
      next = temp;
      if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;
    }
    return current;
  }
  exports.bisect = bisect;
  exports.nelderMead = nelderMead;
  exports.conjugateGradient = conjugateGradient;
  exports.gradientDescent = gradientDescent;
  exports.gradientDescentLineSearch = gradientDescentLineSearch;
  exports.zeros = zeros;
  exports.zerosM = zerosM;
  exports.norm2 = norm2;
  exports.weightedSum = weightedSum;
  exports.scale = scale;
});

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleArea = circleArea;
exports.circleCircleIntersection = circleCircleIntersection;
exports.circleOverlap = circleOverlap;
exports.containedInCircles = containedInCircles;
exports.distance = distance;
exports.getCenter = getCenter;
exports.intersectionArea = intersectionArea;
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  
  var intersectionPoints = getIntersectionPoints(circles);
  
  var innerPoints = intersectionPoints.filter(function (p) {
    return containedInCircles(p, circles);
  });
  var arcArea = 0,
    polygonArea = 0,
    i;
  var arcs = [];
  
  
  if (innerPoints.length > 1) {
    
    
    var center = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      var p = innerPoints[i];
      p.angle = Math.atan2(p.x - center.x, p.y - center.y);
    }
    innerPoints.sort(function (a, b) {
      return b.angle - a.angle;
    });
    
    
    var p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      var p1 = innerPoints[i];
      
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      
      var midPoint = {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
      };
      var arc = null;
      for (var j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          
          
          var circle = circles[p1.parentIndex[j]],
            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);
          var angleDiff = a2 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          
          
          var a = a2 - angleDiff / 2;
          var width = distance(midPoint, {
            x: circle.x + circle.radius * Math.sin(a),
            y: circle.y + circle.radius * Math.cos(a)
          });
          
          
          if (width > circle.radius * 2) {
            width = circle.radius * 2;
          }
          
          if (arc === null || arc.width > width) {
            arc = {
              circle: circle,
              width: width,
              p1: p1,
              p2: p2
            };
          }
        }
      }
      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p2 = p1;
      }
    }
  } else {
    
    
    var smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    
    
    var disjoint = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint = true;
        break;
      }
    }
    if (disjoint) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: {
          x: smallest.x,
          y: smallest.y + smallest.radius
        },
        p2: {
          x: smallest.x - SMALL,
          y: smallest.y + smallest.radius
        },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point, circles) {
  for (var i = 0; i < circles.length; ++i) {
    if (distance(point, circles[i]) > circles[i].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  var ret = [];
  for (var i = 0; i < circles.length; ++i) {
    for (var j = i + 1; j < circles.length; ++j) {
      var intersect = circleCircleIntersection(circles[i], circles[j]);
      for (var k = 0; k < intersect.length; ++k) {
        var p = intersect[k];
        p.parentIndex = [i, j];
        ret.push(p);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d) {
  
  if (d >= r1 + r2) {
    return 0;
  }
  
  if (d <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
    w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  var d = distance(p1, p2),
    r1 = p1.radius,
    r2 = p2.radius;
  
  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
    return [];
  }
  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
    h = Math.sqrt(r1 * r1 - a * a),
    x0 = p1.x + a * (p2.x - p1.x) / d,
    y0 = p1.y + a * (p2.y - p1.y) / d,
    rx = -(p2.y - p1.y) * (h / d),
    ry = -(p2.x - p1.x) * (h / d);
  return [{
    x: x0 + rx,
    y: y0 - ry
  }, {
    x: x0 - rx,
    y: y0 + ry
  }];
}
function getCenter(points) {
  var center = {
    x: 0,
    y: 0
  };
  for (var i = 0; i < points.length; ++i) {
    center.x += points[i].x;
    center.y += points[i].y;
  }
  center.x /= points.length;
  center.y /= points.length;
  return center;
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStockData = getStockData;
var _util = __webpack_require__(0);
var _constant = __webpack_require__(310);
function getStockData(data, yField) {
  return (0, _util.map)(data, function (obj) {
    if ((0, _util.isArray)(yField)) {
      var open_1 = yField[0],
        close_1 = yField[1],
        high = yField[2],
        low = yField[3];
      obj[_constant.TREND_FIELD] = obj[open_1] <= obj[close_1] ? _constant.TREND_UP : _constant.TREND_DOWN;
      obj[_constant.Y_FIELD] = [obj[open_1], obj[close_1], obj[high], obj[low]];
    }
    return obj;
  });
}

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FUNNEL_CONVERSATION_FIELD", {
  enumerable: true,
  get: function get() {
    return _constant.FUNNEL_CONVERSATION;
  }
});
exports.Funnel = void 0;
var _tslib = __webpack_require__(1);
var _util = __webpack_require__(0);
var _plot = __webpack_require__(19);
var _utils = __webpack_require__(7);
var _adaptor = __webpack_require__(589);
var _constant = __webpack_require__(125);
var Funnel = function (_super) {
  (0, _tslib.__extends)(Funnel, _super);
  function Funnel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'funnel';
    return _this;
  }
  Funnel.getDefaultOptions = function () {
    return _constant.DEFAULT_OPTIONS;
  };
    Funnel.prototype.getDefaultOptions = function () {
    
    return Funnel.getDefaultOptions();
  };
    Funnel.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
    Funnel.prototype.setState = function (type, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = (0, _utils.getAllElementsRecursively)(this.chart);
    (0, _util.each)(elements, function (ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
    Funnel.prototype.getStates = function () {
    var elements = (0, _utils.getAllElementsRecursively)(this.chart);
    var stateObjects = [];
    (0, _util.each)(elements, function (element) {
      var data = element.getData();
      var states = element.getStates();
      (0, _util.each)(states, function (state) {
        stateObjects.push({
          data: data,
          state: state,
          geometry: element.geometry,
          element: element
        });
      });
    });
    return stateObjects;
  };
  
    Funnel.CONVERSATION_FIELD = _constant.FUNNEL_CONVERSATION;
    Funnel.PERCENT_FIELD = _constant.FUNNEL_PERCENT;
    Funnel.TOTAL_PERCENT_FIELD = _constant.FUNNEL_TOTAL_PERCENT;
  return Funnel;
}(_plot.Plot);
exports.Funnel = Funnel;

 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;
exports.meta = meta;
var _util = __webpack_require__(0);
var _common = __webpack_require__(22);
var _locale = __webpack_require__(196);
var _utils = __webpack_require__(7);
var _conversion = __webpack_require__(551);
var _basic = __webpack_require__(590);
var _compare = __webpack_require__(1253);
var _facet = __webpack_require__(1254);
var _dynamicHeight = __webpack_require__(1255);
var _constant = __webpack_require__(125);
